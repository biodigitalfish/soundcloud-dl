import{L as p}from"./logger-scdl-C1suKzoJ.js";const c=p.create("Browser-Utils");function y(){try{if(typeof chrome<"u"&&chrome.runtime&&chrome.runtime.getManifest)return chrome.runtime.getManifest().manifest_version===3;if(typeof browser<"u"&&browser.runtime&&browser.runtime.getManifest)return browser.runtime.getManifest().manifest_version===3}catch(e){c.logWarn("Failed to detect manifest version:",e)}return!1}function v(){return typeof self<"u"&&typeof window>"u"&&y()}function h(){return typeof chrome<"u"&&chrome.declarativeNetRequest&&y()}const E=1,R=2;async function C(e){if(!h()){c.logDebug("Skipping declarativeNetRequest OAuth rule update: DNR not used for modification in this environment.");return}const r=[],o=[E];e&&r.push({id:E,priority:1,action:{type:chrome.declarativeNetRequest.RuleActionType.MODIFY_HEADERS,requestHeaders:[{header:"authorization",operation:chrome.declarativeNetRequest.HeaderOperation.SET,value:`OAuth ${e}`}]},condition:{urlFilter:"*://api-v2.soundcloud.com/*",resourceTypes:[chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST]}});try{typeof chrome<"u"&&chrome.declarativeNetRequest?(await chrome.declarativeNetRequest.updateDynamicRules({removeRuleIds:o,addRules:r}),c.logInfo(`OAuth DNR rule updated. Token: ${e?"SET":"REMOVED"}`)):c.logError("Cannot update DNR rules: chrome.declarativeNetRequest is not defined.")}catch(t){c.logError("Failed to update DNR rules for OAuth token:",t)}}async function L(e){if(!h()){c.logDebug("Skipping declarativeNetRequest ClientID rule update: DNR not used for modification in this environment.");return}const r=[],o=[R];e&&(r.push({id:R,priority:2,action:{type:chrome.declarativeNetRequest.RuleActionType.REDIRECT,redirect:{transform:{queryTransform:{addOrReplaceParams:[{key:"client_id",value:e}]}}}},condition:{urlFilter:"*://api-v2.soundcloud.com/*",excludedRequestDomains:[],resourceTypes:[chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST]}}),r[0].condition={urlFilter:"*://api-v2.soundcloud.com/*",resourceTypes:[chrome.declarativeNetRequest.ResourceType.XMLHTTPREQUEST]});try{typeof chrome<"u"&&chrome.declarativeNetRequest?(await chrome.declarativeNetRequest.updateDynamicRules({removeRuleIds:o,addRules:r}),c.logInfo(`Client_id DNR rule updated. ClientID: ${e?"SET":"REMOVED"}`)):c.logError("Cannot update DNR rules: chrome.declarativeNetRequest is not defined.")}catch(t){c.logError("Failed to update DNR rules for client_id:",t)}}async function D(e){if(typeof URL<"u"&&typeof URL.createObjectURL=="function")try{return c.logDebug("Using URL.createObjectURL"),URL.createObjectURL(e)}catch(r){c.logWarn("URL.createObjectURL failed:",r)}c.logInfo("Falling back to FileReader.readAsDataURL");try{const r=new FileReader;return await new Promise((o,t)=>{r.onload=()=>o(r.result),r.onerror=a=>t(new Error(`FileReader failed: ${a}`)),r.readAsDataURL(e)})}catch(r){throw c.logError("Both URL creation methods failed:",r),new Error(`Failed to create URL from blob: ${r.message}`)}}function g(e){if(e&&e.startsWith("blob:"))try{URL.revokeObjectURL(e),c.logDebug("Object URL revoked")}catch(r){c.logWarn("Failed to revoke object URL:",r)}}function S(e){if(typeof chrome<"u"&&chrome.downloads&&chrome.downloads.erase){const r={filenameRegex:e,state:"complete"};chrome.downloads.erase(r,o=>{o&&o.length>0?c.logInfo(`Force redownload: Removed ${o.length} matching entries from browser download history.`):c.logDebug("Force redownload: No matching entries found in browser download history to erase.")})}else c.logDebug("Skipping browser download history erase: chrome.downloads.erase is not available.")}function M(e,r){let o=r;return!o&&typeof browser<"u"&&e&&(e.includes("/sets/")||e.includes("/albums/"))&&(c.logDebug(`[BrowserUtils] Firefox detected, forcing isSet=true for URL: ${e}`),o=!0),o}const s=p.create("Compatibility Stubs"),b="soundcloud-dl-bridge",T=e=>{typeof browser<"u"&&browser.runtime&&browser.runtime.onMessage?browser.runtime.onMessage.addListener((r,o)=>o.id!==browser.runtime.id||!r?Promise.resolve({error:"Invalid message or sender from extension"}):e(r,o).catch(t=>(s.logError("Error in originalRuntimeOnMessage callback (Firefox):",t),Promise.reject({error:t?.message||"Unknown error in callback"})))):typeof chrome<"u"&&chrome.runtime&&chrome.runtime.onMessage?chrome.runtime.onMessage.addListener((r,o,t)=>o.id!==chrome.runtime.id||!r?(t({error:"Invalid message or sender from extension"}),!1):(e(r,o).then(a=>t(a)).catch(a=>{s.logError("Error in originalRuntimeOnMessage callback (Chrome), responding with error:",a),t({error:a?.message||"Unknown error in callback"})}),!0)):s.logError("[CompatibilityStubs] originalRuntimeOnMessage: Browser does not support runtime.onMessage")},U=e=>{(typeof chrome>"u"||typeof chrome.runtime>"u"||typeof chrome.runtime.id>"u")&&typeof window<"u"?(s.logDebug("[CompatibilityStubs] onMessage: Setting up window.addEventListener for page context."),window.addEventListener("message",r=>{let o="<No Data>",t="<No Direction Property>",a="<No Source Property>";try{r.data&&(o=JSON.stringify(r.data),typeof r.data.direction=="string"&&(t=r.data.direction),typeof r.data.source=="string"&&(a=r.data.source))}catch{o="<Error Stringifying Data>"}s.logInfo(`[CompatStubs Listener Raw Detail] Received window message: sourceIsWindow=${r.source===window}, event.data.source='${a}', SCRIPT_ID='${b}', event.data.direction='${t}', expectedDirection='from-background-via-bridge', FullData=${o}`);const i=r.source===window,n=!!r.data;let l=!1,w=!1,u="<event.data was null>",d="<event.data was null>";if(n&&(u=r.data.source,d=r.data.direction,l=r.data.source===b,w=r.data.direction==="from-background-via-bridge"),s.logInfo(`[CompatStubs EVAL CHECK] cond1 (event.source === window): ${i}`),s.logInfo(`[CompatStubs EVAL CHECK] cond2 (!!event.data): ${n}`),s.logInfo(`[CompatStubs EVAL CHECK] cond3 (event.data.source === SCRIPT_ID): ${l} (event.data?.source: '${u}', SCRIPT_ID: '${b}')`),s.logInfo(`[CompatStubs EVAL CHECK] cond4 (event.data.direction === "from-background-via-bridge"): ${w} (event.data?.direction: '${d}')`),s.logInfo(`[CompatStubs EVAL CHECK] Full event.data for this check: ${o}`),i&&n&&l&&w){s.logDebug(">>> COMPATIBILITY STUBS: PAGE CONTEXT LISTENER: PASSED ALL FILTERS! <<< Payload:",JSON.stringify(r.data.payload));const m={id:typeof chrome<"u"&&chrome.runtime?chrome.runtime.id:void 0};e(r.data.payload,m).catch(f=>s.logError("Error in onMessage callback (page context):",f))}else i&&n&&l&&r.data&&r.data.direction==="to-background-via-bridge"||s.logWarn(`[CompatStubs FILTER FAILED] Conditions: cond1=${i}, cond2=${n}, cond3=${l}, cond4=${w}. Full event.data: ${o}`)})):(s.logDebug("[CompatibilityStubs] onMessage: Using original runtime.onMessage for extension context."),T(e))},I=(e,r,o)=>{const t={urls:r||[]};if(typeof browser<"u"&&browser.webRequest&&browser.webRequest.onBeforeSendHeaders)browser.webRequest.onBeforeSendHeaders.addListener(e,t,o);else if(typeof chrome<"u"&&chrome.webRequest&&chrome.webRequest.onBeforeSendHeaders){let a=o;chrome.runtime.getManifest().manifest_version===3&&o&&(a=o.filter(i=>i!=="blocking")),chrome.webRequest.onBeforeSendHeaders.addListener(e,t,a)}else s.logError("Browser does not support webRequest.onBeforeSendHeaders")},q=(e,r,o)=>{const t={urls:r||[]};if(typeof browser<"u"&&browser.webRequest&&browser.webRequest.onBeforeRequest)browser.webRequest.onBeforeRequest.addListener(e,t,o);else if(typeof chrome<"u"&&chrome.webRequest&&chrome.webRequest.onBeforeRequest){let a=o;chrome.runtime.getManifest().manifest_version===3&&o&&(a=o.filter(i=>i!=="blocking")),chrome.webRequest.onBeforeRequest.addListener(e,t,a)}else s.logError("Browser does not support webRequest.onBeforeRequest")},B=(e,r,o)=>{const t={url:e,filename:r,saveAs:o,conflictAction:"uniquify"};return new Promise((a,i)=>{let n,l;const w=(u,d)=>{l=m=>{if(m.id===d)if(m.state?.current==="complete")l&&u.downloads.onChanged.removeListener(l),g(e),s.logInfo(`Download ${d} completed and cleaned up.`);else if(m.state?.current==="interrupted"||m.error&&m.error.current!=="USER_CANCELED"&&m.error.current!=="DOWNLOAD_CANCELLED_BY_USER"){l&&u.downloads.onChanged.removeListener(l);const f=m.error?.current||m.error?.message||"Download was interrupted";s.logWarn(`Download ${d} failed or interrupted post-initiation: ${f}`),g(e)}else m.error&&(m.error.current==="USER_CANCELED"||m.error.current==="DOWNLOAD_CANCELLED_BY_USER")&&(s.logInfo(`Download ${d} was canceled by the user.`),l&&u.downloads.onChanged.removeListener(l),g(e))},u.downloads.onChanged.addListener(l)};typeof browser<"u"&&browser.downloads?browser.downloads.download(t).then(u=>{if(u===void 0){const d=browser.runtime.lastError?.message||"Download initiation failed in Firefox: No downloadId returned.";s.logError("Firefox download initiation error (no id):",d),g(e),i(new Error(d));return}n=u,w(browser,n),a(n)}).catch(u=>{const d=u?.message||String(u)||"browser.downloads.download call failed";s.logError("Firefox browser.downloads.download promise rejected:",d),g(e),i(new Error(`Firefox download failed: ${d}`))}):typeof chrome<"u"&&chrome.downloads?chrome.downloads.download(t,u=>{if(chrome.runtime.lastError){const d=chrome.runtime.lastError.message||"Download initiation failed in Chrome (callback error)";s.logError("Chrome download initiation error (lastError):",d),g(e),i(new Error(d));return}if(u===void 0){const d="Download initiation failed: no downloadId returned (Chrome).";s.logError(d),g(e),i(new Error(d));return}n=u,w(chrome,n),a(n)}):(g(e),i(new Error("Browser does not support downloads.download API")))})},N=e=>(typeof chrome>"u"||typeof chrome.runtime>"u"||typeof chrome.runtime.id>"u")&&typeof window<"u"?(s.logDebug("[CompatibilityStubs] sendMessageToBackend: Using window.postMessage via bridge.",e),new Promise((r,o)=>{const t=crypto.randomUUID(),a={source:b,direction:"to-background-via-bridge",payload:e,messageId:t},i=n=>{n.source===window&&n.data&&n.data.source===b&&n.data.direction==="from-background-via-bridge"&&n.data.payload&&n.data.messageId===t&&(window.removeEventListener("message",i),n.data.payload.error?(s.logWarn("[CompatibilityStubs] Error response from bridge:",n.data.payload.error),o(new Error(n.data.payload.error))):r(n.data.payload))};window.addEventListener("message",i),window.postMessage(a,"*"),setTimeout(()=>{window.removeEventListener("message",i),o(new Error("Timeout waiting for response from bridge for sendMessageToBackend"))},15e3)})):typeof browser<"u"&&browser.runtime&&browser.runtime.sendMessage?(s.logDebug("[CompatibilityStubs] sendMessageToBackend: Using browser.runtime.sendMessage.",e),browser.runtime.sendMessage(e)):typeof chrome<"u"&&chrome.runtime&&chrome.runtime.sendMessage?(s.logDebug("[CompatibilityStubs] sendMessageToBackend: Using chrome.runtime.sendMessage.",e),new Promise((r,o)=>{chrome.runtime.sendMessage(e,t=>{if(chrome.runtime.lastError)return s.logError("[CompatibilityStubs] sendMessageToBackend lastError:",chrome.runtime.lastError),o(chrome.runtime.lastError);r(t)})})):(s.logError("[CompatibilityStubs] sendMessageToBackend: Browser does not support runtime.sendMessage and not in page context for bridge."),Promise.reject(new Error("Browser does not support runtime.sendMessage"))),P=(e,r)=>typeof browser<"u"&&browser.tabs&&browser.tabs.sendMessage?browser.tabs.sendMessage(e,r).catch(o=>{const t=o&&o.message?o.message.toLowerCase():"";return t.includes("receiving end does not exist")||t.includes("could not establish connection")?(s.logDebug(`[CompatibilityStubs sendMessageToTab FF] Tab ${e} not available or content script not ready. Message:`,r),Promise.resolve({ScdlCompatStubTabUnavailable:!0,tabId:e,browser:"firefox"})):(s.logWarn(`[CompatibilityStubs sendMessageToTab FF] Error sending message to tab ${e}:`,o,"Original message:",r),Promise.reject(o))}):typeof chrome<"u"&&chrome.tabs&&chrome.tabs.sendMessage?new Promise((o,t)=>{chrome.tabs.sendMessage(e,r,a=>{if(chrome.runtime.lastError){const i=chrome.runtime.lastError.message?chrome.runtime.lastError.message.toLowerCase():"";i.includes("receiving end does not exist")||i.includes("could not establish connection")?(s.logDebug(`[CompatibilityStubs sendMessageToTab Chrome] Tab ${e} not available or content script not ready (lastError: ${chrome.runtime.lastError.message}). Message:`,r),o({ScdlCompatStubTabUnavailable:!0,tabId:e,browser:"chrome"})):(s.logWarn(`[CompatibilityStubs sendMessageToTab Chrome] chrome.runtime.lastError sending to tab ${e}:`,chrome.runtime.lastError,"Original message:",r),t(chrome.runtime.lastError))}else o(a)})}):(s.logError("[CompatibilityStubs sendMessageToTab] Browser does not support tabs.sendMessage"),Promise.reject(new Error("Browser does not support tabs.sendMessage"))),$=e=>{typeof browser<"u"&&browser.storage&&browser.storage.onChanged?browser.storage.onChanged.addListener(e):typeof chrome<"u"&&chrome.storage&&chrome.storage.onChanged?chrome.storage.onChanged.addListener(e):s.logError("Browser does not support storage.onChanged")},k=e=>typeof browser<"u"&&browser.storage&&browser.storage.sync?browser.storage.sync.set(e):typeof chrome<"u"&&chrome.storage&&chrome.storage.sync?new Promise((r,o)=>{chrome.storage.sync.set(e,()=>{if(chrome.runtime.lastError)return o(chrome.runtime.lastError);r()})}):Promise.reject("Browser does not support storage.sync.set"),F=e=>typeof browser<"u"&&browser.storage&&browser.storage.sync?browser.storage.sync.get(e):typeof chrome<"u"&&chrome.storage&&chrome.storage.sync?new Promise((r,o)=>{chrome.storage.sync.get(e??null,t=>{if(chrome.runtime.lastError)return o(chrome.runtime.lastError);r(t)})}):Promise.reject("Browser does not support storage.sync.get"),A=e=>typeof browser<"u"&&browser.storage&&browser.storage.local?browser.storage.local.set(e):typeof chrome<"u"&&chrome.storage&&chrome.storage.local?new Promise((r,o)=>{chrome.storage.local.set(e,()=>{if(chrome.runtime.lastError)return o(chrome.runtime.lastError);r()})}):Promise.reject("Browser does not support storage.local.set"),O=e=>typeof browser<"u"&&browser.storage&&browser.storage.local?browser.storage.local.get(e):typeof chrome<"u"&&chrome.storage&&chrome.storage.local?new Promise((r,o)=>{chrome.storage.local.get(e??null,t=>{if(chrome.runtime.lastError)return o(chrome.runtime.lastError);r(t)})}):Promise.reject("Browser does not support storage.local.get"),x=()=>typeof browser<"u"&&browser.runtime&&browser.runtime.getManifest?browser.runtime.getManifest():typeof chrome<"u"&&chrome.runtime&&chrome.runtime.getManifest?chrome.runtime.getManifest():(s.logError("Browser does not support runtime.getManifest"),null),_=e=>typeof browser<"u"&&browser.runtime&&browser.runtime.getURL?browser.runtime.getURL(e):typeof chrome<"u"&&chrome.runtime&&chrome.runtime.getURL?chrome.runtime.getURL(e):(s.logError("Browser does not support runtime.getURL"),null),j=e=>typeof browser<"u"&&browser.downloads&&browser.downloads.search?browser.downloads.search(e).then(r=>r.map(o=>({...o,finalUrl:o.url}))):typeof chrome<"u"&&chrome.downloads&&chrome.downloads.search?new Promise(r=>{chrome.downloads.search(e,r)}):(s.logError("Browser does not support downloads.search"),Promise.resolve([]));export{j as a,x as b,D as c,B as d,I as e,q as f,_ as g,C as h,v as i,L as j,S as k,N as l,M as m,$ as n,U as o,k as p,A as q,O as r,P as s,F as t,h as u};
