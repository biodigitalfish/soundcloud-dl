import{L as x,a as X}from"./logger-scdl-C1suKzoJ.js";import{s as oe,g as tt,a as fe,i as rt,c as at,d as st,b as nt,o as it,e as ot,f as lt,h as gt,j as dt,u as De}from"./compatibilityStubs-scdl-DBF9jRnU.js";import{l as Re,c as ct,g as S,a as ke,X as Se,b as Fe,d as ut,s as le,e as ve,f as M,r as he}from"./config-scdl-BL_5oI80.js";class ge extends Error{constructor(t){super(t),this.name="RateLimitError"}}class _e{baseUrl="https://api-v2.soundcloud.com";logger;globalBackoffUntil=null;globalBackoffDurationMs=61*1e3;constructor(){this.logger=x.create("SoundCloudApi")}async retryWithBackoff(t,e=30,r=2e3,s){if(this.globalBackoffUntil&&Date.now()<this.globalBackoffUntil){const c=this.globalBackoffUntil-Date.now();this.logger.logWarn(`[Global Backoff] Active. Waiting for ${c/1e3}s before proceeding with ${s||"operation"}.`),await new Promise(d=>setTimeout(d,c))}let n=0,i=r;for(;n<=e;)try{if(this.globalBackoffUntil&&Date.now()<this.globalBackoffUntil){const c=this.globalBackoffUntil-Date.now();this.logger.logWarn(`[Global Backoff] Active during retry attempt. Waiting for ${c/1e3}s for ${s||"operation"}.`),await new Promise(d=>setTimeout(d,c))}return this.logger.logDebug(`[Retry] Attempt ${n+1}/${e+1} for ${s||"operation"}`),await t()}catch(c){if(c instanceof ge)if(n<e)n++,this.logger.logWarn(`[Retry] Rate limit hit for ${s||"operation"}. Retrying in ${i/1e3}s... (Attempt ${n+1}/${e+1})`),await new Promise(d=>setTimeout(d,i)),i*=2;else throw this.logger.logError(`[Retry] Failed for ${s||"operation"} after ${n+1} attempts due to rate limit. Activating global backoff.`),this.globalBackoffUntil=Date.now()+this.globalBackoffDurationMs,this.logger.logWarn(`[Global Backoff] Activated for ${this.globalBackoffDurationMs/1e3}s due to persistent rate limiting on ${s||"operation"}.`),c;else throw this.logger.logError(`[Retry] Failed for ${s||"operation"} after ${n+1} attempts or non-retryable error:`,c),c}const o=`[Retry] Exhausted retries for ${s||"operation"} without success (this path should not be reached).`;throw this.logger.logError(o),new Error(o)}resolveUrl(t){const e=`${this.baseUrl}/resolve?url=${t}`;return this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`resolveUrl: ${t}`)}getCurrentUser(){const t=`${this.baseUrl}/me`;return this.retryWithBackoff(()=>this._fetchJsonInternal(t),3,2e3,"getCurrentUser")}async getFollowedArtistIds(t){const e=`${this.baseUrl}/users/${t}/followings/ids`,r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getFollowedArtistIds: ${t}`);return!r||!r.collection?null:r.collection}async getTracks(t){const e=`${this.baseUrl}/tracks?ids=${t.join(",")}`;this.logger.logInfo("Fetching tracks with Ids",{trackIds:t});const r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getTracks: ${t.length} IDs`);return t.reduce((s,n,i)=>(s[n]=r[i],s),{})}async getStreamDetails(t){const e=await this.retryWithBackoff(()=>this._fetchJsonInternal(t),3,2e3,`getStreamDetails: ${t}`);if(!e||!e.url)return this.logger.logError("Invalid stream response",e),null;let r,s=!1;const n=/(?:(\w{3,4})\/playlist)?\.(\w{3,4})(?:$|\?)/.exec(e.url);return n.length>=2&&(n[2]==="m3u8"?(r=n[1],s=!0):r=n[2]),{url:e.url,extension:r,hls:s}}async getOriginalDownloadUrl(t){const e=`${this.baseUrl}/tracks/${t}/download`;this.logger.logInfo("Getting original download URL for track with Id",t);try{const r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getOriginalDownloadUrl: ${t}`);return!r||!r.redirectUri?(this.logger.logError("Invalid original file response",r),null):r.redirectUri}catch(r){return this.logger.logError(`Failed to get original download URL for track ${t} after retries`,r),null}}async downloadArtwork(t){const[e]=await this.retryWithBackoff(()=>this._fetchArrayBufferInternal(t),3,2e3,`downloadArtwork: ${t}`);return e}downloadStream(t,e){return this.retryWithBackoff(()=>this._fetchArrayBufferInternal(t,e),3,1e3,`downloadStream: ${t}`)}async _fetchArrayBufferInternal(t,e){try{const r=await fetch(t);if(!r.ok){if(r.status===404)return this.logger.logDebug(`[fetchArrayBuffer] Resource not found (404) for ${t}`),[null,r.headers];if(r.status===429)throw this.logger.logWarn(`[fetchArrayBuffer] Rate limited (429) while fetching ${t}.`),new ge(`Rate limited (status 429) on ${t}`);const b=`[fetchArrayBuffer] HTTP error for ${t} - Status: ${r.status} ${r.statusText}`;throw new Error(b)}if(!r.body)throw this.logger.logError(`Response for ${t} has no body, despite response.ok being true.`),new Error(`Response for ${t} has no body.`);const s=r.headers.get("Content-Length"),n=s?parseInt(s,10):0;let i=0;const o=[],c=r.body.getReader();for(e&&n>0&&e(0);;){const{done:b,value:$}=await c.read();if(b)break;o.push($),i+=$.byteLength,e&&n>0&&e(Math.round(i/n*100))}e&&e(100);const d=new ArrayBuffer(i),f=new Uint8Array(d);let p=0;for(const b of o)f.set(b,p),p+=b.byteLength;return i===0&&r.status===200&&this.logger.logWarn(`[fetchArrayBuffer] Fetched ${t} (Status: ${r.status}) but received an empty (0 bytes) buffer.`),[d,r.headers]}catch(r){throw this.logger.logError(`[fetchArrayBuffer] Generic error for ${t}:`,r),r instanceof ge?r:new Error(`Failed to fetch array buffer from ${t}: ${r instanceof Error?r.message:String(r)}`)}}async _fetchJsonInternal(t){try{const e=await fetch(t);if(!e.ok)if(e.status===429){const s=`Rate limited while fetching from ${t}. Please wait and try again later.`;throw this.logger.logWarn(s),new ge(s)}else{const s=`HTTP error ${e.status} while fetching from ${t}`;throw this.logger.logError(s),new Error(s)}return await e.json()||null}catch{return this.logger.logError("Failed to fetch JSON from",t),null}}}const ft="DOWNLOAD_SET",ht="DOWNLOAD",mt="DOWNLOAD_SET_RANGE",pt="PAUSE_DOWNLOAD",Et="RESUME_DOWNLOAD",me="GET_QUEUE_DATA",de="GET_EXTENSION_CONFIG",Oe={},O=x.create("MessageHandler",X.Debug);async function wt(a,t){let e={};try{e=JSON.parse(JSON.stringify(a))}catch{e={errorParsingMessage:!0,rawMessage:String(a)}}O.logDebug("[MessageHandler DEBUG] Received message:",e);const r=[de,me];(!a||a.downloadId===void 0&&a.type!==void 0&&!r.includes(a.type))&&O.logError(`CRITICAL: MessageHandler received message with type ${a.type} that requires a downloadId, but it was missing!`,e);const s=t.tab?.id,{downloadId:n,url:i,type:o}=a,c=[de,me];if(!s&&o&&!c.includes(o))return O.logWarn(`Message type ${o} received without a valid tab ID and is not allowed.`,{sender:t,message:a}),{error:`No valid tab ID found for message type ${o}`};if(o===de){O.logDebug(`[MessageHandler] Received GET_EXTENSION_CONFIG request from tab ${s}`);try{const d=await Re(!1),f={};for(const p of ct)d[p].secret||(f[p]={value:d[p].value});return O.logDebug("[MessageHandler] Sending non-secret configuration to content script:",f),Promise.resolve(f)}catch(d){return O.logError("[MessageHandler] Error loading or preparing configuration for content script:",d),Promise.reject({error:"Failed to retrieve extension configuration."})}}if(o&&!c.includes(o)&&!s)return O.logError(`CRITICAL: Message type ${o} requires a tabId, but it was missing after initial checks.`,{sender:t,message:a}),{error:`Missing tab ID for message type ${o}`};if(o===ht||o===ft||o===mt){if(!s)return O.logError(`CRITICAL: Download operation ${o} missing tabId.`),{error:"Download operations require a tabId."};O.logInfo(`[MessageHandler] Queuing request: ${o} for URL: ${i} with ID: ${n}`);const d={id:n,type:o,url:i,originalMessage:a,status:"pending",tabId:s,addedAt:Date.now()};L.push(d),O.logDebug(`[MessageHandler] Item added to queue. Current queue size: ${L.length}`,d),ne();const f={success:!0,message:`${o} request added to queue.`,originalDownloadId:n};return oe(s,f).then(()=>O.logInfo(`[MessageHandler TX Ack] Queued ACK for ${n} sent to tab ${s}.`)).catch(p=>O.logError(`[MessageHandler TX Ack] Queued ACK for ${n} FAILED to send to tab ${s}:`,p)),$e(),Promise.resolve(f)}else if(o===pt){if(!s)return{error:"Pause ops require tabId"};const d=a;return O.logInfo(`Received pause request for download: ${d.downloadId}`),Oe[d.downloadId]=!0,G(s,d.downloadId,void 0,void 0,"Paused"),{success:!0,action:"paused",downloadId:d.downloadId}}else if(o===Et){if(!s)return{error:"Resume ops require tabId"};const d=a;O.logInfo(`Received resume request for download: ${d.downloadId}`),delete Oe[d.downloadId];const f=L.find(p=>p.id===d.downloadId);return f&&f.status==="pending"?O.logInfo(`Resume for pending item ${f.id}. Will be picked by processor.`):f&&f.status==="processing"&&O.logInfo(`Resume for actively processing item ${f.id}. Processor will handle.`),$e(),G(s,d.downloadId,void 0,void 0,"Resuming"),{success:!0,action:"resumed",downloadId:d.downloadId}}else{if(o===me)return O.logInfo("[MessageHandler] Received GET_QUEUE_DATA request (likely from popup)."),Promise.resolve(L);if(o!==de)return O.logWarn(`[MessageHandler] Unknown message type received: ${o}`,a),Promise.reject({error:`Unknown message type: ${o}`})}}var I;(function(a){a.LOAD="LOAD",a.EXEC="EXEC",a.FFPROBE="FFPROBE",a.WRITE_FILE="WRITE_FILE",a.READ_FILE="READ_FILE",a.DELETE_FILE="DELETE_FILE",a.RENAME="RENAME",a.CREATE_DIR="CREATE_DIR",a.LIST_DIR="LIST_DIR",a.DELETE_DIR="DELETE_DIR",a.ERROR="ERROR",a.DOWNLOAD="DOWNLOAD",a.PROGRESS="PROGRESS",a.LOG="LOG",a.MOUNT="MOUNT",a.UNMOUNT="UNMOUNT"})(I||(I={}));const bt=(()=>{let a=0;return()=>a++})(),yt=new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),Tt=new Error("called FFmpeg.terminate()");class It{#t=null;#a={};#r={};#s=[];#n=[];loaded=!1;#i=()=>{this.#t&&(this.#t.onmessage=({data:{id:t,type:e,data:r}})=>{switch(e){case I.LOAD:this.loaded=!0,this.#a[t](r);break;case I.MOUNT:case I.UNMOUNT:case I.EXEC:case I.FFPROBE:case I.WRITE_FILE:case I.READ_FILE:case I.DELETE_FILE:case I.RENAME:case I.CREATE_DIR:case I.LIST_DIR:case I.DELETE_DIR:this.#a[t](r);break;case I.LOG:this.#s.forEach(s=>s(r));break;case I.PROGRESS:this.#n.forEach(s=>s(r));break;case I.ERROR:this.#r[t](r);break}delete this.#a[t],delete this.#r[t]})};#e=({type:t,data:e},r=[],s)=>this.#t?new Promise((n,i)=>{const o=bt();this.#t&&this.#t.postMessage({id:o,type:t,data:e},r),this.#a[o]=n,this.#r[o]=i,s?.addEventListener("abort",()=>{i(new DOMException(`Message # ${o} was aborted`,"AbortError"))},{once:!0})}):Promise.reject(yt);on(t,e){t==="log"?this.#s.push(e):t==="progress"&&this.#n.push(e)}off(t,e){t==="log"?this.#s=this.#s.filter(r=>r!==e):t==="progress"&&(this.#n=this.#n.filter(r=>r!==e))}load=({classWorkerURL:t,...e}={},{signal:r}={})=>(this.#t||(this.#t=t?new Worker(new URL(t,import.meta.url),{type:"module"}):new Worker(new URL("/assets/worker-BAOIWoxA.js",import.meta.url),{type:"module"}),this.#i()),this.#e({type:I.LOAD,data:e},void 0,r));exec=(t,e=-1,{signal:r}={})=>this.#e({type:I.EXEC,data:{args:t,timeout:e}},void 0,r);ffprobe=(t,e=-1,{signal:r}={})=>this.#e({type:I.FFPROBE,data:{args:t,timeout:e}},void 0,r);terminate=()=>{const t=Object.keys(this.#r);for(const e of t)this.#r[e](Tt),delete this.#r[e],delete this.#a[e];this.#t&&(this.#t.terminate(),this.#t=null,this.loaded=!1)};writeFile=(t,e,{signal:r}={})=>{const s=[];return e instanceof Uint8Array&&s.push(e.buffer),this.#e({type:I.WRITE_FILE,data:{path:t,data:e}},s,r)};mount=(t,e,r)=>{const s=[];return this.#e({type:I.MOUNT,data:{fsType:t,options:e,mountPoint:r}},s)};unmount=t=>{const e=[];return this.#e({type:I.UNMOUNT,data:{mountPoint:t}},e)};readFile=(t,e="binary",{signal:r}={})=>this.#e({type:I.READ_FILE,data:{path:t,encoding:e}},void 0,r);deleteFile=(t,{signal:e}={})=>this.#e({type:I.DELETE_FILE,data:{path:t}},void 0,e);rename=(t,e,{signal:r}={})=>this.#e({type:I.RENAME,data:{oldPath:t,newPath:e}},void 0,r);createDir=(t,{signal:e}={})=>this.#e({type:I.CREATE_DIR,data:{path:t}},void 0,e);listDir=(t,{signal:e}={})=>this.#e({type:I.LIST_DIR,data:{path:t}},void 0,e);deleteDir=(t,{signal:e}={})=>this.#e({type:I.DELETE_DIR,data:{path:t}},void 0,e)}var Ne;(function(a){a.MEMFS="MEMFS",a.NODEFS="NODEFS",a.NODERAWFS="NODERAWFS",a.IDBFS="IDBFS",a.WORKERFS="WORKERFS",a.PROXYFS="PROXYFS"})(Ne||(Ne={}));const At=new Error("failed to get response body reader"),$t=new Error("failed to complete download"),Dt="Content-Length",Rt=async(a,t)=>{const e=await fetch(a);let r;try{const s=parseInt(e.headers.get(Dt)||"-1"),n=e.body?.getReader();if(!n)throw At;const i=[];let o=0;for(;;){const{done:f,value:p}=await n.read(),b=p?p.length:0;if(f){if(s!=-1&&s!==o)throw $t;t&&t({url:a,total:s,received:o,delta:b,done:f});break}i.push(p),o+=b,t&&t({url:a,total:s,received:o,delta:b,done:f})}const c=new Uint8Array(o);let d=0;for(const f of i)c.set(f,d),d+=f.length;r=c.buffer}catch(s){console.log("failed to send download progress event: ",s),r=await e.arrayBuffer()}return r},pe=async(a,t,e=!1,r)=>{const s=e?await Rt(a,r):await(await fetch(a)).arrayBuffer(),n=new Blob([s],{type:t});return URL.createObjectURL(n)},kt=x.create("FFmpegInstance",X.Debug);async function Pe(a){const t=a?x.create(`FFmpegInstance:${a}`,X.Debug):kt,e=new It;e.on("log",({message:r})=>{r.startsWith("frame=")||t.logDebug(`[FFMPEG_WASM_LOG] ${r}`)}),t.logInfo("[FFMPEG_WASM] Initializing new FFmpeg.wasm instance from local files (using toBlobURL strategy)...");try{const r=tt("ffmpeg-core/");if(!r)return t.logError("[FFMPEG_WASM] Failed to get base URL for FFmpeg core files."),null;const s=r+"ffmpeg-core.js",n=r+"ffmpeg-core.wasm",i=r+"worker.js";t.logInfo(`[FFMPEG_WASM] Base URL for Blob: ${r}`),t.logInfo("[FFMPEG_WASM] Attempting to create Blob URLs for core files (including worker)...");const o=await pe(s,"text/javascript"),c=await pe(n,"application/wasm"),d=await pe(i,"text/javascript");return t.logInfo("[FFMPEG_WASM] Blob URLs created. Loading FFmpeg instance with worker..."),await e.load({coreURL:o,wasmURL:c,workerURL:d}),t.logInfo("[FFMPEG_WASM] FFmpeg.wasm instance loaded successfully via Blob URLs (worker enabled)."),e}catch(r){return t.logError("[FFMPEG_WASM] Failed to load FFmpeg.wasm instance via Blob URLs",r),null}}const A=x.create("FFmpegManager",X.Debug),St=Math.max(1,Math.min(Number(S("maxConcurrentTrackDownloads"))||2,10)),ce=St;A.logInfo(`FFmpegManager initialized with MAX_CONCURRENT_OPERATIONS: ${ce}`);const W=[],ue=[];let j=!1,q=null;async function Me(){return j?Promise.resolve():q||(A.logInfo(`Initializing FFmpeg instance pool with size: ${ce}`),q=(async()=>{try{const a=[];for(let e=0;e<ce;e++)a.push(Pe(e));const t=await Promise.all(a);for(let e=0;e<t.length;e++){const r=t[e];r?W.push({id:e,instance:r,isAvailable:!0,isCompromised:!1}):A.logError(`Failed to load FFmpeg instance ${e} for the pool.`)}if(W.length===0&&ce>0)throw new Error("No FFmpeg instances could be initialized for the pool.");j=!0,A.logInfo(`FFmpeg instance pool initialized with ${W.length} instances.`)}catch(a){throw A.logError("Failed to initialize FFmpeg pool",a),j=!1,q=null,a}})(),q)}async function Ft(a,t){const{instance:e,id:r}=a,{taskId:s,inputBuffer:n,fileExtension:i,progressCallback:o,resolve:c,reject:d}=t,f=`input_${s}_${r}.${i||"mp4"}`,p=`output_remuxed_${s}_${r}.${i||"mp4"}`;A.logInfo(`[FFmpegManager] Instance ${r} starting remux for task ${s}: ${f} -> ${p}`);let b;try{let $;try{A.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Attempting inputBuffer.slice(0). Input buffer byteLength: ${n?.byteLength}`);const R=n.slice(0);A.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Successfully sliced buffer. Slice byteLength: ${R?.byteLength}. Attempting new Uint8Array().`),$=new Uint8Array(R),A.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Created Uint8Array with byteLength: ${$?.byteLength}. About to call instance.writeFile with ${f}.`)}catch(R){throw A.logError(`[FFmpegManager] Instance ${r}, Task ${s}: ERROR during buffer slice or Uint8Array creation:`,R),R}await e.writeFile(f,$),A.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Successfully called instance.writeFile with ${f}.`);const T=["-loglevel","debug","-i",f,"-c","copy",p];if(A.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: FFmpeg exec arguments:`,T),o){let R=-1;b=({progress:F})=>{const u=Math.round(F*100);u>R&&u<=100&&(o(u),R=u)},e.on("progress",b)}await e.exec(T);const l=await e.readFile(p);if(typeof l=="string")throw new Error("FFmpeg remux output was a string, expected Uint8Array");A.logInfo(`[FFmpegManager] Instance ${r} finished remux for task ${s}`),c(l.buffer.slice(0))}catch($){A.logError(`[FFmpegManager] Instance ${r} FAILED remux for task ${s}`,$),a.isCompromised=!0,d($)}finally{b&&typeof e.off=="function"&&e.off("progress",b);try{await e.deleteFile(f),await e.deleteFile(p)}catch($){A.logWarn(`[FFmpegManager] Instance ${r} failed to cleanup files for task ${s}`,$),a.isCompromised=!0}}}function Le(){if(!j||ue.length===0)return;const a=W.find(e=>e.isAvailable);if(!a){A.logDebug("No FFmpeg instance available right now, queue length: "+ue.length);return}const t=ue.shift();t&&(a.isAvailable=!1,A.logDebug(`Assigning task ${t.taskId} to FFmpeg instance ${a.id}`),Ft(a,t).finally(async()=>{if(a.isCompromised){A.logWarn(`[FFmpegManager] Instance ${a.id} is compromised. Terminating and attempting to replace.`);try{await a.instance.terminate(),A.logInfo(`[FFmpegManager] Terminated compromised instance ${a.id}.`)}catch(s){A.logError(`[FFmpegManager] Error terminating compromised instance ${a.id}:`,s)}const e=W.findIndex(s=>s.id===a.id);e>-1&&W.splice(e,1),A.logInfo(`[FFmpegManager] Attempting to create new FFmpeg instance to replace ${a.id}.`);const r=await Pe(a.id);r?(W.push({id:a.id,instance:r,isAvailable:!0,isCompromised:!1}),A.logInfo(`[FFmpegManager] Successfully replaced instance ${a.id}. Pool size: ${W.length}`)):A.logError(`[FFmpegManager] Failed to create new FFmpeg instance to replace ${a.id}. Pool size will be reduced.`)}else a.isAvailable=!0,A.logDebug(`FFmpeg instance ${a.id} is now available.`);Le()}))}async function vt(a,t,e,r){return!j&&!q&&Me().catch(s=>{A.logError("FFmpeg Pool Initialization failed lazily, subsequent requests might fail.",s)}),q&&await q,!j||W.length===0?Promise.reject(new Error("FFmpegManager: Pool not initialized or no instances available after init attempt.")):new Promise((s,n)=>{A.logDebug(`Task ${a} added to FFmpeg remux queue.`),ue.push({taskId:a,inputBuffer:t,fileExtension:e,progressCallback:r,resolve:s,reject:n}),Le()})}function _t(){!j&&!q&&Me().catch(a=>{A.logError("Pre-initialization of FFmpeg Pool failed.",a)})}function Ce(a){return String(a).split("").map(t=>t.charCodeAt(0))}function J(a){return new Uint8Array(Ce(a))}function Y(a){const t=new ArrayBuffer(2*a.length),e=new Uint8Array(t);return new Uint16Array(t).set(Ce(a)),e}function Ue(a){return[a>>>24&255,a>>>16&255,a>>>8&255,a&255]}function xe(a){return 11+a}function Ot(a,t,e,r){return 11+t+1+1+(r?2+2*(e+1):e+1)+a}function Nt(a){let t=0;return a.forEach(e=>{t+=2+2*e[0].length+2+2+2*e[1].length+2}),11+t}function Pt(a,t){const e=2*t;let r=0;return a.forEach(s=>{r+=2+2*s[0].length+2+4}),18+e+2+r}class Mt{_setIntegerFrame(t,e){const r=parseInt(e,10);this.frames.push({name:t,value:r,size:xe(r.toString().length)})}_setStringFrame(t,e){const r=e.toString();let s=13+2*r.length;t==="TDAT"&&(s=xe(r.length)),this.frames.push({name:t,value:r,size:s})}_setPictureFrame(t,e,r,s){const n=function(o){if(!o||!o.length)return null;if(o[0]===255&&o[1]===216&&o[2]===255)return"image/jpeg";if(o[0]===137&&o[1]===80&&o[2]===78&&o[3]===71)return"image/png";if(o[0]===71&&o[1]===73&&o[2]===70)return"image/gif";if(o[8]===87&&o[9]===69&&o[10]===66&&o[11]===80)return"image/webp";const c=o[0]===73&&o[1]===73&&o[2]===42&&o[3]===0,d=o[0]===77&&o[1]===77&&o[2]===0&&o[3]===42;return c||d?"image/tiff":o[0]===66&&o[1]===77?"image/bmp":o[0]===0&&o[1]===0&&o[2]===1&&o[3]===0?"image/x-icon":null}(new Uint8Array(e)),i=r.toString();if(!n)throw new Error("Unknown picture MIME type");r||(s=!1),this.frames.push({name:"APIC",value:e,pictureType:t,mimeType:n,useUnicodeEncoding:s,description:i,size:Ot(e.byteLength,n.length,i.length,s)})}_setLyricsFrame(t,e,r){const s=t.split("").map(d=>d.charCodeAt(0)),n=e.toString(),i=r.toString();var o,c;this.frames.push({name:"USLT",value:i,language:s,description:n,size:(o=n.length,c=i.length,16+2*o+2+2+2*c)})}_setCommentFrame(t,e,r){const s=t.split("").map(d=>d.charCodeAt(0)),n=e.toString(),i=r.toString();var o,c;this.frames.push({name:"COMM",value:i,language:s,description:n,size:(o=n.length,c=i.length,16+2*o+2+2+2*c)})}_setPrivateFrame(t,e){const r=t.toString();var s,n;this.frames.push({name:"PRIV",value:e,id:r,size:(s=r.length,n=e.byteLength,10+s+1+n)})}_setUserStringFrame(t,e){const r=t.toString(),s=e.toString();var n,i;this.frames.push({name:"TXXX",description:r,value:s,size:(n=r.length,i=s.length,13+2*n+2+2+2*i)})}_setUrlLinkFrame(t,e){const r=e.toString();var s;this.frames.push({name:t,value:r,size:(s=r.length,10+s)})}_setPairedTextFrame(t,e){this.frames.push({name:t,value:e,size:Nt(e)})}_setSynchronisedLyricsFrame(t,e,r,s,n){const i=n.toString(),o=s.split("").map(c=>c.charCodeAt(0));this.frames.push({name:"SYLT",value:e,language:o,description:i,type:t,timestampFormat:r,size:Pt(e,i.length)})}constructor(t){if(!t||typeof t!="object"||!("byteLength"in t))throw new Error("First argument should be an instance of ArrayBuffer or Buffer");this.arrayBuffer=t,this.padding=4096,this.frames=[],this.url=""}setFrame(t,e){switch(t){case"TPE1":case"TCOM":case"TCON":{if(!Array.isArray(e))throw new Error(`${t} frame value should be an array of strings`);const r=t==="TCON"?";":"/",s=e.join(r);this._setStringFrame(t,s);break}case"TLAN":case"TIT1":case"TIT2":case"TIT3":case"TALB":case"TPE2":case"TPE3":case"TPE4":case"TRCK":case"TPOS":case"TMED":case"TPUB":case"TCOP":case"TKEY":case"TEXT":case"TDAT":case"TCMP":case"TSRC":this._setStringFrame(t,e);break;case"TBPM":case"TLEN":case"TYER":this._setIntegerFrame(t,e);break;case"USLT":if(e.language=e.language||"eng",typeof e!="object"||!("description"in e)||!("lyrics"in e))throw new Error("USLT frame value should be an object with keys description and lyrics");if(e.language&&!e.language.match(/[a-z]{3}/i))throw new Error("Language must be coded following the ISO 639-2 standards");this._setLyricsFrame(e.language,e.description,e.lyrics);break;case"APIC":if(typeof e!="object"||!("type"in e)||!("data"in e)||!("description"in e))throw new Error("APIC frame value should be an object with keys type, data and description");if(e.type<0||e.type>20)throw new Error("Incorrect APIC frame picture type");this._setPictureFrame(e.type,e.data,e.description,!!e.useUnicodeEncoding);break;case"TXXX":if(typeof e!="object"||!("description"in e)||!("value"in e))throw new Error("TXXX frame value should be an object with keys description and value");this._setUserStringFrame(e.description,e.value);break;case"WCOM":case"WCOP":case"WOAF":case"WOAR":case"WOAS":case"WORS":case"WPAY":case"WPUB":this._setUrlLinkFrame(t,e);break;case"COMM":if(e.language=e.language||"eng",typeof e!="object"||!("description"in e)||!("text"in e))throw new Error("COMM frame value should be an object with keys description and text");if(e.language&&!e.language.match(/[a-z]{3}/i))throw new Error("Language must be coded following the ISO 639-2 standards");this._setCommentFrame(e.language,e.description,e.text);break;case"PRIV":if(typeof e!="object"||!("id"in e)||!("data"in e))throw new Error("PRIV frame value should be an object with keys id and data");this._setPrivateFrame(e.id,e.data);break;case"IPLS":if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Error("IPLS frame value should be an array of pairs");this._setPairedTextFrame(t,e);break;case"SYLT":if(typeof e!="object"||!("type"in e)||!("text"in e)||!("timestampFormat"in e))throw new Error("SYLT frame value should be an object with keys type, text and timestampFormat");if(!Array.isArray(e.text)||!Array.isArray(e.text[0]))throw new Error("SYLT frame text value should be an array of pairs");if(e.type<0||e.type>6)throw new Error("Incorrect SYLT frame content type");if(e.timestampFormat<1||e.timestampFormat>2)throw new Error("Incorrect SYLT frame time stamp format");e.language=e.language||"eng",e.description=e.description||"",this._setSynchronisedLyricsFrame(e.type,e.text,e.timestampFormat,e.language,e.description);break;default:throw new Error(`Unsupported frame ${t}`)}return this}removeTag(){if(this.arrayBuffer.byteLength<10)return;const t=new Uint8Array(this.arrayBuffer),e=t[3],r=((s=[t[6],t[7],t[8],t[9]])[0]<<21)+(s[1]<<14)+(s[2]<<7)+s[3]+10;var s,n;(n=t)[0]!==73||n[1]!==68||n[2]!==51||e<2||e>4||(this.arrayBuffer=new Uint8Array(t.subarray(r)).buffer)}addTag(){this.removeTag();const t=[255,254],e=10+this.frames.reduce((o,c)=>o+c.size,0)+this.padding,r=new ArrayBuffer(this.arrayBuffer.byteLength+e),s=new Uint8Array(r);let n=0,i=[];return i=[73,68,51,3],s.set(i,n),n+=i.length,n++,n++,i=function(o){return[o>>>21&127,o>>>14&127,o>>>7&127,o&127]}(e-10),s.set(i,n),n+=i.length,this.frames.forEach(o=>{switch(i=J(o.name),s.set(i,n),n+=i.length,i=Ue(o.size-10),s.set(i,n),n+=i.length,n+=2,o.name){case"WCOM":case"WCOP":case"WOAF":case"WOAR":case"WOAS":case"WORS":case"WPAY":case"WPUB":i=J(o.value),s.set(i,n),n+=i.length;break;case"TPE1":case"TCOM":case"TCON":case"TLAN":case"TIT1":case"TIT2":case"TIT3":case"TALB":case"TPE2":case"TPE3":case"TPE4":case"TRCK":case"TPOS":case"TKEY":case"TMED":case"TPUB":case"TCOP":case"TEXT":case"TSRC":i=[1].concat(t),s.set(i,n),n+=i.length,i=Y(o.value),s.set(i,n),n+=i.length;break;case"TXXX":case"USLT":case"COMM":i=[1],o.name!=="USLT"&&o.name!=="COMM"||(i=i.concat(o.language)),i=i.concat(t),s.set(i,n),n+=i.length,i=Y(o.description),s.set(i,n),n+=i.length,i=[0,0].concat(t),s.set(i,n),n+=i.length,i=Y(o.value),s.set(i,n),n+=i.length;break;case"TBPM":case"TLEN":case"TDAT":case"TYER":n++,i=J(o.value),s.set(i,n),n+=i.length;break;case"PRIV":i=J(o.id),s.set(i,n),n+=i.length,n++,s.set(new Uint8Array(o.value),n),n+=o.value.byteLength;break;case"APIC":i=[o.useUnicodeEncoding?1:0],s.set(i,n),n+=i.length,i=J(o.mimeType),s.set(i,n),n+=i.length,i=[0,o.pictureType],s.set(i,n),n+=i.length,o.useUnicodeEncoding?(i=[].concat(t),s.set(i,n),n+=i.length,i=Y(o.description),s.set(i,n),n+=i.length,n+=2):(i=J(o.description),s.set(i,n),n+=i.length,n++),s.set(new Uint8Array(o.value),n),n+=o.value.byteLength;break;case"IPLS":i=[1],s.set(i,n),n+=i.length,o.value.forEach(c=>{i=[].concat(t),s.set(i,n),n+=i.length,i=Y(c[0].toString()),s.set(i,n),n+=i.length,i=[0,0].concat(t),s.set(i,n),n+=i.length,i=Y(c[1].toString()),s.set(i,n),n+=i.length,i=[0,0],s.set(i,n),n+=i.length});break;case"SYLT":i=[1].concat(o.language).concat(o.timestampFormat).concat(o.type),s.set(i,n),n+=i.length,i=[].concat(t),s.set(i,n),n+=i.length,i=Y(o.description),s.set(i,n),n+=i.length,n+=2,o.value.forEach(c=>{i=[].concat(t),s.set(i,n),n+=i.length,i=Y(c[0].toString()),s.set(i,n),n+=i.length,i=[0,0],s.set(i,n),n+=i.length,i=Ue(c[1]),s.set(i,n),n+=i.length})}}),n+=this.padding,s.set(new Uint8Array(this.arrayBuffer),n),this.arrayBuffer=r,r}getBlob(){return new Blob([this.arrayBuffer],{type:"audio/mpeg"})}getURL(){return this.url||(this.url=URL.createObjectURL(this.getBlob())),this.url}revokeURL(){URL.revokeObjectURL(this.url)}}const Lt=x.create("Mp3TagWriter");class Ct{writer;constructor(t){this.writer=new Mt(t)}setTitle(t){if(!t)throw new Error("Invalid value for title");this.writer.setFrame("TIT2",t)}setArtists(t){if(!t||t.length<1)throw new Error("Invalid value for artists");this.writer.setFrame("TPE1",t)}setAlbum(t){if(!t)throw new Error("Invalid value for album");this.writer.setFrame("TALB",t)}setComment(t){if(!t)throw new Error("Invalid value for comment");this.writer.setFrame("COMM",{text:t,description:""})}setTrackNumber(t){if(t<1||t>32767)throw new Error("Invalid value for trackNumber");this.writer.setFrame("TRCK",t.toString())}setYear(t){if(t<1)throw new Error("Invalud value for year");this.writer.setFrame("TYER",t)}setGrouping(t){if(!t)throw new Error("Invalid value for grouping");this.writer.setFrame("TIT1",t)}setArtwork(t){if(!t||t.byteLength<1)throw new Error("Invalid value for artworkBuffer");this.writer.setFrame("APIC",{type:3,data:t,description:""})}setSoundCloudTrackId(t){if(!t)throw new Error("Invalid value for SoundCloud Track ID");Lt.logDebug(`Attempting to set SoundCloudTrackID: ${t}`),this.writer.setFrame("TXXX",{description:"SoundCloudTrackID",text:t})}getBuffer(){return this.writer.addTag(),this.writer.getBlob().arrayBuffer().then(t=>({buffer:t,tagsApplied:!0}))}}const H=8,ae=16,Be=H+ae;class Xe{_metadataPath=["moov","udta","meta","ilst"];_buffer;_bufferView;_atoms=[];_loggedErrors=new Set;_hasValidStructure=!1;_logger;get hasValidMp4Structure(){return this._hasValidStructure}_logError(t){this._loggedErrors.has(t)||(this._logger.logDebug(`MP4 metadata: ${t}`),this._loggedErrors.add(t))}constructor(t){this._buffer=t,this._bufferView=new DataView(t),this._logger=x.create("MP4TagWriterInternals",X.Debug)}parse(){if(!this._buffer)throw new Error("Buffer can not be null");if(this._atoms.length>0)throw new Error("Buffer already parsed");this._logger.logDebug("Starting MP4 parse...");let t=0,e,r=[];for(;;){if(e=this._readAtom(t),!e||e.length<1||t>=this._buffer.byteLength){t<this._buffer.byteLength?this._logger.logDebug(`Parsing stopped: _readAtom returned invalid atom or zero length at offset ${t}.`):this._logger.logDebug(`Parsing stopped: Reached end of buffer at offset ${t}.`);break}if(r.push({name:e.name||"undefined",length:e.length,offset:e.offset}),this._atoms.push(e),t=e.offset+e.length,t<=e.offset){this._logger.logError(`Parsing stopped: Invalid offset progression. Current offset ${e.offset}, next offset calculated as ${t}.`);break}}if(this._logger.logDebug(`Finished MP4 parse. Found ${this._atoms.length} top-level atoms.`),this._logger.logDebug(`Top-level atoms summary: ${JSON.stringify(r)}`),this._atoms.length<1){this._logError("Buffer could not be parsed - no valid top-level atoms found."),this._hasValidStructure=!1;return}const s=this._atoms.find(n=>n.name?.toLowerCase()==="moov");this._hasValidStructure=!!s,this._hasValidStructure?this._logger.logDebug("File structure check passed: Found top-level 'moov' atom (case-insensitive check)."):this._logError("File structure check failed: Did not find a top-level 'moov' atom (checked case-insensitively).")}setDuration(t){try{if(!this._hasValidStructure){this._logError("Cannot set duration - file doesn't have a valid MP4 structure");return}const e=this._findAtom(this._atoms,["moov","mvhd"]);if(!e)throw new Error("'mvhd' atom could not be found");this._bufferView.setUint32(e.offset+H+16,t)}catch(e){this._logError(`Failed to set duration: ${e.message}`)}}addMetadataAtom(t,e){try{if(!this._hasValidStructure){this._logError(`Cannot add ${t} metadata - file doesn't have a valid MP4 structure`);return}if(t.length>4||t.length<1)throw new Error(`Unsupported atom name: '${t}'`);let r;if(e instanceof ArrayBuffer)r=e;else if(typeof e=="string")r=this._getBufferFromString(e);else if(typeof e=="number")r=new ArrayBuffer(4),new DataView(r).setUint32(0,e);else throw new Error(`Unsupported data: '${e}'`);const s={name:t,length:Be+r.byteLength,data:r};this._insertAtom(s,this._metadataPath)}catch(r){this._logError(`Failed to add metadata atom '${t}': ${r.message}`)}}getBuffer(){const t=[];let e=0;for(const r of this._atoms){if(!r.children){const i=this._buffer.slice(r.offset,r.offset+r.length);t.push(i),e++;continue}r.length=H;const s=[{parent:r,offset:e,childIndex:0}];let n=0;for(;;){const{parent:i,offset:o,childIndex:c}=s[n];if(c>=i.children.length){n--,s.pop();let f=H;i.name==="meta"?(i.length+=4,f+=4):i.name==="stsd"&&(i.length+=8,f+=8),this._bufferView.setUint32(i.offset,i.length);const p=this._buffer.slice(i.offset,i.offset+f);if(t.splice(o,0,p),n<0)break;const b=s[n].parent;b.length+=i.length,s[n].childIndex++;continue}const d=i.children[c];if(d.children){d.length=H,s.push({parent:d,offset:e,childIndex:0}),n++;continue}else if(d.data){const f=this._getHeaderBufferFromAtom(d);t.push(f),t.push(d.data)}else{const f=this._buffer.slice(d.offset,d.offset+d.length);t.push(f)}e++,i.length+=d.length,s[n].childIndex++}}return this._bufferView=null,this._buffer=null,this._atoms=[],ke(t)}_insertAtom(t,e){try{if(this._logger.logDebug(`Attempting to insert atom '${t.name}' at path '${e.join(" > ")}'.`),!e||e[e.length-1]!=="ilst"){this._logError(`Cannot insert tag atom '${t.name}': Path does not end in 'ilst'.`);return}const r=this._createMetadataPath();if(!r){this._logError(`Cannot insert atom '${t.name}': Failed to find or create parent 'ilst' atom.`);return}r.children===void 0&&(r.children=this._readChildAtoms(r),this._logger.logDebug(`Loaded children for '${r.name}' in _insertAtom.`));const s=r.children.findIndex(i=>i.name===t.name);s!==-1&&(this._logger.logDebug(`Replacing existing atom '${t.name}' in '${r.name}'.`),r.children.splice(s,1));let n=r.offset+this._getAtomHeaderLength(r);if(r.children.length>0){const i=r.children[r.children.length-1];n=i.offset+i.length}t.offset=n,r.children.push(t),this._logger.logDebug(`Successfully prepared atom '${t.name}' for insertion into '${r.name}'.`)}catch(r){this._logError(`Error during _insertAtom for '${t.name}': ${r.message}`)}}_findAtom(t,e){if(!e||e.length<1)throw new Error("Path can not be empty");const r=[...e],s=r.shift();this._logger.logDebug(`_findAtom: Searching for '${s}' in ${t.length} atoms. Remaining path: [${r.join(",")}]`);const n=t.find(i=>i.name===s);return n?(this._logger.logDebug(`_findAtom: Found '${n.name}' (length: ${n.length}, offset: ${n.offset})`),r.length<1?(this._logger.logDebug(`_findAtom: Path complete. Returning '${n.name}'.`),n.children===void 0&&(this._logger.logDebug(`_findAtom: Reading children for final element '${n.name}' before returning.`),n.children=this._readChildAtoms(n)),n):(n.children===void 0&&(this._logger.logDebug(`_findAtom: Reading children for '${n.name}' to continue traversal.`),n.children=this._readChildAtoms(n)),!n.children||n.children.length<1?(this._logger.logDebug(`_findAtom: '${n.name}' has no children to continue search for [${r.join(",")}]`),null):this._findAtom(n.children,r))):(this._logger.logDebug(`_findAtom: '${s}' not found.`),null)}_readChildAtoms(t){const e=[];this._logger.logDebug(`_readChildAtoms: Reading children for parent '${t.name}' (length: ${t.length}, offset: ${t.offset})`);const r=t.offset+t.length;let s=t.offset+H;t.name==="meta"?s+=4:t.name==="stsd"?s+=8:t.name==="ilst"?this._logger.logDebug(`_readChildAtoms: Parent is '${t.name}', standard child offset: ${s}`):t.name&&(t.name==="\xA9nam"||t.name==="\xA9ART"||t.name==="\xA9alb"||t.name==="\xA9day"||t.name==="trkn"||t.name==="scid"||t.name==="covr"||t.name==="\xA9too")&&this._logger.logDebug(`_readChildAtoms: Parent is item atom '${t.name}', standard child offset: ${s}`);let n=0;for(;;){if(s>=r){this._logger.logDebug(`_readChildAtoms: Reached end of parent '${t.name}' at offset ${s}. Found ${n} children.`);break}const i=this._readAtom(s);if(n++,this._logger.logDebug(`_readChildAtoms: For parent '${t.name}', read potential child ${n}: '${i.name||"?"}' (length: ${i.length}, offset: ${i.offset})`),!i||i.length<1){this._logger.logWarn(`_readChildAtoms: Invalid child atom or zero length for parent '${t.name}' at offset ${s}. Stopping child read.`);break}if(i.offset+i.length>r){this._logger.logWarn(`_readChildAtoms: Child atom '${i.name}' (offset ${i.offset}, length ${i.length}) exceeds parent '${t.name}' (ends at ${r}). Stopping.`);break}if(e.push(i),s=i.offset+i.length,s<=i.offset){this._logger.logError(`_readChildAtoms: Invalid offset progression for parent '${t.name}'. Child offset ${i.offset}, next offset ${s}. Stopping.`);break}}return this._logger.logDebug(`_readChildAtoms: Finished reading for parent '${t.name}'. Total children found: ${e.length}`),e}_readAtom(t){const e=t,r=t+H,s=this._buffer.slice(e,r);if(s.byteLength<H)return{length:s.byteLength,offset:t};const n=new DataView(s);let i=n.getUint32(0,!1),o="";for(let c=0;c<4;c++)o+=String.fromCharCode(n.getUint8(4+c));return{name:o,length:i,offset:t}}_getHeaderBufferFromAtom(t){if(!t||t.length<1||!t.name||!t.data)throw new Error("Can not compute header buffer for this atom");const e=new ArrayBuffer(Be),r=new DataView(e);r.setUint32(0,t.length);const s=this._getCharCodes(t.name);for(let i=0;i<s.length;i++)r.setUint8(4+i,s[i]);r.setUint32(8,ae+t.data.byteLength);const n=this._getCharCodes("data");for(let i=0;i<n.length;i++)r.setUint8(12+i,n[i]);return r.setUint32(16,this._getFlags(t.name)),e}_getBufferFromString(t){const e=new ArrayBuffer(t.length),r=new DataView(e),s=this._getCharCodes(t);for(let n=0;n<s.length;n++)r.setUint8(n,s[n]);return e}_getCharCodes(t){const e=[];for(let r=0;r<t.length;r++)e.push(t.charCodeAt(r));return e}_getFlags(t){switch(t){case"covr":return 13;case"trkn":case"disk":return 0;case"tmpo":case"cpil":case"rtng":return 21;default:return 1}}_createMetadataPath(){try{this._logger.logDebug("Attempting to ensure metadata path moov > udta > meta > ilst exists.");const t=this._findAtom(this._atoms,["moov"]);if(!t)return this._logError("Cannot create metadata path: Required 'moov' atom not found."),null;t.children===void 0&&(t.children=this._readChildAtoms(t));let e=t;const r=["udta","meta","ilst"];for(const s of r){let n=this._findAtom(e.children,[s]);if(n)this._logger.logDebug(`Found existing '${s}' atom.`),n.children===void 0&&(n.children=this._readChildAtoms(n));else{this._logger.logDebug(`Creating missing '${s}' atom.`);let i=e.offset+this._getAtomHeaderLength(e);if(e.children.length>0){const c=e.children[e.children.length-1];i=c.offset+c.length}const o=this._getAtomHeaderLength({name:s});n={name:s,length:o,offset:i,children:[]},e.children.push(n),this._logger.logDebug(`Created '${s}' atom.`)}e=n}return this._logger.logDebug("Metadata path creation/verification successful. Returning 'ilst' atom."),e}catch(t){return this._logError(`Failed during _createMetadataPath: ${t.message}`),null}}_getAtomHeaderLength(t){let e=H;return t.name==="meta"?e+=4:t.name==="stsd"&&(e+=8),e}findAndReadTextAtomData(t){try{const e=this._findAtom(this._atoms,t);if(e&&e.children&&e.children.length>0){const r=e.children.find(s=>s.name==="data");if(r){const s=r.offset+ae,n=r.length-ae;if(n>0&&this._buffer&&s+n<=this._buffer.byteLength){const i=this._buffer.slice(s,s+n);return new TextDecoder().decode(i)}else return this._logError(`Invalid data length or buffer bounds for atom at path ${t.join(" > ")}. Data atom length: ${r.length}, Header: ${ae}`),null}else return this._logError(`No 'data' child atom found for atom at path ${t.join(" > ")}`),null}else this._logError(`Target atom not found or has no children at path ${t.join(" > ")}`);return null}catch(e){return this._logError(`Error finding or reading text atom at path ${t.join(" > ")}: ${e.message}`),null}}}class D{_originalBuffer;_mp4;_hasValidMp4=!1;static _loggedErrors=new Set;static _logger=x.create("MP4TagWriter",X.Debug);static _logError(t){D._loggedErrors.has(t)||(D._logger.logDebug(`MP4 metadata: ${t}`),D._loggedErrors.add(t))}constructor(t){try{this._originalBuffer=t.slice(0),D._logger.logDebug(`Creating Mp4TagWriter with buffer of size: ${this._originalBuffer.byteLength}`);try{this._mp4=new Xe(this._originalBuffer),this._mp4.parse(),this._hasValidMp4=this._mp4.hasValidMp4Structure,this._hasValidMp4?D._logger.logDebug("MP4 structure validation passed. TagWriter ready for use."):D._logError("MP4 structure validation failed. Tags will not be applied but original audio will still be saved.")}catch(e){this._hasValidMp4=!1,D._logError(`Failed to initialize MP4 parser: ${e.message}`)}}catch(e){D._logError(`Mp4TagWriter constructor error: ${e.message}`),this._originalBuffer=new ArrayBuffer(0),this._hasValidMp4=!1}}setTitle(t){try{if(!t)throw new Error("Invalid value for title");this._mp4.addMetadataAtom("\xA9nam",t)}catch(e){D._logError(`Failed to set title: ${e.message}`)}}setArtists(t){try{if(!t||t.length<1)throw new Error("Invalid value for artists");this._mp4.addMetadataAtom("\xA9ART",t.join(", "))}catch(e){D._logError(`Failed to set artists: ${e.message}`)}}setAlbum(t){try{if(!t)throw new Error("Invalid value for album");this._mp4.addMetadataAtom("\xA9alb",t)}catch(e){D._logError(`Failed to set album: ${e.message}`)}}setComment(t){try{if(!t)throw new Error("Invalid value for comment");this._mp4.addMetadataAtom("\xA9cmt",t)}catch(e){D._logError(`Failed to set comment: ${e.message}`)}}setTrackNumber(t){try{if(t<1||t>32767)throw new Error("Invalid value for trackNumber");this._mp4.addMetadataAtom("trkn",t)}catch(e){D._logError(`Failed to set track number: ${e.message}`)}}setYear(t){try{if(t<1)throw new Error("Invalid value for year");this._mp4.addMetadataAtom("\xA9day",t.toString())}catch(e){D._logError(`Failed to set year: ${e.message}`)}}setGrouping(t){try{if(!t)throw new Error("Invalid value for grouping");this._mp4.addMetadataAtom("\xA9grp",t)}catch(e){D._logError(`Failed to set grouping: ${e.message}`)}}setArtwork(t){try{if(!t||t.byteLength<1)throw new Error("Invalid value for artworkBuffer");this._mp4.addMetadataAtom("covr",t)}catch(e){D._logError(`Failed to set artwork: ${e.message}`)}}setSoundCloudTrackId(t){if(!this._hasValidMp4){D._logError("Cannot set SoundCloud Track ID - MP4 structure is invalid or not parsed.");return}if(!t){D._logError("Invalid value for SoundCloud Track ID");return}D._logger.logDebug(`[Mp4TagWriter] Attempting to set SoundCloudTrackID (scid): ${t}`),this._mp4.addMetadataAtom("scid",t)}setDuration(t){try{if(t<1)throw new Error("Invalid value for duration");this._mp4.setDuration(t)}catch(e){D._logError(`Failed to set duration: ${e.message}`)}}getBuffer(){try{if(!this._originalBuffer||this._originalBuffer.byteLength===0)throw new Error("Original buffer is missing or empty");if(!this._mp4||!this._hasValidMp4)return D._logError("MP4 structure check failed. Returning original buffer without applying tags."),Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:"Invalid MP4 structure for tagging."});let t;try{if(t=this._mp4.getBuffer(),!t||t.byteLength===0)throw new Error("Processed buffer is empty or null");t=t.slice(0)}catch(s){return D._logError(`Failed to get processed buffer: ${s.message}`),Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:`Failed to process MP4 buffer: ${s.message}`})}let e=!0,r;return t.byteLength!==this._originalBuffer.byteLength&&(e=!0,r=`Successfully applied tags (original: ${this._originalBuffer.byteLength}, new: ${t.byteLength})`),Promise.resolve({buffer:t,tagsApplied:e,message:r})}catch(t){const e=`Failed to get processed buffer: ${t.message}. Using original buffer as fallback.`;D._logError(e);try{return Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:e})}catch(r){return D._logError(`CRITICAL: Failed to create copy of original buffer: ${r.message}`),Promise.resolve({buffer:new ArrayBuffer(0),tagsApplied:!1,message:`CRITICAL ERROR: ${e} + ${r.message}`})}}}}function Ut(a){if(typeof a!="string")throw new TypeError("Expected a string");return a.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}var Ee=(a=>(a[a.Main=0]="Main",a[a.Feature=1]="Feature",a[a.Remixer=2]="Remixer",a[a.Producer=3]="Producer",a))(Ee||{}),we=(a=>(a[a.Remix=0]="Remix",a[a.Flip=1]="Flip",a[a.Bootleg=2]="Bootleg",a[a.Mashup=3]="Mashup",a[a.Edit=4]="Edit",a))(we||{});function xt(a){switch(a.toLowerCase().trim()){case"flip":return 1;case"bootleg":return 2;case"mashup":return 3;case"edit":return 4;case"remix":default:return 0}}function Bt(a,t){return a.map((e,r)=>({data:e,index:r})).sort((e,r)=>e.data[t]<r.data[t]?-1:e.data[t]>r.data[t]?1:e.index-r.index).map(e=>e.data)}class C{constructor(t,e,r){this.title=t,this.username=e,this.userPermalink=r}static titleSeparators=["-","\u2013","\u2014","~"];static featureSeparators=["featuring","feat.","feat","ft."," ft ","w/"," w /"," w ","+"];static combiningFeatureSeparators=[...C.featureSeparators,", "," & "," x "];static remixIndicators=["remix","flip","bootleg","mashup","edit"];static producerIndicators=["prod. by ","prod by ","prod. ","p. ","prod "];static promotions=["free download","video in description","video in desc","vid in desc","Original Mix"];getArtists(){const t=this.preprocessTitle(this.title);let e=[];const r=this.splitByTitleSeparators(t,!0);e=e.concat(r.artistNames.map((d,f)=>({name:d,type:f===0?0:1})));const s=this.splitByProducer(r.title,!0);e=e.concat(s.artistNames.map(d=>({name:d,type:3})));const n=this.splitByRemix(s.title,!0);e=e.concat(n.artists);const i=this.splitByUnsafeProducers(n.title,!0);e=e.concat(i.artistNames.map(d=>({name:d,type:3})));const o=this.splitByFeatures(n.title,!0);if(e=e.concat(o.artistNames.map(d=>({name:d,type:1}))),!e.some(d=>d.type===0)){const d={name:this.sanitizeArtistName(this.username)||this.userPermalink,type:0};d.name&&(e.length>0?e=[d,...e]:e.push(d))}e=e.map(d=>this.removeTwitterHandle(d));const c=[];for(const d of e)c.some(f=>f.name==d.name)||c.push(d);return Bt(c,"type")}getTitle(){let t=this.preprocessTitle(this.title);return t=this.splitByTitleSeparators(t,!1).title,t=this.splitByProducer(t,!1).title,t=this.splitByRemix(t,!1).title,t=this.splitByFeatures(t,!1).title,t=this.splitByUnsafeProducers(t,!1).title,this.sanitizeTitle(t)}removeTwitterHandle(t){t.name=t.name.replace(/^[@]+/,"");const e=/^([^(]+)\s?\(\s?@.+\)?$/.exec(t.name);return e&&e.length>1&&(t.name=e[1].trimEnd()),t}splitByTitleSeparators(t,e){let r=[];if(this.includes(t,C.titleSeparators)){const s=this.escapeRegexArray(C.titleSeparators),n=new RegExp(`^((.+)\\s[${s}]\\s)(.+)$`).exec(t);if(n&&n.length>0){const[i,o,c]=n;e&&(r=this.getArtistNames(c)),t=t.replace(o,"")}}return{artistNames:r,title:t}}splitByFeatures(t,e){let r=[];if(this.includes(t,C.featureSeparators)){const s=this.escapeRegexArray(C.featureSeparators).join("|"),n=new RegExp(`(?:${s})([^\\[\\]\\(\\)]+)`,"i").exec(t);if(n&&n.length>0){const[i,o]=n;e&&(r=this.getArtistNames(o)),t=t.replace(i,"")}}return{artistNames:r,title:t}}splitByProducer(t,e){let r=[];if(this.includes(t,C.producerIndicators)){const s=this.escapeRegexArray(C.producerIndicators).join("|"),n=new RegExp(`(?:${s})([^\\[\\]\\(\\)]+)`,"i").exec(t);if(n&&n.length>0){const[i,o]=n;e&&(r=this.getArtistNames(o)),t=t.replace(i,"")}}return{artistNames:r,title:t}}splitByUnsafeProducers(t,e){let r=[];const s=this.escapeRegexArray(C.featureSeparators).join("|"),n=new RegExp(`[\\(\\[](?!${s})(.+)[\\)\\]]`,"i").exec(t);if(n&&n.length>0){const[i,o]=n;e&&(r=this.getArtistNames(o)),t=t.replace(i,"")}return{artistNames:r,title:t}}splitByRemix(t,e){let r=[];if(this.includes(t,C.remixIndicators)){const s=this.escapeRegexArray(C.remixIndicators).join("|"),n=new RegExp(`[\\[\\(](.+)(${s})[\\]\\)]`,"i").exec(t);if(n&&n.length>0){const[i,o,c]=n;if(e){const d=this.getArtistNames(o),f=xt(c);r=d.map(p=>({name:p,type:2,remixType:f}))}t=t.replace(i,"")}}return{artists:r,title:t}}getArtistNames(t){const e=this.escapeRegexArray(C.combiningFeatureSeparators).join("|"),r=new RegExp(`(.+)\\s?(${e})\\s?(.+)`,"i"),s=[];for(;;){const n=r.exec(t);if(!n){s.push(this.sanitizeArtistName(t));break}s.push(this.sanitizeArtistName(n[3])),t=n[1]}return s.reverse()}preprocessTitle(t){t=t.replace(/\+([+]+)/g,"+");const e=C.promotions.join("|"),r=new RegExp(`[\\[\\(]?\\s*(${e})\\s*[\\]\\)]?`,"i");return t.replace(r,"")}sanitizeArtistName(t){return this.removeNonAsciiCharacters(t).trim()}sanitizeTitle(t){let e=this.removeNonAsciiCharacters(t);return e=e.replace("()","").replace("[]",""),e.trim()}removeNonAsciiCharacters(t){return Se.replace(t,Se("[^\\p{L}\\p{N}\\p{Zs}\0-\x7F]","g"),"")}includes(t,e){const r=t.toLowerCase();return e.some(s=>r.includes(s))}escapeRegexArray(t){return t.map(e=>Ut(e))}}var be=function(){function a(){this.listeners={}}var t=a.prototype;return t.on=function(e,r){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(r)},t.off=function(e,r){if(!this.listeners[e])return!1;var s=this.listeners[e].indexOf(r);return this.listeners[e]=this.listeners[e].slice(0),this.listeners[e].splice(s,1),s>-1},t.trigger=function(e){var r=this.listeners[e];if(r)if(arguments.length===2)for(var s=r.length,n=0;n<s;++n)r[n].call(this,arguments[1]);else for(var i=Array.prototype.slice.call(arguments,1),o=r.length,c=0;c<o;++c)r[c].apply(this,i)},t.dispose=function(){this.listeners={}},t.pipe=function(e){this.on("data",function(r){e.push(r)})},a}();function Z(){return Z=Object.assign?Object.assign.bind():function(a){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var r in e)({}).hasOwnProperty.call(e,r)&&(a[r]=e[r])}return a},Z.apply(null,arguments)}var ye,We;function Xt(){if(We)return ye;We=1;var a;return typeof window<"u"?a=window:typeof Fe<"u"?a=Fe:typeof self<"u"?a=self:a={},ye=a,ye}var Wt=Xt();const He=ut(Wt);var Ht=function(a){return He.atob?He.atob(a):Buffer.from(a,"base64").toString("binary")};function Gt(a){for(var t=Ht(a),e=new Uint8Array(t.length),r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */class qt extends be{constructor(){super(),this.buffer=""}push(t){let e;for(this.buffer+=t,e=this.buffer.indexOf(`
`);e>-1;e=this.buffer.indexOf(`
`))this.trigger("data",this.buffer.substring(0,e)),this.buffer=this.buffer.substring(e+1)}}const Yt="	",Te=function(a){const t=/([0-9.]*)?@?([0-9.]*)?/.exec(a||""),e={};return t[1]&&(e.length=parseInt(t[1],10)),t[2]&&(e.offset=parseInt(t[2],10)),e},Vt=function(){const a='(?:[^=]*)=(?:"[^"]*"|[^,]*)';return new RegExp("(?:^|,)("+a+")")},P=function(a){const t={};if(!a)return t;const e=a.split(Vt());let r=e.length,s;for(;r--;)e[r]!==""&&(s=/([^=]*)=(.*)/.exec(e[r]).slice(1),s[0]=s[0].replace(/^\s+|\s+$/g,""),s[1]=s[1].replace(/^\s+|\s+$/g,""),s[1]=s[1].replace(/^['"](.*)['"]$/g,"$1"),t[s[0]]=s[1]);return t},Ge=a=>{const t=a.split("x"),e={};return t[0]&&(e.width=parseInt(t[0],10)),t[1]&&(e.height=parseInt(t[1],10)),e};class jt extends be{constructor(){super(),this.customParsers=[],this.tagMappers=[]}push(t){let e,r;if(t=t.trim(),t.length!==0){if(t[0]!=="#"){this.trigger("data",{type:"uri",uri:t});return}this.tagMappers.reduce((s,n)=>{const i=n(t);return i===t?s:s.concat([i])},[t]).forEach(s=>{for(let n=0;n<this.customParsers.length;n++)if(this.customParsers[n].call(this,s))return;if(s.indexOf("#EXT")!==0){this.trigger("data",{type:"comment",text:s.slice(1)});return}if(s=s.replace("\r",""),e=/^#EXTM3U/.exec(s),e){this.trigger("data",{type:"tag",tagType:"m3u"});return}if(e=/^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(s),e){r={type:"tag",tagType:"inf"},e[1]&&(r.duration=parseFloat(e[1])),e[2]&&(r.title=e[2]),this.trigger("data",r);return}if(e=/^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"targetduration"},e[1]&&(r.duration=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-VERSION:([0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"version"},e[1]&&(r.version=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"media-sequence"},e[1]&&(r.number=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"discontinuity-sequence"},e[1]&&(r.number=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(s),e){r={type:"tag",tagType:"playlist-type"},e[1]&&(r.playlistType=e[1]),this.trigger("data",r);return}if(e=/^#EXT-X-BYTERANGE:(.*)?$/.exec(s),e){r=Z(Te(e[1]),{type:"tag",tagType:"byterange"}),this.trigger("data",r);return}if(e=/^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(s),e){r={type:"tag",tagType:"allow-cache"},e[1]&&(r.allowed=!/NO/.test(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-MAP:(.*)$/.exec(s),e){if(r={type:"tag",tagType:"map"},e[1]){const n=P(e[1]);n.URI&&(r.uri=n.URI),n.BYTERANGE&&(r.byterange=Te(n.BYTERANGE))}this.trigger("data",r);return}if(e=/^#EXT-X-STREAM-INF:(.*)$/.exec(s),e){r={type:"tag",tagType:"stream-inf"},e[1]&&(r.attributes=P(e[1]),r.attributes.RESOLUTION&&(r.attributes.RESOLUTION=Ge(r.attributes.RESOLUTION)),r.attributes.BANDWIDTH&&(r.attributes.BANDWIDTH=parseInt(r.attributes.BANDWIDTH,10)),r.attributes["FRAME-RATE"]&&(r.attributes["FRAME-RATE"]=parseFloat(r.attributes["FRAME-RATE"])),r.attributes["PROGRAM-ID"]&&(r.attributes["PROGRAM-ID"]=parseInt(r.attributes["PROGRAM-ID"],10))),this.trigger("data",r);return}if(e=/^#EXT-X-MEDIA:(.*)$/.exec(s),e){r={type:"tag",tagType:"media"},e[1]&&(r.attributes=P(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-ENDLIST/.exec(s),e){this.trigger("data",{type:"tag",tagType:"endlist"});return}if(e=/^#EXT-X-DISCONTINUITY/.exec(s),e){this.trigger("data",{type:"tag",tagType:"discontinuity"});return}if(e=/^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(s),e){r={type:"tag",tagType:"program-date-time"},e[1]&&(r.dateTimeString=e[1],r.dateTimeObject=new Date(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-KEY:(.*)$/.exec(s),e){r={type:"tag",tagType:"key"},e[1]&&(r.attributes=P(e[1]),r.attributes.IV&&(r.attributes.IV.substring(0,2).toLowerCase()==="0x"&&(r.attributes.IV=r.attributes.IV.substring(2)),r.attributes.IV=r.attributes.IV.match(/.{8}/g),r.attributes.IV[0]=parseInt(r.attributes.IV[0],16),r.attributes.IV[1]=parseInt(r.attributes.IV[1],16),r.attributes.IV[2]=parseInt(r.attributes.IV[2],16),r.attributes.IV[3]=parseInt(r.attributes.IV[3],16),r.attributes.IV=new Uint32Array(r.attributes.IV))),this.trigger("data",r);return}if(e=/^#EXT-X-START:(.*)$/.exec(s),e){r={type:"tag",tagType:"start"},e[1]&&(r.attributes=P(e[1]),r.attributes["TIME-OFFSET"]=parseFloat(r.attributes["TIME-OFFSET"]),r.attributes.PRECISE=/YES/.test(r.attributes.PRECISE)),this.trigger("data",r);return}if(e=/^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(s),e){r={type:"tag",tagType:"cue-out-cont"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-CUE-OUT:(.*)?$/.exec(s),e){r={type:"tag",tagType:"cue-out"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-CUE-IN:?(.*)?$/.exec(s),e){r={type:"tag",tagType:"cue-in"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-SKIP:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"skip"},r.attributes=P(e[1]),r.attributes.hasOwnProperty("SKIPPED-SEGMENTS")&&(r.attributes["SKIPPED-SEGMENTS"]=parseInt(r.attributes["SKIPPED-SEGMENTS"],10)),r.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")&&(r.attributes["RECENTLY-REMOVED-DATERANGES"]=r.attributes["RECENTLY-REMOVED-DATERANGES"].split(Yt)),this.trigger("data",r);return}if(e=/^#EXT-X-PART:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"part"},r.attributes=P(e[1]),["DURATION"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),["INDEPENDENT","GAP"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=/YES/.test(r.attributes[n]))}),r.attributes.hasOwnProperty("BYTERANGE")&&(r.attributes.byterange=Te(r.attributes.BYTERANGE)),this.trigger("data",r);return}if(e=/^#EXT-X-SERVER-CONTROL:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"server-control"},r.attributes=P(e[1]),["CAN-SKIP-UNTIL","PART-HOLD-BACK","HOLD-BACK"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),["CAN-SKIP-DATERANGES","CAN-BLOCK-RELOAD"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=/YES/.test(r.attributes[n]))}),this.trigger("data",r);return}if(e=/^#EXT-X-PART-INF:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"part-inf"},r.attributes=P(e[1]),["PART-TARGET"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),this.trigger("data",r);return}if(e=/^#EXT-X-PRELOAD-HINT:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"preload-hint"},r.attributes=P(e[1]),["BYTERANGE-START","BYTERANGE-LENGTH"].forEach(function(n){if(r.attributes.hasOwnProperty(n)){r.attributes[n]=parseInt(r.attributes[n],10);const i=n==="BYTERANGE-LENGTH"?"length":"offset";r.attributes.byterange=r.attributes.byterange||{},r.attributes.byterange[i]=r.attributes[n],delete r.attributes[n]}}),this.trigger("data",r);return}if(e=/^#EXT-X-RENDITION-REPORT:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"rendition-report"},r.attributes=P(e[1]),["LAST-MSN","LAST-PART"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseInt(r.attributes[n],10))}),this.trigger("data",r);return}if(e=/^#EXT-X-DATERANGE:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"daterange"},r.attributes=P(e[1]),["ID","CLASS"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=String(r.attributes[i]))}),["START-DATE","END-DATE"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=new Date(r.attributes[i]))}),["DURATION","PLANNED-DURATION"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=parseFloat(r.attributes[i]))}),["END-ON-NEXT"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=/YES/i.test(r.attributes[i]))}),["SCTE35-CMD"," SCTE35-OUT","SCTE35-IN"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=r.attributes[i].toString(16))});const n=/^X-([A-Z]+-)+[A-Z]+$/;for(const i in r.attributes){if(!n.test(i))continue;const o=/[0-9A-Fa-f]{6}/g.test(r.attributes[i]),c=/^\d+(\.\d+)?$/.test(r.attributes[i]);r.attributes[i]=o?r.attributes[i].toString(16):c?parseFloat(r.attributes[i]):String(r.attributes[i])}this.trigger("data",r);return}if(e=/^#EXT-X-INDEPENDENT-SEGMENTS/.exec(s),e){this.trigger("data",{type:"tag",tagType:"independent-segments"});return}if(e=/^#EXT-X-I-FRAMES-ONLY/.exec(s),e){this.trigger("data",{type:"tag",tagType:"i-frames-only"});return}if(e=/^#EXT-X-CONTENT-STEERING:(.*)$/.exec(s),e){r={type:"tag",tagType:"content-steering"},r.attributes=P(e[1]),this.trigger("data",r);return}if(e=/^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(s),e){r={type:"tag",tagType:"i-frame-playlist"},r.attributes=P(e[1]),r.attributes.URI&&(r.uri=r.attributes.URI),r.attributes.BANDWIDTH&&(r.attributes.BANDWIDTH=parseInt(r.attributes.BANDWIDTH,10)),r.attributes.RESOLUTION&&(r.attributes.RESOLUTION=Ge(r.attributes.RESOLUTION)),r.attributes["AVERAGE-BANDWIDTH"]&&(r.attributes["AVERAGE-BANDWIDTH"]=parseInt(r.attributes["AVERAGE-BANDWIDTH"],10)),r.attributes["FRAME-RATE"]&&(r.attributes["FRAME-RATE"]=parseFloat(r.attributes["FRAME-RATE"])),this.trigger("data",r);return}if(e=/^#EXT-X-DEFINE:(.*)$/.exec(s),e){r={type:"tag",tagType:"define"},r.attributes=P(e[1]),this.trigger("data",r);return}this.trigger("data",{type:"tag",data:s.slice(4)})})}}addParser({expression:t,customType:e,dataParser:r,segment:s}){typeof r!="function"&&(r=n=>n),this.customParsers.push(n=>{if(t.exec(n))return this.trigger("data",{type:"custom",data:r(n),customType:e,segment:s}),!0})}addTagMapper({expression:t,map:e}){const r=s=>t.test(s)?e(s):s;this.tagMappers.push(r)}}const zt=a=>a.toLowerCase().replace(/-(\w)/g,t=>t[1].toUpperCase()),V=function(a){const t={};return Object.keys(a).forEach(function(e){t[zt(e)]=a[e]}),t},Ie=function(a){const{serverControl:t,targetDuration:e,partTargetDuration:r}=a;if(!t)return;const s="#EXT-X-SERVER-CONTROL",n="holdBack",i="partHoldBack",o=e&&e*3,c=r&&r*2;e&&!t.hasOwnProperty(n)&&(t[n]=o,this.trigger("info",{message:`${s} defaulting HOLD-BACK to targetDuration * 3 (${o}).`})),o&&t[n]<o&&(this.trigger("warn",{message:`${s} clamping HOLD-BACK (${t[n]}) to targetDuration * 3 (${o})`}),t[n]=o),r&&!t.hasOwnProperty(i)&&(t[i]=r*3,this.trigger("info",{message:`${s} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${t[i]}).`})),r&&t[i]<c&&(this.trigger("warn",{message:`${s} clamping PART-HOLD-BACK (${t[i]}) to partTargetDuration * 2 (${c}).`}),t[i]=c)};class Qt extends be{constructor(t={}){super(),this.lineStream=new qt,this.parseStream=new jt,this.lineStream.pipe(this.parseStream),this.mainDefinitions=t.mainDefinitions||{},this.params=new URL(t.uri,"https://a.com").searchParams,this.lastProgramDateTime=null;const e=this,r=[];let s={},n,i,o=!1;const c=function(){},d={AUDIO:{},VIDEO:{},"CLOSED-CAPTIONS":{},SUBTITLES:{}},f="urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";let p=0;this.manifest={allowCache:!0,discontinuityStarts:[],dateRanges:[],iFramePlaylists:[],segments:[]};let b=0,$=0;const T={};this.on("end",()=>{s.uri||!s.parts&&!s.preloadHints||(!s.map&&n&&(s.map=n),!s.key&&i&&(s.key=i),!s.timeline&&typeof p=="number"&&(s.timeline=p),this.manifest.preloadSegment=s)}),this.parseStream.on("data",function(l){let R,F;if(e.manifest.definitions){for(const u in e.manifest.definitions)if(l.uri&&(l.uri=l.uri.replace(`{$${u}}`,e.manifest.definitions[u])),l.attributes)for(const g in l.attributes)typeof l.attributes[g]=="string"&&(l.attributes[g]=l.attributes[g].replace(`{$${u}}`,e.manifest.definitions[u]))}({tag(){({version(){l.version&&(this.manifest.version=l.version)},"allow-cache"(){this.manifest.allowCache=l.allowed,"allowed"in l||(this.trigger("info",{message:"defaulting allowCache to YES"}),this.manifest.allowCache=!0)},byterange(){const u={};"length"in l&&(s.byterange=u,u.length=l.length,"offset"in l||(l.offset=b)),"offset"in l&&(s.byterange=u,u.offset=l.offset),b=u.offset+u.length},endlist(){this.manifest.endList=!0},inf(){"mediaSequence"in this.manifest||(this.manifest.mediaSequence=0,this.trigger("info",{message:"defaulting media sequence to zero"})),"discontinuitySequence"in this.manifest||(this.manifest.discontinuitySequence=0,this.trigger("info",{message:"defaulting discontinuity sequence to zero"})),l.title&&(s.title=l.title),l.duration>0&&(s.duration=l.duration),l.duration===0&&(s.duration=.01,this.trigger("info",{message:"updating zero segment duration to a small value"})),this.manifest.segments=r},key(){if(!l.attributes){this.trigger("warn",{message:"ignoring key declaration without attribute list"});return}if(l.attributes.METHOD==="NONE"){i=null;return}if(!l.attributes.URI){this.trigger("warn",{message:"ignoring key declaration without URI"});return}if(l.attributes.KEYFORMAT==="com.apple.streamingkeydelivery"){this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.apple.fps.1_0"]={attributes:l.attributes};return}if(l.attributes.KEYFORMAT==="com.microsoft.playready"){this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.microsoft.playready"]={uri:l.attributes.URI};return}if(l.attributes.KEYFORMAT===f){if(["SAMPLE-AES","SAMPLE-AES-CTR","SAMPLE-AES-CENC"].indexOf(l.attributes.METHOD)===-1){this.trigger("warn",{message:"invalid key method provided for Widevine"});return}if(l.attributes.METHOD==="SAMPLE-AES-CENC"&&this.trigger("warn",{message:"SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"}),l.attributes.URI.substring(0,23)!=="data:text/plain;base64,"){this.trigger("warn",{message:"invalid key URI provided for Widevine"});return}if(!(l.attributes.KEYID&&l.attributes.KEYID.substring(0,2)==="0x")){this.trigger("warn",{message:"invalid key ID provided for Widevine"});return}this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.widevine.alpha"]={attributes:{schemeIdUri:l.attributes.KEYFORMAT,keyId:l.attributes.KEYID.substring(2)},pssh:Gt(l.attributes.URI.split(",")[1])};return}l.attributes.METHOD||this.trigger("warn",{message:"defaulting key method to AES-128"}),i={method:l.attributes.METHOD||"AES-128",uri:l.attributes.URI},typeof l.attributes.IV<"u"&&(i.iv=l.attributes.IV)},"media-sequence"(){if(!isFinite(l.number)){this.trigger("warn",{message:"ignoring invalid media sequence: "+l.number});return}this.manifest.mediaSequence=l.number},"discontinuity-sequence"(){if(!isFinite(l.number)){this.trigger("warn",{message:"ignoring invalid discontinuity sequence: "+l.number});return}this.manifest.discontinuitySequence=l.number,p=l.number},"playlist-type"(){if(!/VOD|EVENT/.test(l.playlistType)){this.trigger("warn",{message:"ignoring unknown playlist type: "+l.playlist});return}this.manifest.playlistType=l.playlistType},map(){n={},l.uri&&(n.uri=l.uri),l.byterange&&(n.byterange=l.byterange),i&&(n.key=i)},"stream-inf"(){if(this.manifest.playlists=r,this.manifest.mediaGroups=this.manifest.mediaGroups||d,!l.attributes){this.trigger("warn",{message:"ignoring empty stream-inf attributes"});return}s.attributes||(s.attributes={}),Z(s.attributes,l.attributes)},media(){if(this.manifest.mediaGroups=this.manifest.mediaGroups||d,!(l.attributes&&l.attributes.TYPE&&l.attributes["GROUP-ID"]&&l.attributes.NAME)){this.trigger("warn",{message:"ignoring incomplete or missing media group"});return}const u=this.manifest.mediaGroups[l.attributes.TYPE];u[l.attributes["GROUP-ID"]]=u[l.attributes["GROUP-ID"]]||{},R=u[l.attributes["GROUP-ID"]],F={default:/yes/i.test(l.attributes.DEFAULT)},F.default?F.autoselect=!0:F.autoselect=/yes/i.test(l.attributes.AUTOSELECT),l.attributes.LANGUAGE&&(F.language=l.attributes.LANGUAGE),l.attributes.URI&&(F.uri=l.attributes.URI),l.attributes["INSTREAM-ID"]&&(F.instreamId=l.attributes["INSTREAM-ID"]),l.attributes.CHARACTERISTICS&&(F.characteristics=l.attributes.CHARACTERISTICS),l.attributes.FORCED&&(F.forced=/yes/i.test(l.attributes.FORCED)),R[l.attributes.NAME]=F},discontinuity(){p+=1,s.discontinuity=!0,this.manifest.discontinuityStarts.push(r.length)},"program-date-time"(){typeof this.manifest.dateTimeString>"u"&&(this.manifest.dateTimeString=l.dateTimeString,this.manifest.dateTimeObject=l.dateTimeObject),s.dateTimeString=l.dateTimeString,s.dateTimeObject=l.dateTimeObject;const{lastProgramDateTime:u}=this;this.lastProgramDateTime=new Date(l.dateTimeString).getTime(),u===null&&this.manifest.segments.reduceRight((g,w)=>(w.programDateTime=g-w.duration*1e3,w.programDateTime),this.lastProgramDateTime)},targetduration(){if(!isFinite(l.duration)||l.duration<0){this.trigger("warn",{message:"ignoring invalid target duration: "+l.duration});return}this.manifest.targetDuration=l.duration,Ie.call(this,this.manifest)},start(){if(!l.attributes||isNaN(l.attributes["TIME-OFFSET"])){this.trigger("warn",{message:"ignoring start declaration without appropriate attribute list"});return}this.manifest.start={timeOffset:l.attributes["TIME-OFFSET"],precise:l.attributes.PRECISE}},"cue-out"(){s.cueOut=l.data},"cue-out-cont"(){s.cueOutCont=l.data},"cue-in"(){s.cueIn=l.data},skip(){this.manifest.skip=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-SKIP",l.attributes,["SKIPPED-SEGMENTS"])},part(){o=!0;const u=this.manifest.segments.length,g=V(l.attributes);s.parts=s.parts||[],s.parts.push(g),g.byterange&&(g.byterange.hasOwnProperty("offset")||(g.byterange.offset=$),$=g.byterange.offset+g.byterange.length);const w=s.parts.length-1;this.warnOnMissingAttributes_(`#EXT-X-PART #${w} for segment #${u}`,l.attributes,["URI","DURATION"]),this.manifest.renditionReports&&this.manifest.renditionReports.forEach((E,y)=>{E.hasOwnProperty("lastPart")||this.trigger("warn",{message:`#EXT-X-RENDITION-REPORT #${y} lacks required attribute(s): LAST-PART`})})},"server-control"(){const u=this.manifest.serverControl=V(l.attributes);u.hasOwnProperty("canBlockReload")||(u.canBlockReload=!1,this.trigger("info",{message:"#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"})),Ie.call(this,this.manifest),u.canSkipDateranges&&!u.hasOwnProperty("canSkipUntil")&&this.trigger("warn",{message:"#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"})},"preload-hint"(){const u=this.manifest.segments.length,g=V(l.attributes),w=g.type&&g.type==="PART";s.preloadHints=s.preloadHints||[],s.preloadHints.push(g),g.byterange&&(g.byterange.hasOwnProperty("offset")||(g.byterange.offset=w?$:0,w&&($=g.byterange.offset+g.byterange.length)));const E=s.preloadHints.length-1;if(this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${E} for segment #${u}`,l.attributes,["TYPE","URI"]),!!g.type)for(let y=0;y<s.preloadHints.length-1;y++){const _=s.preloadHints[y];_.type&&_.type===g.type&&this.trigger("warn",{message:`#EXT-X-PRELOAD-HINT #${E} for segment #${u} has the same TYPE ${g.type} as preload hint #${y}`})}},"rendition-report"(){const u=V(l.attributes);this.manifest.renditionReports=this.manifest.renditionReports||[],this.manifest.renditionReports.push(u);const g=this.manifest.renditionReports.length-1,w=["LAST-MSN","URI"];o&&w.push("LAST-PART"),this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${g}`,l.attributes,w)},"part-inf"(){this.manifest.partInf=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-PART-INF",l.attributes,["PART-TARGET"]),this.manifest.partInf.partTarget&&(this.manifest.partTargetDuration=this.manifest.partInf.partTarget),Ie.call(this,this.manifest)},daterange(){this.manifest.dateRanges.push(V(l.attributes));const u=this.manifest.dateRanges.length-1;this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${u}`,l.attributes,["ID","START-DATE"]);const g=this.manifest.dateRanges[u];g.endDate&&g.startDate&&new Date(g.endDate)<new Date(g.startDate)&&this.trigger("warn",{message:"EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"}),g.duration&&g.duration<0&&this.trigger("warn",{message:"EXT-X-DATERANGE DURATION must not be negative"}),g.plannedDuration&&g.plannedDuration<0&&this.trigger("warn",{message:"EXT-X-DATERANGE PLANNED-DURATION must not be negative"});const w=!!g.endOnNext;if(w&&!g.class&&this.trigger("warn",{message:"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"}),w&&(g.duration||g.endDate)&&this.trigger("warn",{message:"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"}),g.duration&&g.endDate){const E=g.startDate.getTime()+g.duration*1e3;this.manifest.dateRanges[u].endDate=new Date(E)}if(!T[g.id])T[g.id]=g;else{for(const y in T[g.id])if(g[y]&&JSON.stringify(T[g.id][y])!==JSON.stringify(g[y])){this.trigger("warn",{message:"EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"});break}const E=this.manifest.dateRanges.findIndex(y=>y.id===g.id);this.manifest.dateRanges[E]=Z(this.manifest.dateRanges[E],g),T[g.id]=Z(T[g.id],g),this.manifest.dateRanges.pop()}},"independent-segments"(){this.manifest.independentSegments=!0},"i-frames-only"(){this.manifest.iFramesOnly=!0,this.requiredCompatibilityversion(this.manifest.version,4)},"content-steering"(){this.manifest.contentSteering=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING",l.attributes,["SERVER-URI"])},define(){this.manifest.definitions=this.manifest.definitions||{};const u=(g,w)=>{if(g in this.manifest.definitions){this.trigger("error",{message:`EXT-X-DEFINE: Duplicate name ${g}`});return}this.manifest.definitions[g]=w};if("QUERYPARAM"in l.attributes){if("NAME"in l.attributes||"IMPORT"in l.attributes){this.trigger("error",{message:"EXT-X-DEFINE: Invalid attributes"});return}const g=this.params.get(l.attributes.QUERYPARAM);if(!g){this.trigger("error",{message:`EXT-X-DEFINE: No query param ${l.attributes.QUERYPARAM}`});return}u(l.attributes.QUERYPARAM,decodeURIComponent(g));return}if("NAME"in l.attributes){if("IMPORT"in l.attributes){this.trigger("error",{message:"EXT-X-DEFINE: Invalid attributes"});return}if(!("VALUE"in l.attributes)||typeof l.attributes.VALUE!="string"){this.trigger("error",{message:`EXT-X-DEFINE: No value for ${l.attributes.NAME}`});return}u(l.attributes.NAME,l.attributes.VALUE);return}if("IMPORT"in l.attributes){if(!this.mainDefinitions[l.attributes.IMPORT]){this.trigger("error",{message:`EXT-X-DEFINE: No value ${l.attributes.IMPORT} to import, or IMPORT used on main playlist`});return}u(l.attributes.IMPORT,this.mainDefinitions[l.attributes.IMPORT]);return}this.trigger("error",{message:"EXT-X-DEFINE: No attribute"})},"i-frame-playlist"(){this.manifest.iFramePlaylists.push({attributes:l.attributes,uri:l.uri,timeline:p}),this.warnOnMissingAttributes_("#EXT-X-I-FRAME-STREAM-INF",l.attributes,["BANDWIDTH","URI"])}}[l.tagType]||c).call(e)},uri(){s.uri=l.uri,r.push(s),this.manifest.targetDuration&&!("duration"in s)&&(this.trigger("warn",{message:"defaulting segment duration to the target duration"}),s.duration=this.manifest.targetDuration),i&&(s.key=i),s.timeline=p,n&&(s.map=n),$=0,this.lastProgramDateTime!==null&&(s.programDateTime=this.lastProgramDateTime,this.lastProgramDateTime+=s.duration*1e3),s={}},comment(){},custom(){l.segment?(s.custom=s.custom||{},s.custom[l.customType]=l.data):(this.manifest.custom=this.manifest.custom||{},this.manifest.custom[l.customType]=l.data)}})[l.type].call(e)})}requiredCompatibilityversion(t,e){(t<e||!t)&&this.trigger("warn",{message:`manifest must be at least version ${e}`})}warnOnMissingAttributes_(t,e,r){const s=[];r.forEach(function(n){e.hasOwnProperty(n)||s.push(n)}),s.length&&this.trigger("warn",{message:`${t} lacks required attribute(s): ${s.join(", ")}`})}push(t){this.lineStream.push(t)}end(){this.lineStream.push(`
`),this.manifest.dateRanges.length&&this.lastProgramDateTime===null&&this.trigger("warn",{message:"A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"}),this.lastProgramDateTime=null,this.trigger("end")}addParser(t){this.parseStream.addParser(t)}addTagMapper(t){this.parseStream.addTagMapper(t)}}console.log("DOWNLOAD_HANDLER.TS IS BEING LOADED AND PARSED");const qe=x.create("DownloadHandler_EarlyTest",X.Debug);qe.logError("DOWNLOAD_HANDLER.TS - EARLY ERROR LOG TEST"),qe.logDebug("DOWNLOAD_HANDLER.TS - EARLY DEBUG LOG TEST");class B extends Error{constructor(t,e){super(`${t} (TrackId: ${e})`)}}const h=x.create("DownloadHandler",X.Debug),ee=new _e;function Kt(a){return a&&a.kind==="track"&&a.state==="finished"&&(a.streamable||a.downloadable)}function Jt(a){return typeof a=="object"&&a!==null&&"protocol"in a}function Zt(a){if(a?.media?.transcodings?.length<1)return h.logDebug(`[DownloadHandler TrackId: ${a.id}] No transcodings array or empty in track.media.`),null;h.logDebug(`[DownloadHandler TrackId: ${a.id}] Raw transcodings:`,JSON.stringify(a.media.transcodings,null,2));const t=a.media.transcodings.filter(r=>(r.format?.protocol==="progressive"||r.format?.protocol==="hls")&&(r.format?.mime_type?.startsWith("audio/mpeg")||r.format?.mime_type?.startsWith("audio/mp4"))&&!r.snipped).map(r=>({protocol:r.format.protocol,url:r.url,quality:r.quality}));if(t.length<1)return h.logWarn("[DownloadHandler] No transcodings streams could be determined for Track "+a.id),null;let e=t.sort((r,s)=>r.quality==="hq"&&s.quality==="sq"?-1:r.quality==="sq"&&s.quality==="hq"?1:r.protocol==="progressive"&&s.protocol==="hls"?-1:r.protocol==="hls"&&s.protocol==="progressive"?1:0);return S("download-hq-version")||(e=e.filter(r=>r.quality!=="hq")),e.some(r=>r.quality==="hq")&&h.logInfo("[DownloadHandler] Including high quality streams for Track "+a.id),e}async function Ye(a,t,e,r,s){if(!Kt(a))throw h.logError("[DownloadHandler] Track does not satisfy constraints needed to be downloadable",a),new B("Track does not satisfy constraints needed to be downloadable",a.id);const n=[];if(S("download-original-version")&&a.downloadable&&a.has_downloads_left){const o=await ee.getOriginalDownloadUrl(a.id);if(o){const c={url:o,hls:!1,extension:void 0};n.push(c)}}const i=Zt(a);if(i&&n.push(...i),n.length<1){const o=`[DownloadHandler] No download details could be determined for track: "${a.title}"`;throw new B(o,a.id)}for(const o of n){let c=null,d=!1,f=null,p;try{if(Jt(o))if(h.logDebug(`[DownloadHandler TrackId: ${a.id}] Getting stream details for transcoding`,o),c=await ee.getStreamDetails(o.url),c)d=c.hls,f=c.url,p=c.extension;else{h.logWarn(`[DownloadHandler TrackId: ${a.id}] Failed to get stream details for transcoding option (url: ${o.url}), trying next...`);continue}else c=o,f=c.url,d=c.hls,p=c.extension,h.logDebug(`[DownloadHandler TrackId: ${a.id}] Using direct download detail (original file?)`,{url:f,hls:d,extension:p});if(!f){h.logWarn(`[DownloadHandler TrackId: ${a.id}] No stream URL resolved, trying next...`,{downloadDetail:o});continue}let b=f,$=d;const T={trackId:a.id,duration:a.duration,uploadDate:new Date(a.display_date),streamUrl:b,fileExtension:p,title:a.title,username:a.user.username,userPermalink:a.user.permalink,artworkUrl:a.artwork_url,avatarUrl:a.user.avatar_url,trackNumber:t,albumName:e,playlistName:r,hls:$,wasOriginallyHls:d};h.logDebug(`[DownloadHandler TrackId: ${a.id}] Calling handleDownload with data`,{downloadData:T});const l=await er(T,s);return h.logInfo(`[DownloadHandler TrackId: ${a.id}] handleDownload returned browserDownloadId: ${l} for stream: ${b}`),s(101,l),l}catch(b){h.logWarn(`[DownloadHandler TrackId: ${a.id}] Download attempt failed for option. Error: ${b?.message||b}`,{downloadDetail:o,streamUrl:f})}}throw h.logError(`[DownloadHandler TrackId: ${a.id}] All download attempts failed after trying ${n.length} options.`),s(102),new B("No version of this track could be downloaded",a.id)}async function er(a,t){h.logDebug(`[handleDownload ENTRY] Processing TrackId: ${a.trackId}. History check comes later.`);let e=a.username,r=a.title,s,n=a.artworkUrl,i,o,c,d,f,p,b,$,T;try{try{if(h.logInfo(`Initiating metadata processing for ${a.trackId} with payload`,{payload:a}),S("normalize-track")){const u=new C(a.title,a.username,a.userPermalink);let g=u.getArtists();S("include-producers")||(g=g.filter(E=>E.type!==Ee.Producer)),e=g.map(E=>E.name).join(", "),r=u.getTitle();const w=g.filter(E=>E.type===Ee.Remixer);if(w.length>0){const E=w.map(_=>_.name).join(" & "),y=we[w[0].remixType||we.Remix].toString();r+=` (${E} ${y})`}}e||(e="Unknown"),r||(r="Unknown"),s=le(`${e} - ${r}`)}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during metadata processing:`,u),new B(`Metadata processing failed for track ${a.trackId}: ${u.message}`,a.trackId)}c=!S("download-without-prompt"),d=S("default-download-location"),f=S("skipExistingFiles");try{const u=a.fileExtension||"mp3";if(T=s+"."+u,!c&&d)if(a.playlistName){const g=le(a.playlistName);T=d+"/"+g+"/"+T}else T=d+"/"+T;if(f){let g="";if(d)if(a.playlistName){const N=le(a.playlistName);g=d+"/"+N+"/"}else g=d+"/";const w=`track-${a.trackId}`,E=await ve("track-download-history")||{};if(h.logDebug(`[History Check] shouldSkipExisting=${f}, trackIdKey=${w}, history exists=${!!E}`),Object.keys(E).length>0&&h.logDebug(`[History Check] History has ${Object.keys(E).length} entries`),E&&E[w]){const N=E[w];h.logInfo(`Skipping download for TrackId: ${a.trackId}. Previously downloaded as: ${N.filename} at ${new Date(N.timestamp).toLocaleString()}`),t(101);const U=Math.floor(Math.random()*1e6)+1e3;return h.logInfo(`Using fake download ID ${U} for skipped track ${a.trackId}`),U}const y={filename:`${g}${s}.${a.fileExtension||"mp3"}`};h.logDebug(`[History Check] Searching downloads with exactQuery: ${JSON.stringify(y)}`);const _=await fe(y);h.logDebug(`[History Check] exactMatches found: ${_.length}`);const z=g.replace(/[-/^$*+?.()|[\]{}]/g,"\\$&"),Q=s.replace(/[-/^$*+?.()|[\]{}]/g,"\\$&"),ie={filenameRegex:`^${z}${Q}\\..+$`};h.logDebug(`[History Check] Searching downloads with regexQuery: ${JSON.stringify(ie)}`);const re=_.length===0?await fe(ie):[];h.logDebug(`[History Check] regexMatches found: ${re.length}`);const K={filenameRegex:`${Q}\\..+$`};h.logDebug(`[History Check] Searching downloads with titleArtistQuery: ${JSON.stringify(K)}`);const k=_.length===0&&re.length===0?await fe(K):[];h.logDebug(`[History Check] titleArtistMatches found: ${k.length}`);const v=[..._,...re,...k].filter(N=>N.state==="complete");if(v.length>0){h.logInfo(`Skipping download for TrackId: ${a.trackId}. File already exists in download history: ${v[0].filename}`),v.length>0&&v.slice(0,3).forEach((U,et)=>{h.logDebug(`[History Check] Match ${et}: filename=${U.filename}, state=${U.state}`)}),E[w]={filename:v[0].filename,timestamp:Date.now()},await M("track-download-history",E),t(101);const N=Math.floor(Math.random()*1e6)+1e3;return h.logInfo(`Using fake download ID ${N} for already downloaded track ${a.trackId}`),N}else h.logDebug(`No matching downloads found for TrackId: ${a.trackId} with filename base "${s}"`)}else h.logDebug("[History Check] Skip existing files check is disabled")}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during filename/skip logic:`,u),new B(`Filename/skip logic failed for track ${a.trackId}: ${u.message}`,a.trackId)}try{n||(h.logInfo(`No Artwork URL in data. Fallback to User Avatar (TrackId: ${a.trackId})`),n=a.avatarUrl)}catch(u){h.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Error checking/falling back artwork URL: ${u.message}. Will attempt with current value.`)}h.logInfo(`Starting download of '${s}' (TrackId: ${a.trackId})...`);let l;try{if(a.hls){h.logInfo(`[TrackId: ${a.trackId}] Starting HLS segment fetching from: ${a.streamUrl}`);const[u,g]=await ee.downloadStream(a.streamUrl,k=>{k!==void 0&&t(k*.1)});if(o=g,!u)throw new Error("HLS playlist download failed or returned empty buffer.");const w=new TextDecoder().decode(u),E=new Qt;E.push(w),E.end();let y=null;if(E.manifest?.segments?.length>0){const k=E.manifest.segments.find(v=>v.map?.uri);if(k?.map?.uri){let v=k.map.uri;try{v.startsWith("http://")||v.startsWith("https://")||(v=new URL(v,a.streamUrl).href)}catch{if(!(v.startsWith("http://")||v.startsWith("https://")))throw new Error(`Failed to resolve relative HLS init segment URI: ${v}`)}const[N]=await ee.downloadStream(v,U=>{U!==void 0&&t(5+U*.05)});if(!N)throw new Error(`Failed to download HLS init segment: ${v}`);y=N}}let _=[];if(E.manifest?.segments?.length>0&&(_=E.manifest.segments.map(k=>{try{return new URL(k.uri,a.streamUrl).href}catch{if(k.uri.startsWith("http://")||k.uri.startsWith("https://"))return k.uri;throw new Error(`Failed to resolve relative HLS segment URI: ${k.uri}`)}})),_.length===0&&!y)throw new Error("HLS playlist contains no media segments or init segment.");const z=[],Q=_.length,ie=y?10:5,re=y?80:85;for(let k=0;k<Q;k++){const[v]=await ee.downloadStream(_[k],U=>{U!==void 0&&t(ie+(k+U/100)/Q*re)});if(!v)throw new Error(`Failed to download HLS segment: ${_[k]}`);z.push(v);const N=S("hls-rate-limit-delay-ms")??0;N>0&&k<Q-1&&await new Promise(U=>setTimeout(U,N))}const K=[];y&&K.push(y),K.push(...z),i=ke(K),a.hls=!1}else[i,o]=await ee.downloadStream(a.streamUrl,t);if(!i)throw new B("Stream buffer is undefined after download attempts",a.trackId);if(l=i.slice(0),h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] Initial streamBuffer byteLength: ${i?.byteLength}, originalStreamBuffer byteLength: ${l?.byteLength}`),a.wasOriginallyHls&&a.fileExtension&&/^[a-f0-9]{4}$/i.test(a.fileExtension)&&a.streamUrl.includes("/aac")?(h.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Correcting likely bogus HLS AAC extension '${a.fileExtension}' to 'm4a'.`),a.fileExtension="m4a"):a.wasOriginallyHls&&a.fileExtension&&a.fileExtension.toLowerCase()==="m3u8"&&(h.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Correcting HLS extension from 'm3u8' to 'm4a' (assuming AAC).`),a.fileExtension="m4a"),!a.fileExtension&&o){p=o.get("content-type");let u="mp3";p==="audio/mp4"?u="m4a":(p==="audio/x-wav"||p==="audio/wav")&&(u="wav"),a.fileExtension=u}else a.fileExtension||(a.fileExtension="mp3");if(S("ffmpeg-remux-hls-mp4")&&(a.fileExtension==="m4a"||a.fileExtension==="mp4")){t(85);const u=g=>{const w=85+Math.floor(g*.13);t(w)};try{h.logInfo(`[DownloadHandler TrackId: ${a.trackId}] Sending remux task to FFmpegManager. Original streamBuffer byteLength before remux: ${l?.byteLength}`),i=await vt(a.trackId.toString(),l,a.fileExtension||"mp4",u),(a.fileExtension==="m4a"||a.fileExtension==="mp4")&&(p="audio/mp4"),t(99),h.logInfo(`[DownloadHandler TrackId: ${a.trackId}] Remux task completed by FFmpegManager.`)}catch(g){h.logError(`[FFMPEG_MANAGER] Error during remux via manager. Proceeding with original. TrackId: ${a.trackId}`,g),i=l.slice(0),h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] FFmpeg failed. Fallen back to originalStreamBuffer. ByteLength: ${i?.byteLength}`)}}else h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] FFmpeg remux skipped (disabled or not applicable filetype).`)}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during download/FFmpeg stage:`,u),new B(`Download/FFmpeg failed for track ${a.trackId}: ${u.message}`,a.trackId)}let R;try{const u=S("set-metadata");if(h.logDebug(`[Metadata Check Before If] TrackId: ${a.trackId}, setMetadata config: ${u}, streamBuffer exists: ${!!i}`),u&&i){let g;const w=i.slice(0);if(a.fileExtension==="mp3"?g=new Ct(w):(a.fileExtension==="m4a"||a.fileExtension==="mp4")&&(g=new D(w)),g){if(r&&g.setTitle(r),e&&g.setArtists([e]),a.albumName?g.setAlbum(a.albumName):a.playlistName&&g.setAlbum(a.playlistName),a.uploadDate){const y=a.uploadDate.getFullYear();isNaN(y)||g.setYear(y)}if(a.trackNumber&&g.setTrackNumber(a.trackNumber),a.trackId?g.setSoundCloudTrackId(a.trackId.toString()):h.logWarn(`[Metadata] TrackId is missing in data, cannot set SoundCloudTrackID for tagging. Track Title: ${a.title}`),n)try{const y=n.replace("-large.jpg","-t500x500.jpg"),_=await fetch(y);if(!_.ok)throw new Error(`Artwork fetch failed: ${_.statusText}`);const z=await _.arrayBuffer();g.setArtwork(z)}catch(y){h.logWarn(`[Artwork] Failed to fetch/set artwork for tagging TrackId: ${a.trackId}`,y)}const E=await g.getBuffer();h.logDebug(`[Metadata] TagWriter result for TrackId ${a.trackId} (ext: ${a.fileExtension}): applied=${E.tagsApplied}, message='${E.message||"none"}'`),E?.buffer?.byteLength>0?R=E.buffer:(h.logWarn("[Metadata] TagWriter returned invalid buffer. Using untagged buffer."),R=i.slice(0))}else h.logWarn(`[TrackId: ${a.trackId}] No TagWriter for ext '${a.fileExtension}'. Using untagged buffer.`),R=i.slice(0)}else h.logInfo(`[TrackId: ${a.trackId}] Metadata disabled or no streamBuffer. Using untagged.`),R=i?.slice(0)}catch(u){h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during metadata tagging:`,u),R=i?.slice(0)}let F;try{F=R?.byteLength>0?R:i?.byteLength>0?i.slice(0):l?.byteLength>0?l.slice(0):(()=>{throw new B(`All buffers invalid for ${a.trackId}`,a.trackId)})(),F.byteLength<100&&h.logWarn(`Final buffer small: ${F.byteLength} bytes.`),h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] Final bufferToSave byteLength before Blob creation: ${F?.byteLength}`);const u={};p?u.type=p:a.fileExtension==="mp3"?u.type="audio/mpeg":a.fileExtension==="m4a"||a.fileExtension==="mp4"?u.type="audio/mp4":a.fileExtension==="wav"&&(u.type="audio/wav");const g=new Blob([F],u);h.logInfo(`Creating URL for download (TrackId: ${a.trackId}). Service worker context: ${rt()}`),$=await at(g)}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error preparing final buffer or Blob/DataURL:`,u),new B(`Failed to prepare buffer/DataURL for track ${a.trackId}: ${u.message}`,a.trackId)}if(b=s+"."+(a.fileExtension||"mp3"),!c&&d){const u=d.endsWith("/")?d.slice(0,-1):d,g=a.playlistName?`/${le(a.playlistName)}`:"",w=b.split("/").pop()||b;b=`${u}${g}/${w}`}try{h.logInfo(`Downloading track as '${b}' (TrackId: ${a.trackId}). SaveAs: ${c}`);const u=$;if(!u)throw new Error("Data URL for download is undefined.");const g=await st(u,b,c);if(h.logInfo(`Successfully initiated browser download for '${s}' (TrackId: ${a.trackId}) with browserDownloadId: ${g}`),f){const w=`track-${a.trackId}`,E=await ve("track-download-history")||{};E[w]={filename:b,timestamp:Date.now()},await M("track-download-history",E)}return g}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Download save stage error:`,u),new B(`Save failed for track ${a.trackId}: ${u.message}`,a.trackId)}}catch(l){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Uncaught error in handleDownload`,l),l instanceof B?l:new B(`Unknown error during download: ${l?.message||l}`,a.trackId)}}const te=x.create("Semaphore",X.Debug);class Ve{tasks=[];count;maxCount;constructor(t){if(t<=0)throw new Error("Semaphore count must be a positive integer.");this.count=t,this.maxCount=t}async acquire(){return te.logDebug(`Acquire attempt: current count ${this.count}, tasks in queue ${this.tasks.length}`),this.count>0?(this.count--,te.logDebug(`Acquired immediately. New count ${this.count}`),Promise.resolve()):new Promise(t=>{this.tasks.push(t),te.logDebug(`Queued. New queue length ${this.tasks.length}`)})}release(){if(this.count++,te.logDebug(`Released. New count ${this.count}`),this.tasks.length>0){const t=this.tasks.shift();t&&(this.count--,te.logDebug(`Processing queued task. New count ${this.count}, New queue length ${this.tasks.length}`),t())}this.count>this.maxCount&&(te.logWarn(`Semaphore count (${this.count}) exceeded maxCount (${this.maxCount}) after release. This might indicate an issue.`),this.count=this.maxCount)}async withLock(t){await this.acquire();try{return await t()}finally{this.release()}}getAvailablePermits(){return this.count}getQueueLength(){return this.tasks.length}}const se=new _e,m=x.create("Background",X.Debug),tr=nt(),L=[];let Ae=!1;const ne=()=>{m.logDebug("[Queue Broadcast] Sending queue update."),chrome?.runtime?.sendMessage?chrome.runtime.sendMessage({type:"QUEUE_UPDATED_BROADCAST",queuePayload:L},a=>{if(chrome.runtime.lastError){const t=chrome.runtime.lastError.message?.toLowerCase()||"";!t.includes("message port closed")&&!t.includes("receiving end does not exist")&&m.logWarn("[Queue Broadcast] Error sending queue update:",chrome.runtime.lastError.message)}}):m.logWarn("[Queue Broadcast] chrome.runtime.sendMessage not available?")},rr=async a=>{m.logInfo(`[QueueProcessor _executeDownloadTask] Starting task for ID: ${a.id}, Type: ${a.type}, URL: ${a.url}`),a.status="processing",ne(),a.tabId&&G(a.tabId,a.id,0,void 0,"Resuming");const t=(e,r)=>{e!==void 0&&(a.progress=e,a.tabId&&G(a.tabId,a.id,e,void 0,r?void 0:"Resuming",r),ne())};try{if(a.type==="DOWNLOAD"){const e=a.originalMessage.url;if(!e)throw new Error("Missing URL in original message for DOWNLOAD item");m.logInfo(`[QueueProcessor _executeDownloadTask] Resolving track URL: ${e} for item ${a.id}`);const r=await se.resolveUrl(e);if(!r||r.kind!=="track")throw new Error(`Failed to resolve URL to a valid track: ${e}`);m.logInfo(`[QueueProcessor _executeDownloadTask] Track resolved: ${r.title}. Starting download for item ${a.id}`),await Ye(r,void 0,void 0,void 0,t),a.status="completed",m.logInfo(`[QueueProcessor _executeDownloadTask] DOWNLOAD complete for item ${a.id}: ${r.title}`)}else if(a.type==="DOWNLOAD_SET"){const e=a.originalMessage.url;if(!e)throw new Error("Missing URL in original message for DOWNLOAD_SET item");m.logInfo(`[QueueProcessor _executeDownloadTask] Resolving set URL: ${e} for item ${a.id}`);const r=await se.resolveUrl(e);if(!r||!r.tracks||r.tracks.length===0)throw new Error(`Failed to resolve URL to a valid playlist or playlist is empty: ${e}`);const s=r.tracks.map(T=>T.id);if(s.length===0){m.logWarn(`[Queue Set ${a.id}] Playlist resolved but contains no track IDs?`),a.status="completed";return}m.logInfo(`[QueueProcessor _executeDownloadTask] Set resolved: ${r.title}. Fetching full details for ${s.length} tracks for item ${a.id}`);const n=sr(s,50),i=[];for(const T of n){const l=await se.getTracks(T);i.push(...Object.values(l))}m.logInfo(`[QueueProcessor _executeDownloadTask] Fetched full details for ${i.length} tracks.`);const o={};let c=!1,d=null;const f=()=>{const T=Object.values(o).reduce((l,R)=>l+R,0);return i.length>0?T/i.length:0};a.progress=0,t(0);const p=r.set_type==="album"||r.set_type==="ep"?r.title:void 0,b=r.set_type!=="album"&&r.set_type!=="ep"?r.title:void 0,$=[];for(let T=0;T<i.length;T++){const l=i[T],R=T+1,F=(u,g)=>{if(u!==void 0){o[l.id]=u;const w=f();t(w,g)}};$.push(ze.withLock(()=>(m.logDebug(`[Queue Set ${a.id}] Starting download for track ${R}/${i.length}: ${l.title} (ID: ${l.id})`),Ye(l,R,p,b,F))).catch(u=>{m.logWarn(`[Queue Set ${a.id}] Failed to download track ${R}: ${l.title}`,u),c=!0,d=u?.message||String(u),o[l.id]=100;const g=f();t(g)}))}m.logInfo(`[Queue Set ${a.id}] Waiting for ${$.length} track downloads to complete...`),await Promise.all($),m.logInfo(`[Queue Set ${a.id}] All track download attempts finished.`),c?(a.status="error",a.error="One or more tracks failed to download within the set.",m.logWarn(`[Queue Set ${a.id}] DOWNLOAD_SET completed with errors. Last individual error logged was: ${d||"None recorded"}`),a.tabId&&G(a.tabId,a.id,102,a.error)):(a.status="completed",a.progress=101,m.logInfo(`[Queue Set ${a.id}] DOWNLOAD_SET completed successfully.`),a.tabId&&G(a.tabId,a.id,101))}else a.type==="DOWNLOAD_SET_RANGE"?(m.logWarn(`[QueueProcessor _executeDownloadTask] DOWNLOAD_SET_RANGE for ${a.id} not yet implemented in queue processor.`),a.status="error",a.error="Set range downloads via queue not yet implemented.",a.tabId&&G(a.tabId,a.id,void 0,a.error)):(m.logError(`[QueueProcessor _executeDownloadTask] Unknown item type: ${a.type} for item ID: ${a.id}`),a.status="error",a.error="Unknown download type",a.tabId&&G(a.tabId,a.id,void 0,a.error))}catch(e){m.logError(`[QueueProcessor _executeDownloadTask] Error processing item ${a.id}:`,e),a.status="error",a.error=e.message||"Unknown error during processing",a.tabId&&G(a.tabId,a.id,void 0,a.error,void 0)}finally{ne()}},ar=async()=>{if(Ae)return;Ae=!0;const a=L.findIndex(t=>t.status==="pending");if(a!==-1){const t=L[a];await rr(t);const e=L.findIndex(r=>r.id===t.id);e!==-1&&(L[e].status==="completed"||L[e].status==="error")&&(m.logInfo(`[QueueProcessor] Removing finalized item ${L[e].id} (Status: ${L[e].status}) from queue.`),L.splice(e,1),ne())}Ae=!1,L.some(t=>t.status==="pending")&&$e()},$e=()=>{setTimeout(()=>{m.logInfo("[QueueProcessor trigger] Checking queue..."),ar()},0)},je=()=>Math.max(1,Math.min(Number(S("maxConcurrentTrackDownloads"))||3,10));let ze=new Ve(je());m.logInfo(`Download track semaphore initialized with concurrency: ${je()}`),he("maxConcurrentTrackDownloads",a=>{const t=Math.max(1,Math.min(Number(a)||3,10));m.logInfo(`Updating download track semaphore concurrency to: ${t}`),ze=new Ve(t)});async function Qe(a){await gt(a)}async function Ke(a){await dt(a)}m.logInfo("Starting with version: "+tr.version),it(wt),m.logInfo("Initial message listener registered."),Re(!0).then(async()=>{m.logInfo("Initial configuration loaded. Setting initial DNR rules.");const a=S("oauth-token");await Qe(a);const t=S("client-id");await Ke(t),a&&await Ze(a),_t()});function G(a,t,e,r,s,n){if(!t||typeof t!="string"||t.trim()===""){m.logError(`Attempted to send download progress with invalid downloadId: ${JSON.stringify(t)}`);const c=new Error().stack;if(m.logError(`Call stack for invalid downloadId: ${c}`),e===101||e===102){m.logWarn(`Attempting to send COMPLETION message (${e}) even with missing downloadId`);const d={downloadId:"undefined_completion",progress:e,error:typeof r=="string"?r:r instanceof Error?r.message:"",status:s,completionWithoutId:!0,timestamp:Date.now(),browserDownloadId:n};oe(a,d).catch(f=>{m.logError(`Failed to send fallback completion message: ${f}`)})}return}let i="";r instanceof Error?i=r.message:typeof r=="string"&&(i=r),e===101||e===102?m.logInfo(`Sending COMPLETION message for download ${t} to tab ${a}, progress=${e}`):e===100&&m.logInfo(`Sending FINISHING message for download ${t} to tab ${a}`);const o={downloadId:t,progress:e,error:i,status:s,timestamp:Date.now(),browserDownloadId:n};e===101||e===102?(m.logInfo(`Sending SINGLE COMPLETION message for download ${t} to tab ${a}, progress=${e} (BrowserDownloadId: ${n||"N/A"})`),oe(a,o).catch(c=>{m.logWarn(`Failed to send completion message to tab ${a}:`,c)})):oe(a,o).catch(c=>{m.logWarn(`Failed to send progress/status message to tab ${a}:`,c)})}function sr(a,t){const e=[];for(let r=0;r<a.length;r+=t){const s=a.slice(r,r+t);e.push(s)}return e}const Je=new RegExp("OAuth (.+)"),nr=new RegExp("/me/followings/(\\d+)");ot(a=>{if(De()){const r=S("oauth-token");if(a.requestHeaders){for(let s=0;s<a.requestHeaders.length;s++)if(a.requestHeaders[s].name.toLowerCase()==="authorization"){const n=a.requestHeaders[s].value,i=Je.exec(n);i&&i.length>=2&&i[1]!==r&&(m.logInfo("Sniffed and storing OAuth token from request header (all envs)."),M("oauth-token",i[1]));break}}return{}}let t=!1;const e=S("oauth-token");if(a.requestHeaders){for(let r=0;r<a.requestHeaders.length;r++)if(a.requestHeaders[r].name.toLowerCase()==="authorization"){t=!0;const s=a.requestHeaders[r].value,n=Je.exec(s);n&&n.length>=2&&n[1]!==e&&(m.logInfo("Sniffed and storing OAuth token (Firefox/non-DNR)."),M("oauth-token",n[1]));break}if(!t&&e)return a.requestHeaders.push({name:"Authorization",value:"OAuth "+e}),{requestHeaders:a.requestHeaders}}return{}},["*://api-v2.soundcloud.com/*"],["blocking","requestHeaders"]),lt(a=>{const t=new URL(a.url);if(t.pathname==="/connect/session"&&S("oauth-token")===null)m.logInfo("User logged in - clearing potentially stale token."),M("oauth-token",void 0);else if(t.pathname==="/sign-out")m.logInfo("User logged out"),M("oauth-token",null),M("user-id",null),M("followed-artists",[]);else if(t.pathname.startsWith("/me/followings/")){const e=nr.exec(t.pathname);if(e&&e.length===2){const r=+e[1];if(r){let s=S("followed-artists")||[];a.method==="POST"?s.includes(r)||s.push(r):a.method==="DELETE"&&(s=s.filter(n=>n!==r)),M("followed-artists",s)}}}else{const e=t.searchParams.get("client_id");if(e){const r=S("client-id");e!==r&&(m.logInfo(`Found new client_id: ${e}. Storing it.`),M("client-id",e))}else if(!De()){const r=S("client-id");if(r)return m.logDebug(`Adding ClientId to ${a.url} via redirect (Firefox/non-DNR)`),t.searchParams.append("client_id",r),{redirectUrl:t.toString()}}}return{}},["*://api-v2.soundcloud.com/*","*://api-auth.soundcloud.com/*"],["blocking"]);const Ze=async a=>{if(!a){M("user-id",null),m.logInfo("OAuth token cleared, user ID cleared.");return}const t=await se.getCurrentUser();if(!t){m.logError("Failed to fetch currently logged in user (after token change/init)");return}M("user-id",t.id),m.logInfo("Logged in as",t.username);const e=await se.getFollowedArtistIds(t.id);if(!e){m.logError("Failed to fetch ids of followed artists");return}M("followed-artists",e)};he("oauth-token",async a=>{await Qe(a),await Ze(a)}),he("client-id",async a=>{m.logInfo(`client-id config changed to: ${a}. Updating DNR rule.`),await Ke(a)}),chrome.runtime.onMessage.addListener((a,t,e)=>{if(m.logDebug("[Background] Received message:",a),a.type==="EXTRACT_SCID_FROM_M4A"){if(!a.payload||!a.payload.buffer||!a.payload.filename)return m.logError("[Background] Invalid payload for EXTRACT_SCID_FROM_M4A:",a.payload),e({error:"Invalid payload for SCID extraction."}),!0;const{filename:r,buffer:s}=a.payload;m.logInfo(`[Background] EXTRACT_SCID_FROM_M4A: Received buffer for ${r} (size: ${s.byteLength})`);try{const n=new Xe(s);if(n.parse(),!n.hasValidMp4Structure)return m.logWarn(`[Background] EXTRACT_SCID_FROM_M4A: File ${r} does not have a valid MP4 structure.`),e({error:`File ${r} is not a valid MP4.`}),!0;const i=["moov","udta","meta","ilst","scid"],o=n.findAndReadTextAtomData(i);o?(m.logInfo(`[Background] EXTRACT_SCID_FROM_M4A: Extracted SCID '${o}' from ${r}`),e({trackId:o})):(m.logWarn(`[Background] EXTRACT_SCID_FROM_M4A: SCID atom not found or no data in ${r}`),e({error:`SCID not found in ${r}`}))}catch(n){m.logError(`[Background] EXTRACT_SCID_FROM_M4A: Error parsing ${r}:`,n),e({error:`Error parsing MP4 file ${r}: ${n.message||n}`})}return!0}if(a.type==="RESTORE_HISTORY_FROM_IDS"){if(!a.payload||!Array.isArray(a.payload.trackIds))return m.logError("[Background] Invalid payload for RESTORE_HISTORY_FROM_IDS:",a.payload),e({error:"Invalid payload for history restoration."}),!0;const{trackIds:r}=a.payload;return m.logInfo(`[Background] RESTORE_HISTORY_FROM_IDS: Received ${r.length} track IDs to restore.`),r.length===0?(e({message:"No track IDs provided to restore."}),!0):((async()=>{try{const s=await S("track-download-history")||{};let n=0;r.forEach(i=>{if(typeof i=="string"&&i.trim()!==""){const o=`track-${i}`;s[o]?m.logDebug(`[Background] RESTORE_HISTORY_FROM_IDS: Track ${i} already in history, skipping.`):(s[o]={filename:`Restored: TrackID ${i}`,timestamp:Date.now()},n++)}}),await M("track-download-history",s),m.logInfo(`[Background] RESTORE_HISTORY_FROM_IDS: Successfully restored ${n} new tracks to history.`),e({message:`Successfully restored ${n} new tracks out of ${r.length} to download history.`})}catch(s){m.logError("[Background] RESTORE_HISTORY_FROM_IDS: Error accessing storage or processing IDs:",s),e({error:`Error restoring history: ${s.message||s}`})}})(),!0)}});
