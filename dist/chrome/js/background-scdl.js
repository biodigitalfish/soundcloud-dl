import{L as x,a as X}from"./logger-scdl-C1suKzoJ.js";import{s as ge,g as st,a as pe,i as ot,c as lt,d as gt,b as ct,o as dt,e as ut,f as ft,h as ht,j as mt,u as _e}from"./compatibilityStubs-scdl-DBF9jRnU.js";import{c as Fe,l as Oe,a as pt,g as v,s as L,X as Pe,b as Ne,d as Et,e as ce,f as Me,r as Ee}from"./config-scdl-CB4onbqr.js";class de extends Error{constructor(t){super(t),this.name="RateLimitError"}}class Le{baseUrl="https://api-v2.soundcloud.com";logger;globalBackoffUntil=null;globalBackoffDurationMs=61*1e3;constructor(){this.logger=x.create("SoundCloudApi")}async retryWithBackoff(t,e=3,r=2e3,i){if(this.globalBackoffUntil&&Date.now()<this.globalBackoffUntil){const d=this.globalBackoffUntil-Date.now();this.logger.logWarn(`[Global Backoff] Active. Waiting for ${Math.ceil(d/1e3)}s before proceeding with ${i||"operation"}.`),await new Promise(g=>setTimeout(g,d)),this.logger.logInfo(`[Global Backoff] Wait completed for ${i||"operation"}. Optimistically clearing global trigger.`),this.globalBackoffUntil=null}let n=0,s=r;for(;n<=e;)try{if(n>0&&this.globalBackoffUntil&&Date.now()<this.globalBackoffUntil){const g=this.globalBackoffUntil-Date.now();this.logger.logWarn(`[Global Backoff] Re-activated during retries. Waiting for ${Math.ceil(g/1e3)}s for ${i||"operation"}.`),await new Promise(f=>setTimeout(f,g)),this.logger.logInfo(`[Global Backoff] Secondary wait completed for ${i||"operation"}. Optimistically clearing global trigger.`),this.globalBackoffUntil=null}this.logger.logDebug(`[Retry] Attempt ${n+1}/${e+1} for ${i||"operation"}`);const d=await t();return this.globalBackoffUntil!==null&&(this.logger.logInfo(`[${i||"operation"}] Succeeded. Clearing active global backoff trigger.`),this.globalBackoffUntil=null),d}catch(d){if(d instanceof de)if(n<e)n++,this.logger.logWarn(`[Retry] Rate limit hit for ${i||"operation"}. Retrying in ${s/1e3}s... (Attempt ${n+1}/${e+1})`),await new Promise(g=>setTimeout(g,s)),s=Math.min(s*2,3e4);else throw this.logger.logError(`[Retry] Failed for ${i||"operation"} after ${n+1} attempts due to persistent rate limit. Activating global backoff.`),this.globalBackoffUntil=Date.now()+this.globalBackoffDurationMs,this.logger.logWarn(`[Global Backoff] Activated for ${this.globalBackoffDurationMs/1e3}s due to persistent rate limiting on ${i||"operation"}.`),d;else throw this.logger.logError(`[Retry] Failed for ${i||"operation"} with non-retryable or unexpected error after ${n+1} attempts:`,d.message||d),d}const o=`[Retry] Exhausted retries for ${i||"operation"} without explicit success or failure handling.`;throw this.logger.logError(o),new Error(o)}resolveUrl(t){const e=`${this.baseUrl}/resolve?url=${t}`;return this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`resolveUrl: ${t}`)}getCurrentUser(){const t=`${this.baseUrl}/me`;return this.retryWithBackoff(()=>this._fetchJsonInternal(t),3,2e3,"getCurrentUser")}async getFollowedArtistIds(t){const e=`${this.baseUrl}/users/${t}/followings/ids`,r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getFollowedArtistIds: ${t}`);return!r||!r.collection?null:r.collection}async getTracks(t){const e=`${this.baseUrl}/tracks?ids=${t.join(",")}`;this.logger.logInfo("Fetching tracks with Ids",{trackIds:t});const r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getTracks: ${t.length} IDs`);return t.reduce((i,n,s)=>(i[n]=r[s],i),{})}async getStreamDetails(t){const e=await this.retryWithBackoff(()=>this._fetchJsonInternal(t),3,2e3,`getStreamDetails: ${t}`);if(!e||!e.url)return this.logger.logError("Invalid stream response",e),null;let r,i=!1;const n=/(?:(\w{3,4})\/playlist)?\.(\w{3,4})(?:$|\?)/.exec(e.url);return n.length>=2&&(n[2]==="m3u8"?(r=n[1],i=!0):r=n[2]),{url:e.url,extension:r,hls:i}}async getOriginalDownloadUrl(t){const e=`${this.baseUrl}/tracks/${t}/download`;this.logger.logInfo("Getting original download URL for track with Id",t);try{const r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getOriginalDownloadUrl: ${t}`);return!r||!r.redirectUri?(this.logger.logError("Invalid original file response",r),null):r.redirectUri}catch(r){return this.logger.logError(`Failed to get original download URL for track ${t} after retries`,r),null}}async downloadArtwork(t){const[e]=await this.retryWithBackoff(()=>this._fetchArrayBufferInternal(t),3,2e3,`downloadArtwork: ${t}`);return e}downloadStream(t,e){return this.retryWithBackoff(()=>this._fetchArrayBufferInternal(t,e),3,1e3,`downloadStream: ${t}`)}async _fetchArrayBufferInternal(t,e){try{const r=await fetch(t);if(!r.ok){if(r.status===404)return this.logger.logDebug(`[fetchArrayBuffer] Resource not found (404) for ${t}`),[null,r.headers];if(r.status===429)throw this.logger.logWarn(`[fetchArrayBuffer] Rate limited (429) while fetching ${t}.`),new de(`Rate limited (status 429) on ${t}`);const E=`[fetchArrayBuffer] HTTP error for ${t} - Status: ${r.status} ${r.statusText}`;throw new Error(E)}if(!r.body)throw this.logger.logError(`Response for ${t} has no body, despite response.ok being true.`),new Error(`Response for ${t} has no body.`);const i=r.headers.get("Content-Length"),n=i?parseInt(i,10):0;let s=0;const o=[],d=r.body.getReader();for(e&&n>0&&e(0);;){const{done:E,value:y}=await d.read();if(E)break;o.push(y),s+=y.byteLength,e&&n>0&&e(Math.round(s/n*100))}e&&e(100);const g=new ArrayBuffer(s),f=new Uint8Array(g);let m=0;for(const E of o)f.set(E,m),m+=E.byteLength;return s===0&&r.status===200&&this.logger.logWarn(`[fetchArrayBuffer] Fetched ${t} (Status: ${r.status}) but received an empty (0 bytes) buffer.`),[g,r.headers]}catch(r){throw this.logger.logError(`[fetchArrayBuffer] Generic error for ${t}:`,r),r instanceof de?r:new Error(`Failed to fetch array buffer from ${t}: ${r instanceof Error?r.message:String(r)}`)}}async _fetchJsonInternal(t,e="GET",r){const i={Accept:"application/json"};e!=="GET"&&e!=="HEAD"&&(i["Content-Type"]="application/json");let n;try{this.logger.logDebug(`[API Fetch] Attempting ${e} to ${t}`),n=await fetch(t,{method:e,headers:i,body:r?JSON.stringify(r):void 0})}catch(s){throw this.logger.logError(`[API Fetch] Network error for ${e} ${t}: ${s.message}`,s),new Error(`Network error: ${s.message}`)}if(n.ok){const s=await n.text();if(!s&&(n.status===204||n.status===202))return this.logger.logDebug(`[API Fetch] Successful ${e} to ${t} with status ${n.status} (No Content).`),null;if(!s)return this.logger.logWarn(`[API Fetch] Successful ${e} to ${t} with status ${n.status} but received an empty response body.`),null;try{return JSON.parse(s)}catch(o){throw this.logger.logError(`[API Fetch] Successful ${e} to ${t} (status ${n.status}) but failed to parse JSON response: ${o.message}. Response text: "${s.substring(0,100)}"`),new Error(`JSON parsing error: ${o.message}`)}}else if(n.status===429){const s=`Rate limited (429) while fetching ${e} ${t}.`;throw this.logger.logWarn(s),new de(s)}else{const s=await n.text().catch(()=>`Failed to read error response body for status ${n.status}`),o=`HTTP error ${n.status} ${n.statusText} for ${e} ${t}. Response: ${s.substring(0,200)}`;throw this.logger.logError(o),new Error(o)}}}const H=8,se=16,Ce=H+se;class Ue{_metadataPath=["moov","udta","meta","ilst"];_buffer;_bufferView;_atoms=[];_loggedErrors=new Set;_hasValidStructure=!1;_logger;get hasValidMp4Structure(){return this._hasValidStructure}_logError(t){this._loggedErrors.has(t)||(this._logger.logDebug(`MP4 metadata: ${t}`),this._loggedErrors.add(t))}constructor(t){this._buffer=t,this._bufferView=new DataView(t),this._logger=x.create("MP4TagWriterInternals",X.Debug)}parse(){if(!this._buffer)throw new Error("Buffer can not be null");if(this._atoms.length>0)throw new Error("Buffer already parsed");this._logger.logDebug("Starting MP4 parse...");let t=0,e,r=[];for(;;){if(e=this._readAtom(t),!e||e.length<1||t>=this._buffer.byteLength){t<this._buffer.byteLength?this._logger.logDebug(`Parsing stopped: _readAtom returned invalid atom or zero length at offset ${t}.`):this._logger.logDebug(`Parsing stopped: Reached end of buffer at offset ${t}.`);break}if(r.push({name:e.name||"undefined",length:e.length,offset:e.offset}),this._atoms.push(e),t=e.offset+e.length,t<=e.offset){this._logger.logError(`Parsing stopped: Invalid offset progression. Current offset ${e.offset}, next offset calculated as ${t}.`);break}}if(this._logger.logDebug(`Finished MP4 parse. Found ${this._atoms.length} top-level atoms.`),this._logger.logDebug(`Top-level atoms summary: ${JSON.stringify(r)}`),this._atoms.length<1){this._logError("Buffer could not be parsed - no valid top-level atoms found."),this._hasValidStructure=!1;return}const i=this._atoms.find(n=>n.name?.toLowerCase()==="moov");this._hasValidStructure=!!i,this._hasValidStructure?this._logger.logDebug("File structure check passed: Found top-level 'moov' atom (case-insensitive check)."):this._logError("File structure check failed: Did not find a top-level 'moov' atom (checked case-insensitively).")}setDuration(t){try{if(!this._hasValidStructure){this._logError("Cannot set duration - file doesn't have a valid MP4 structure");return}const e=this._findAtom(this._atoms,["moov","mvhd"]);if(!e)throw new Error("'mvhd' atom could not be found");this._bufferView.setUint32(e.offset+H+16,t)}catch(e){this._logError(`Failed to set duration: ${e.message}`)}}addMetadataAtom(t,e){try{if(!this._hasValidStructure){this._logError(`Cannot add ${t} metadata - file doesn't have a valid MP4 structure`);return}if(t.length>4||t.length<1)throw new Error(`Unsupported atom name: '${t}'`);let r;if(e instanceof ArrayBuffer)r=e;else if(typeof e=="string")r=this._getBufferFromString(e);else if(typeof e=="number")r=new ArrayBuffer(4),new DataView(r).setUint32(0,e);else throw new Error(`Unsupported data: '${e}'`);const i={name:t,length:Ce+r.byteLength,data:r};this._insertAtom(i,this._metadataPath)}catch(r){this._logError(`Failed to add metadata atom '${t}': ${r.message}`)}}getBuffer(){const t=[];let e=0;for(const r of this._atoms){if(!r.children){const s=this._buffer.slice(r.offset,r.offset+r.length);t.push(s),e++;continue}r.length=H;const i=[{parent:r,offset:e,childIndex:0}];let n=0;for(;;){const{parent:s,offset:o,childIndex:d}=i[n];if(d>=s.children.length){n--,i.pop();let f=H;s.name==="meta"?(s.length+=4,f+=4):s.name==="stsd"&&(s.length+=8,f+=8),this._bufferView.setUint32(s.offset,s.length);const m=this._buffer.slice(s.offset,s.offset+f);if(t.splice(o,0,m),n<0)break;const E=i[n].parent;E.length+=s.length,i[n].childIndex++;continue}const g=s.children[d];if(g.children){g.length=H,i.push({parent:g,offset:e,childIndex:0}),n++;continue}else if(g.data){const f=this._getHeaderBufferFromAtom(g);t.push(f),t.push(g.data)}else{const f=this._buffer.slice(g.offset,g.offset+g.length);t.push(f)}e++,s.length+=g.length,i[n].childIndex++}}return this._bufferView=null,this._buffer=null,this._atoms=[],Fe(t)}_insertAtom(t,e){try{if(this._logger.logDebug(`Attempting to insert atom '${t.name}' at path '${e.join(" > ")}'.`),!e||e[e.length-1]!=="ilst"){this._logError(`Cannot insert tag atom '${t.name}': Path does not end in 'ilst'.`);return}const r=this._createMetadataPath();if(!r){this._logError(`Cannot insert atom '${t.name}': Failed to find or create parent 'ilst' atom.`);return}r.children===void 0&&(r.children=this._readChildAtoms(r),this._logger.logDebug(`Loaded children for '${r.name}' in _insertAtom.`));const i=r.children.findIndex(s=>s.name===t.name);i!==-1&&(this._logger.logDebug(`Replacing existing atom '${t.name}' in '${r.name}'.`),r.children.splice(i,1));let n=r.offset+this._getAtomHeaderLength(r);if(r.children.length>0){const s=r.children[r.children.length-1];n=s.offset+s.length}t.offset=n,r.children.push(t),this._logger.logDebug(`Successfully prepared atom '${t.name}' for insertion into '${r.name}'.`)}catch(r){this._logError(`Error during _insertAtom for '${t.name}': ${r.message}`)}}_findAtom(t,e){if(!e||e.length<1)throw new Error("Path can not be empty");const r=[...e],i=r.shift();this._logger.logDebug(`_findAtom: Searching for '${i}' in ${t.length} atoms. Remaining path: [${r.join(",")}]`);const n=t.find(s=>s.name===i);return n?(this._logger.logDebug(`_findAtom: Found '${n.name}' (length: ${n.length}, offset: ${n.offset})`),r.length<1?(this._logger.logDebug(`_findAtom: Path complete. Returning '${n.name}'.`),n.children===void 0&&(this._logger.logDebug(`_findAtom: Reading children for final element '${n.name}' before returning.`),n.children=this._readChildAtoms(n)),n):(n.children===void 0&&(this._logger.logDebug(`_findAtom: Reading children for '${n.name}' to continue traversal.`),n.children=this._readChildAtoms(n)),!n.children||n.children.length<1?(this._logger.logDebug(`_findAtom: '${n.name}' has no children to continue search for [${r.join(",")}]`),null):this._findAtom(n.children,r))):(this._logger.logDebug(`_findAtom: '${i}' not found.`),null)}_readChildAtoms(t){const e=[];this._logger.logDebug(`_readChildAtoms: Reading children for parent '${t.name}' (length: ${t.length}, offset: ${t.offset})`);const r=t.offset+t.length;let i=t.offset+H;t.name==="meta"?i+=4:t.name==="stsd"?i+=8:t.name==="ilst"?this._logger.logDebug(`_readChildAtoms: Parent is '${t.name}', standard child offset: ${i}`):t.name&&(t.name==="\xA9nam"||t.name==="\xA9ART"||t.name==="\xA9alb"||t.name==="\xA9day"||t.name==="trkn"||t.name==="scid"||t.name==="covr"||t.name==="\xA9too")&&this._logger.logDebug(`_readChildAtoms: Parent is item atom '${t.name}', standard child offset: ${i}`);let n=0;for(;;){if(i>=r){this._logger.logDebug(`_readChildAtoms: Reached end of parent '${t.name}' at offset ${i}. Found ${n} children.`);break}const s=this._readAtom(i);if(n++,this._logger.logDebug(`_readChildAtoms: For parent '${t.name}', read potential child ${n}: '${s.name||"?"}' (length: ${s.length}, offset: ${s.offset})`),!s||s.length<1){this._logger.logWarn(`_readChildAtoms: Invalid child atom or zero length for parent '${t.name}' at offset ${i}. Stopping child read.`);break}if(s.offset+s.length>r){this._logger.logWarn(`_readChildAtoms: Child atom '${s.name}' (offset ${s.offset}, length ${s.length}) exceeds parent '${t.name}' (ends at ${r}). Stopping.`);break}if(e.push(s),i=s.offset+s.length,i<=s.offset){this._logger.logError(`_readChildAtoms: Invalid offset progression for parent '${t.name}'. Child offset ${s.offset}, next offset ${i}. Stopping.`);break}}return this._logger.logDebug(`_readChildAtoms: Finished reading for parent '${t.name}'. Total children found: ${e.length}`),e}_readAtom(t){const e=t,r=t+H,i=this._buffer.slice(e,r);if(i.byteLength<H)return{length:i.byteLength,offset:t};const n=new DataView(i);let s=n.getUint32(0,!1),o="";for(let d=0;d<4;d++)o+=String.fromCharCode(n.getUint8(4+d));return{name:o,length:s,offset:t}}_getHeaderBufferFromAtom(t){if(!t||t.length<1||!t.name||!t.data)throw new Error("Can not compute header buffer for this atom");const e=new ArrayBuffer(Ce),r=new DataView(e);r.setUint32(0,t.length);const i=this._getCharCodes(t.name);for(let s=0;s<i.length;s++)r.setUint8(4+s,i[s]);r.setUint32(8,se+t.data.byteLength);const n=this._getCharCodes("data");for(let s=0;s<n.length;s++)r.setUint8(12+s,n[s]);return r.setUint32(16,this._getFlags(t.name)),e}_getBufferFromString(t){const e=new ArrayBuffer(t.length),r=new DataView(e),i=this._getCharCodes(t);for(let n=0;n<i.length;n++)r.setUint8(n,i[n]);return e}_getCharCodes(t){const e=[];for(let r=0;r<t.length;r++)e.push(t.charCodeAt(r));return e}_getFlags(t){switch(t){case"covr":return 13;case"trkn":case"disk":return 0;case"tmpo":case"cpil":case"rtng":return 21;default:return 1}}_createMetadataPath(){try{this._logger.logDebug("Attempting to ensure metadata path moov > udta > meta > ilst exists.");const t=this._findAtom(this._atoms,["moov"]);if(!t)return this._logError("Cannot create metadata path: Required 'moov' atom not found."),null;t.children===void 0&&(t.children=this._readChildAtoms(t));let e=t;const r=["udta","meta","ilst"];for(const i of r){let n=this._findAtom(e.children,[i]);if(n)this._logger.logDebug(`Found existing '${i}' atom.`),n.children===void 0&&(n.children=this._readChildAtoms(n));else{this._logger.logDebug(`Creating missing '${i}' atom.`);let s=e.offset+this._getAtomHeaderLength(e);if(e.children.length>0){const d=e.children[e.children.length-1];s=d.offset+d.length}const o=this._getAtomHeaderLength({name:i});n={name:i,length:o,offset:s,children:[]},e.children.push(n),this._logger.logDebug(`Created '${i}' atom.`)}e=n}return this._logger.logDebug("Metadata path creation/verification successful. Returning 'ilst' atom."),e}catch(t){return this._logError(`Failed during _createMetadataPath: ${t.message}`),null}}_getAtomHeaderLength(t){let e=H;return t.name==="meta"?e+=4:t.name==="stsd"&&(e+=8),e}findAndReadTextAtomData(t){try{const e=this._findAtom(this._atoms,t);if(e&&e.children&&e.children.length>0){const r=e.children.find(i=>i.name==="data");if(r){const i=r.offset+se,n=r.length-se;if(n>0&&this._buffer&&i+n<=this._buffer.byteLength){const s=this._buffer.slice(i,i+n);return new TextDecoder().decode(s)}else return this._logError(`Invalid data length or buffer bounds for atom at path ${t.join(" > ")}. Data atom length: ${r.length}, Header: ${se}`),null}else return this._logError(`No 'data' child atom found for atom at path ${t.join(" > ")}`),null}else this._logError(`Target atom not found or has no children at path ${t.join(" > ")}`);return null}catch(e){return this._logError(`Error finding or reading text atom at path ${t.join(" > ")}: ${e.message}`),null}}}class k{_originalBuffer;_mp4;_hasValidMp4=!1;static _loggedErrors=new Set;static _logger=x.create("MP4TagWriter",X.Debug);static _logError(t){k._loggedErrors.has(t)||(k._logger.logDebug(`MP4 metadata: ${t}`),k._loggedErrors.add(t))}constructor(t){try{this._originalBuffer=t.slice(0),k._logger.logDebug(`Creating Mp4TagWriter with buffer of size: ${this._originalBuffer.byteLength}`);try{this._mp4=new Ue(this._originalBuffer),this._mp4.parse(),this._hasValidMp4=this._mp4.hasValidMp4Structure,this._hasValidMp4?k._logger.logDebug("MP4 structure validation passed. TagWriter ready for use."):k._logError("MP4 structure validation failed. Tags will not be applied but original audio will still be saved.")}catch(e){this._hasValidMp4=!1,k._logError(`Failed to initialize MP4 parser: ${e.message}`)}}catch(e){k._logError(`Mp4TagWriter constructor error: ${e.message}`),this._originalBuffer=new ArrayBuffer(0),this._hasValidMp4=!1}}setTitle(t){try{if(!t)throw new Error("Invalid value for title");this._mp4.addMetadataAtom("\xA9nam",t)}catch(e){k._logError(`Failed to set title: ${e.message}`)}}setArtists(t){try{if(!t||t.length<1)throw new Error("Invalid value for artists");this._mp4.addMetadataAtom("\xA9ART",t.join(", "))}catch(e){k._logError(`Failed to set artists: ${e.message}`)}}setAlbum(t){try{if(!t)throw new Error("Invalid value for album");this._mp4.addMetadataAtom("\xA9alb",t)}catch(e){k._logError(`Failed to set album: ${e.message}`)}}setComment(t){try{if(!t)throw new Error("Invalid value for comment");this._mp4.addMetadataAtom("\xA9cmt",t)}catch(e){k._logError(`Failed to set comment: ${e.message}`)}}setTrackNumber(t){try{if(t<1||t>32767)throw new Error("Invalid value for trackNumber");this._mp4.addMetadataAtom("trkn",t)}catch(e){k._logError(`Failed to set track number: ${e.message}`)}}setYear(t){try{if(t<1)throw new Error("Invalid value for year");this._mp4.addMetadataAtom("\xA9day",t.toString())}catch(e){k._logError(`Failed to set year: ${e.message}`)}}setGrouping(t){try{if(!t)throw new Error("Invalid value for grouping");this._mp4.addMetadataAtom("\xA9grp",t)}catch(e){k._logError(`Failed to set grouping: ${e.message}`)}}setArtwork(t){try{if(!t||t.byteLength<1)throw new Error("Invalid value for artworkBuffer");this._mp4.addMetadataAtom("covr",t)}catch(e){k._logError(`Failed to set artwork: ${e.message}`)}}setSoundCloudTrackId(t){if(!this._hasValidMp4){k._logError("Cannot set SoundCloud Track ID - MP4 structure is invalid or not parsed.");return}if(!t){k._logError("Invalid value for SoundCloud Track ID");return}k._logger.logDebug(`[Mp4TagWriter] Attempting to set SoundCloudTrackID (scid): ${t}`),this._mp4.addMetadataAtom("scid",t)}setDuration(t){try{if(t<1)throw new Error("Invalid value for duration");this._mp4.setDuration(t)}catch(e){k._logError(`Failed to set duration: ${e.message}`)}}getBuffer(){try{if(!this._originalBuffer||this._originalBuffer.byteLength===0)throw new Error("Original buffer is missing or empty");if(!this._mp4||!this._hasValidMp4)return k._logError("MP4 structure check failed. Returning original buffer without applying tags."),Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:"Invalid MP4 structure for tagging."});let t;try{if(t=this._mp4.getBuffer(),!t||t.byteLength===0)throw new Error("Processed buffer is empty or null");t=t.slice(0)}catch(i){return k._logError(`Failed to get processed buffer: ${i.message}`),Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:`Failed to process MP4 buffer: ${i.message}`})}let e=!0,r;return t.byteLength!==this._originalBuffer.byteLength&&(e=!0,r=`Successfully applied tags (original: ${this._originalBuffer.byteLength}, new: ${t.byteLength})`),Promise.resolve({buffer:t,tagsApplied:e,message:r})}catch(t){const e=`Failed to get processed buffer: ${t.message}. Using original buffer as fallback.`;k._logError(e);try{return Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:e})}catch(r){return k._logError(`CRITICAL: Failed to create copy of original buffer: ${r.message}`),Promise.resolve({buffer:new ArrayBuffer(0),tagsApplied:!1,message:`CRITICAL ERROR: ${e} + ${r.message}`})}}}}const wt="DOWNLOAD_SET",bt="DOWNLOAD",yt="DOWNLOAD_SET_RANGE",Tt="PAUSE_DOWNLOAD",It="RESUME_DOWNLOAD",we="PAUSE_ALL_DOWNLOADS",be="RESUME_ALL_DOWNLOADS",ye="GET_GLOBAL_PAUSE_STATE",Te="GET_QUEUE_DATA",ue="GET_EXTENSION_CONFIG",xe={},T=x.create("MessageHandler",X.Debug);async function At(a,t){let e={};try{e=JSON.parse(JSON.stringify(a))}catch{e={errorParsingMessage:!0,rawMessage:String(a)}}T.logDebug("[MessageHandler DEBUG] Received message:",e);const r=[ue,Te,we,be,ye,"EXTRACT_SCID_FROM_M4A","RESTORE_HISTORY_FROM_IDS"];(!a||a.downloadId===void 0&&a.type!==void 0&&!r.includes(a.type))&&T.logError(`CRITICAL: MessageHandler received message with type ${a.type} that requires a downloadId, but it was missing!`,e);const i=t.tab?.id,{downloadId:n,url:s,type:o}=a,d=[ue,Te,we,be,ye];if(!i&&o&&!d.includes(o))return T.logWarn(`Message type ${o} received without a valid tab ID and is not allowed.`,{sender:t,message:a}),{error:`No valid tab ID found for message type ${o}`};if(o===ue){T.logDebug(`[MessageHandler] Received GET_EXTENSION_CONFIG request from tab ${i}`);try{const g=await Oe(!1),f={};for(const m of pt)g[m].secret||(f[m]={value:g[m].value});return T.logDebug("[MessageHandler] Sending non-secret configuration to content script:",f),Promise.resolve(f)}catch(g){return T.logError("[MessageHandler] Error loading or preparing configuration for content script:",g),Promise.reject({error:"Failed to retrieve extension configuration."})}}if(o&&!d.includes(o)&&!i)return T.logError(`CRITICAL: Message type ${o} requires a tabId, but it was missing after initial checks.`,{sender:t,message:a}),{error:`Missing tab ID for message type ${o}`};if(o===bt||o===wt||o===yt){if(!i)return T.logError(`CRITICAL: Download operation ${o} missing tabId.`),{error:"Download operations require a tabId."};T.logInfo(`[MessageHandler] Queuing request: ${o} for URL: ${s} with ID: ${n}`);const g={id:n,type:o,url:s,originalMessage:a,status:"pending",tabId:i,addedAt:Date.now()};P.push(g),await G(),T.logDebug(`[MessageHandler] Item added to queue and saved. Current queue size: ${P.length}`,g),z();const f={success:!0,message:`${o} request added to queue.`,originalDownloadId:n};return ge(i,f).then(()=>T.logInfo(`[MessageHandler TX Ack] Queued ACK for ${n} sent to tab ${i}.`)).catch(m=>T.logError(`[MessageHandler TX Ack] Queued ACK for ${n} FAILED to send to tab ${i}:`,m)),ie(),Promise.resolve(f)}else{if(o===we)return T.logInfo("[MessageHandler] Received PAUSE_ALL_DOWNLOADS request."),Object.keys(P).forEach(g=>{}),globalThis.isBackgroundGloballyPaused=!0,ie(),Promise.resolve({success:!0,message:"All downloads paused globally."});if(o===be)return T.logInfo("[MessageHandler] Received RESUME_ALL_DOWNLOADS request."),globalThis.isBackgroundGloballyPaused=!1,ie(),Promise.resolve({success:!0,message:"All downloads resumed globally."});if(o===ye){T.logInfo("[MessageHandler] Received GET_GLOBAL_PAUSE_STATE request.");const g=!!globalThis.isBackgroundGloballyPaused;return Promise.resolve({isGloballyPaused:g})}else if(o==="EXTRACT_SCID_FROM_M4A"){if(!a.payload||!a.payload.buffer||!a.payload.filename)return T.logError("[MessageHandler] Invalid payload for EXTRACT_SCID_FROM_M4A:",a.payload),Promise.reject({error:"Invalid payload for SCID extraction."});const{filename:g,buffer:f}=a.payload;T.logInfo(`[MessageHandler] EXTRACT_SCID_FROM_M4A: Received buffer for ${g} (size: ${f.byteLength})`);try{const m=new Ue(f);if(m.parse(),!m.hasValidMp4Structure)return T.logWarn(`[MessageHandler] EXTRACT_SCID_FROM_M4A: File ${g} does not have a valid MP4 structure.`),Promise.resolve({error:`File ${g} is not a valid MP4.`});const E=["moov","udta","meta","ilst","scid"],y=m.findAndReadTextAtomData(E);return y?(T.logInfo(`[MessageHandler] EXTRACT_SCID_FROM_M4A: Extracted SCID '${y}' from ${g}`),Promise.resolve({trackId:y})):(T.logWarn(`[MessageHandler] EXTRACT_SCID_FROM_M4A: SCID atom not found or no data in ${g}`),Promise.resolve({error:`SCID not found in ${g}`}))}catch(m){return T.logError(`[MessageHandler] EXTRACT_SCID_FROM_M4A: Error parsing ${g}:`,m),Promise.resolve({error:`Error parsing MP4 file ${g}: ${m.message||m}`})}}else if(o==="RESTORE_HISTORY_FROM_IDS"){if(!a.payload||!Array.isArray(a.payload.trackIds))return T.logError("[MessageHandler] Invalid payload for RESTORE_HISTORY_FROM_IDS:",a.payload),Promise.reject({error:"Invalid payload for history restoration."});const{trackIds:g}=a.payload;if(T.logInfo(`[MessageHandler] RESTORE_HISTORY_FROM_IDS: Received ${g.length} track IDs to restore.`),g.length===0)return Promise.resolve({message:"No track IDs provided to restore."});try{const f=await v("track-download-history")||{};let m=0;return g.forEach(E=>{if(typeof E=="string"&&E.trim()!==""){const y=`track-${E}`;f[y]?T.logDebug(`[MessageHandler] RESTORE_HISTORY_FROM_IDS: Track ${E} already in history, skipping.`):(f[y]={filename:`Restored: TrackID ${E}`,timestamp:Date.now()},m++)}}),await L("track-download-history",f),T.logInfo(`[MessageHandler] RESTORE_HISTORY_FROM_IDS: Successfully restored ${m} new tracks to history.`),Promise.resolve({message:`Successfully restored ${m} new tracks out of ${g.length} to download history.`})}catch(f){return T.logError("[MessageHandler] RESTORE_HISTORY_FROM_IDS: Error accessing storage or processing IDs:",f),Promise.resolve({error:`Error restoring history: ${f.message||f}`})}}else if(o===Tt){if(!i)return{error:"Pause ops require tabId"};const g=a;return T.logInfo(`Received pause request for download: ${g.downloadId}`),xe[g.downloadId]=!0,q(i,g.downloadId,void 0,void 0,"Paused"),{success:!0,action:"paused",downloadId:g.downloadId}}else if(o===It){if(!i)return{error:"Resume ops require tabId"};const g=a;T.logInfo(`Received resume request for download: ${g.downloadId}`),delete xe[g.downloadId];const f=P.find(m=>m.id===g.downloadId);return f&&f.status==="pending"?T.logInfo(`Resume for pending item ${f.id}. Will be picked by processor.`):f&&f.status==="processing"&&T.logInfo(`Resume for actively processing item ${f.id}. Processor will handle.`),ie(),q(i,g.downloadId,void 0,void 0,"Resuming"),{success:!0,action:"resumed",downloadId:g.downloadId}}else{if(o===Te)return T.logInfo("[MessageHandler] Received GET_QUEUE_DATA request (likely from popup)."),Promise.resolve(P);if(o!==ue)return T.logWarn(`[MessageHandler] Unknown message type received: ${o}`,a),Promise.reject({error:`Unknown message type: ${o}`})}}}var $;(function(a){a.LOAD="LOAD",a.EXEC="EXEC",a.FFPROBE="FFPROBE",a.WRITE_FILE="WRITE_FILE",a.READ_FILE="READ_FILE",a.DELETE_FILE="DELETE_FILE",a.RENAME="RENAME",a.CREATE_DIR="CREATE_DIR",a.LIST_DIR="LIST_DIR",a.DELETE_DIR="DELETE_DIR",a.ERROR="ERROR",a.DOWNLOAD="DOWNLOAD",a.PROGRESS="PROGRESS",a.LOG="LOG",a.MOUNT="MOUNT",a.UNMOUNT="UNMOUNT"})($||($={}));const $t=(()=>{let a=0;return()=>a++})(),Dt=new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),kt=new Error("called FFmpeg.terminate()");class Rt{#t=null;#a={};#r={};#i=[];#n=[];loaded=!1;#s=()=>{this.#t&&(this.#t.onmessage=({data:{id:t,type:e,data:r}})=>{switch(e){case $.LOAD:this.loaded=!0,this.#a[t](r);break;case $.MOUNT:case $.UNMOUNT:case $.EXEC:case $.FFPROBE:case $.WRITE_FILE:case $.READ_FILE:case $.DELETE_FILE:case $.RENAME:case $.CREATE_DIR:case $.LIST_DIR:case $.DELETE_DIR:this.#a[t](r);break;case $.LOG:this.#i.forEach(i=>i(r));break;case $.PROGRESS:this.#n.forEach(i=>i(r));break;case $.ERROR:this.#r[t](r);break}delete this.#a[t],delete this.#r[t]})};#e=({type:t,data:e},r=[],i)=>this.#t?new Promise((n,s)=>{const o=$t();this.#t&&this.#t.postMessage({id:o,type:t,data:e},r),this.#a[o]=n,this.#r[o]=s,i?.addEventListener("abort",()=>{s(new DOMException(`Message # ${o} was aborted`,"AbortError"))},{once:!0})}):Promise.reject(Dt);on(t,e){t==="log"?this.#i.push(e):t==="progress"&&this.#n.push(e)}off(t,e){t==="log"?this.#i=this.#i.filter(r=>r!==e):t==="progress"&&(this.#n=this.#n.filter(r=>r!==e))}load=({classWorkerURL:t,...e}={},{signal:r}={})=>(this.#t||(this.#t=t?new Worker(new URL(t,import.meta.url),{type:"module"}):new Worker(new URL("/assets/worker-BAOIWoxA.js",import.meta.url),{type:"module"}),this.#s()),this.#e({type:$.LOAD,data:e},void 0,r));exec=(t,e=-1,{signal:r}={})=>this.#e({type:$.EXEC,data:{args:t,timeout:e}},void 0,r);ffprobe=(t,e=-1,{signal:r}={})=>this.#e({type:$.FFPROBE,data:{args:t,timeout:e}},void 0,r);terminate=()=>{const t=Object.keys(this.#r);for(const e of t)this.#r[e](kt),delete this.#r[e],delete this.#a[e];this.#t&&(this.#t.terminate(),this.#t=null,this.loaded=!1)};writeFile=(t,e,{signal:r}={})=>{const i=[];return e instanceof Uint8Array&&i.push(e.buffer),this.#e({type:$.WRITE_FILE,data:{path:t,data:e}},i,r)};mount=(t,e,r)=>{const i=[];return this.#e({type:$.MOUNT,data:{fsType:t,options:e,mountPoint:r}},i)};unmount=t=>{const e=[];return this.#e({type:$.UNMOUNT,data:{mountPoint:t}},e)};readFile=(t,e="binary",{signal:r}={})=>this.#e({type:$.READ_FILE,data:{path:t,encoding:e}},void 0,r);deleteFile=(t,{signal:e}={})=>this.#e({type:$.DELETE_FILE,data:{path:t}},void 0,e);rename=(t,e,{signal:r}={})=>this.#e({type:$.RENAME,data:{oldPath:t,newPath:e}},void 0,r);createDir=(t,{signal:e}={})=>this.#e({type:$.CREATE_DIR,data:{path:t}},void 0,e);listDir=(t,{signal:e}={})=>this.#e({type:$.LIST_DIR,data:{path:t}},void 0,e);deleteDir=(t,{signal:e}={})=>this.#e({type:$.DELETE_DIR,data:{path:t}},void 0,e)}var Be;(function(a){a.MEMFS="MEMFS",a.NODEFS="NODEFS",a.NODERAWFS="NODERAWFS",a.IDBFS="IDBFS",a.WORKERFS="WORKERFS",a.PROXYFS="PROXYFS"})(Be||(Be={}));const St=new Error("failed to get response body reader"),vt=new Error("failed to complete download"),_t="Content-Length",Ft=async(a,t)=>{const e=await fetch(a);let r;try{const i=parseInt(e.headers.get(_t)||"-1"),n=e.body?.getReader();if(!n)throw St;const s=[];let o=0;for(;;){const{done:f,value:m}=await n.read(),E=m?m.length:0;if(f){if(i!=-1&&i!==o)throw vt;t&&t({url:a,total:i,received:o,delta:E,done:f});break}s.push(m),o+=E,t&&t({url:a,total:i,received:o,delta:E,done:f})}const d=new Uint8Array(o);let g=0;for(const f of s)d.set(f,g),g+=f.length;r=d.buffer}catch(i){console.log("failed to send download progress event: ",i),r=await e.arrayBuffer()}return r},Ie=async(a,t,e=!1,r)=>{const i=e?await Ft(a,r):await(await fetch(a)).arrayBuffer(),n=new Blob([i],{type:t});return URL.createObjectURL(n)},Ot=x.create("FFmpegInstance",X.Debug);async function Xe(a){const t=a?x.create(`FFmpegInstance:${a}`,X.Debug):Ot,e=new Rt;e.on("log",({message:r})=>{r.startsWith("frame=")||t.logDebug(`[FFMPEG_WASM_LOG] ${r}`)}),t.logInfo("[FFMPEG_WASM] Initializing new FFmpeg.wasm instance from local files (using toBlobURL strategy)...");try{const r=st("ffmpeg-core/");if(!r)return t.logError("[FFMPEG_WASM] Failed to get base URL for FFmpeg core files."),null;const i=r+"ffmpeg-core.js",n=r+"ffmpeg-core.wasm",s=r+"worker.js";t.logInfo(`[FFMPEG_WASM] Base URL for Blob: ${r}`),t.logInfo("[FFMPEG_WASM] Attempting to create Blob URLs for core files (including worker)...");const o=await Ie(i,"text/javascript"),d=await Ie(n,"application/wasm"),g=await Ie(s,"text/javascript");return t.logInfo("[FFMPEG_WASM] Blob URLs created. Loading FFmpeg instance with worker..."),await e.load({coreURL:o,wasmURL:d,workerURL:g}),t.logInfo("[FFMPEG_WASM] FFmpeg.wasm instance loaded successfully via Blob URLs (worker enabled)."),e}catch(r){return t.logError("[FFMPEG_WASM] Failed to load FFmpeg.wasm instance via Blob URLs",r),null}}const D=x.create("FFmpegManager",X.Debug),Pt=Math.max(1,Math.min(Number(v("maxConcurrentTrackDownloads"))||2,10)),fe=Pt;D.logInfo(`FFmpegManager initialized with MAX_CONCURRENT_OPERATIONS: ${fe}`);const W=[],he=[];let Q=!1,j=null;async function He(){return Q?Promise.resolve():j||(D.logInfo(`Initializing FFmpeg instance pool with size: ${fe}`),j=(async()=>{try{const a=[];for(let e=0;e<fe;e++)a.push(Xe(e));const t=await Promise.all(a);for(let e=0;e<t.length;e++){const r=t[e];r?W.push({id:e,instance:r,isAvailable:!0,isCompromised:!1}):D.logError(`Failed to load FFmpeg instance ${e} for the pool.`)}if(W.length===0&&fe>0)throw new Error("No FFmpeg instances could be initialized for the pool.");Q=!0,D.logInfo(`FFmpeg instance pool initialized with ${W.length} instances.`)}catch(a){throw D.logError("Failed to initialize FFmpeg pool",a),Q=!1,j=null,a}})(),j)}async function Nt(a,t){const{instance:e,id:r}=a,{taskId:i,inputBuffer:n,fileExtension:s,progressCallback:o,resolve:d,reject:g}=t,f=`input_${i}_${r}.${s||"mp4"}`,m=`output_remuxed_${i}_${r}.${s||"mp4"}`;D.logInfo(`[FFmpegManager] Instance ${r} starting remux for task ${i}: ${f} -> ${m}`);let E;try{let y;try{D.logDebug(`[FFmpegManager] Instance ${r}, Task ${i}: Attempting inputBuffer.slice(0). Input buffer byteLength: ${n?.byteLength}`);const R=n.slice(0);D.logDebug(`[FFmpegManager] Instance ${r}, Task ${i}: Successfully sliced buffer. Slice byteLength: ${R?.byteLength}. Attempting new Uint8Array().`),y=new Uint8Array(R),D.logDebug(`[FFmpegManager] Instance ${r}, Task ${i}: Created Uint8Array with byteLength: ${y?.byteLength}. About to call instance.writeFile with ${f}.`)}catch(R){throw D.logError(`[FFmpegManager] Instance ${r}, Task ${i}: ERROR during buffer slice or Uint8Array creation:`,R),R}await e.writeFile(f,y),D.logDebug(`[FFmpegManager] Instance ${r}, Task ${i}: Successfully called instance.writeFile with ${f}.`);const A=["-loglevel","debug","-i",f,"-c","copy",m];if(D.logDebug(`[FFmpegManager] Instance ${r}, Task ${i}: FFmpeg exec arguments:`,A),o){let R=-1;E=({progress:_})=>{const u=Math.round(_*100);u>R&&u<=100&&(o(u),R=u)},e.on("progress",E)}await e.exec(A);const l=await e.readFile(m);if(typeof l=="string")throw new Error("FFmpeg remux output was a string, expected Uint8Array");D.logInfo(`[FFmpegManager] Instance ${r} finished remux for task ${i}`),d(l.buffer.slice(0))}catch(y){D.logError(`[FFmpegManager] Instance ${r} FAILED remux for task ${i}`,y),a.isCompromised=!0,g(y)}finally{E&&typeof e.off=="function"&&e.off("progress",E);try{await e.deleteFile(f),await e.deleteFile(m)}catch(y){D.logWarn(`[FFmpegManager] Instance ${r} failed to cleanup files for task ${i}`,y),a.isCompromised=!0}}}function We(){if(!Q||he.length===0)return;const a=W.find(e=>e.isAvailable);if(!a){D.logDebug("No FFmpeg instance available right now, queue length: "+he.length);return}const t=he.shift();t&&(a.isAvailable=!1,D.logDebug(`Assigning task ${t.taskId} to FFmpeg instance ${a.id}`),Nt(a,t).finally(async()=>{if(a.isCompromised){D.logWarn(`[FFmpegManager] Instance ${a.id} is compromised. Terminating and attempting to replace.`);try{await a.instance.terminate(),D.logInfo(`[FFmpegManager] Terminated compromised instance ${a.id}.`)}catch(i){D.logError(`[FFmpegManager] Error terminating compromised instance ${a.id}:`,i)}const e=W.findIndex(i=>i.id===a.id);e>-1&&W.splice(e,1),D.logInfo(`[FFmpegManager] Attempting to create new FFmpeg instance to replace ${a.id}.`);const r=await Xe(a.id);r?(W.push({id:a.id,instance:r,isAvailable:!0,isCompromised:!1}),D.logInfo(`[FFmpegManager] Successfully replaced instance ${a.id}. Pool size: ${W.length}`)):D.logError(`[FFmpegManager] Failed to create new FFmpeg instance to replace ${a.id}. Pool size will be reduced.`)}else a.isAvailable=!0,D.logDebug(`FFmpeg instance ${a.id} is now available.`);We()}))}async function Mt(a,t,e,r){return!Q&&!j&&He().catch(i=>{D.logError("FFmpeg Pool Initialization failed lazily, subsequent requests might fail.",i)}),j&&await j,!Q||W.length===0?Promise.reject(new Error("FFmpegManager: Pool not initialized or no instances available after init attempt.")):new Promise((i,n)=>{D.logDebug(`Task ${a} added to FFmpeg remux queue.`),he.push({taskId:a,inputBuffer:t,fileExtension:e,progressCallback:r,resolve:i,reject:n}),We()})}function Lt(){!Q&&!j&&He().catch(a=>{D.logError("Pre-initialization of FFmpeg Pool failed.",a)})}function Ge(a){return String(a).split("").map(t=>t.charCodeAt(0))}function ee(a){return new Uint8Array(Ge(a))}function Y(a){const t=new ArrayBuffer(2*a.length),e=new Uint8Array(t);return new Uint16Array(t).set(Ge(a)),e}function qe(a){return[a>>>24&255,a>>>16&255,a>>>8&255,a&255]}function je(a){return 11+a}function Ct(a,t,e,r){return 11+t+1+1+(r?2+2*(e+1):e+1)+a}function Ut(a){let t=0;return a.forEach(e=>{t+=2+2*e[0].length+2+2+2*e[1].length+2}),11+t}function xt(a,t){const e=2*t;let r=0;return a.forEach(i=>{r+=2+2*i[0].length+2+4}),18+e+2+r}class Bt{_setIntegerFrame(t,e){const r=parseInt(e,10);this.frames.push({name:t,value:r,size:je(r.toString().length)})}_setStringFrame(t,e){const r=e.toString();let i=13+2*r.length;t==="TDAT"&&(i=je(r.length)),this.frames.push({name:t,value:r,size:i})}_setPictureFrame(t,e,r,i){const n=function(o){if(!o||!o.length)return null;if(o[0]===255&&o[1]===216&&o[2]===255)return"image/jpeg";if(o[0]===137&&o[1]===80&&o[2]===78&&o[3]===71)return"image/png";if(o[0]===71&&o[1]===73&&o[2]===70)return"image/gif";if(o[8]===87&&o[9]===69&&o[10]===66&&o[11]===80)return"image/webp";const d=o[0]===73&&o[1]===73&&o[2]===42&&o[3]===0,g=o[0]===77&&o[1]===77&&o[2]===0&&o[3]===42;return d||g?"image/tiff":o[0]===66&&o[1]===77?"image/bmp":o[0]===0&&o[1]===0&&o[2]===1&&o[3]===0?"image/x-icon":null}(new Uint8Array(e)),s=r.toString();if(!n)throw new Error("Unknown picture MIME type");r||(i=!1),this.frames.push({name:"APIC",value:e,pictureType:t,mimeType:n,useUnicodeEncoding:i,description:s,size:Ct(e.byteLength,n.length,s.length,i)})}_setLyricsFrame(t,e,r){const i=t.split("").map(g=>g.charCodeAt(0)),n=e.toString(),s=r.toString();var o,d;this.frames.push({name:"USLT",value:s,language:i,description:n,size:(o=n.length,d=s.length,16+2*o+2+2+2*d)})}_setCommentFrame(t,e,r){const i=t.split("").map(g=>g.charCodeAt(0)),n=e.toString(),s=r.toString();var o,d;this.frames.push({name:"COMM",value:s,language:i,description:n,size:(o=n.length,d=s.length,16+2*o+2+2+2*d)})}_setPrivateFrame(t,e){const r=t.toString();var i,n;this.frames.push({name:"PRIV",value:e,id:r,size:(i=r.length,n=e.byteLength,10+i+1+n)})}_setUserStringFrame(t,e){const r=t.toString(),i=e.toString();var n,s;this.frames.push({name:"TXXX",description:r,value:i,size:(n=r.length,s=i.length,13+2*n+2+2+2*s)})}_setUrlLinkFrame(t,e){const r=e.toString();var i;this.frames.push({name:t,value:r,size:(i=r.length,10+i)})}_setPairedTextFrame(t,e){this.frames.push({name:t,value:e,size:Ut(e)})}_setSynchronisedLyricsFrame(t,e,r,i,n){const s=n.toString(),o=i.split("").map(d=>d.charCodeAt(0));this.frames.push({name:"SYLT",value:e,language:o,description:s,type:t,timestampFormat:r,size:xt(e,s.length)})}constructor(t){if(!t||typeof t!="object"||!("byteLength"in t))throw new Error("First argument should be an instance of ArrayBuffer or Buffer");this.arrayBuffer=t,this.padding=4096,this.frames=[],this.url=""}setFrame(t,e){switch(t){case"TPE1":case"TCOM":case"TCON":{if(!Array.isArray(e))throw new Error(`${t} frame value should be an array of strings`);const r=t==="TCON"?";":"/",i=e.join(r);this._setStringFrame(t,i);break}case"TLAN":case"TIT1":case"TIT2":case"TIT3":case"TALB":case"TPE2":case"TPE3":case"TPE4":case"TRCK":case"TPOS":case"TMED":case"TPUB":case"TCOP":case"TKEY":case"TEXT":case"TDAT":case"TCMP":case"TSRC":this._setStringFrame(t,e);break;case"TBPM":case"TLEN":case"TYER":this._setIntegerFrame(t,e);break;case"USLT":if(e.language=e.language||"eng",typeof e!="object"||!("description"in e)||!("lyrics"in e))throw new Error("USLT frame value should be an object with keys description and lyrics");if(e.language&&!e.language.match(/[a-z]{3}/i))throw new Error("Language must be coded following the ISO 639-2 standards");this._setLyricsFrame(e.language,e.description,e.lyrics);break;case"APIC":if(typeof e!="object"||!("type"in e)||!("data"in e)||!("description"in e))throw new Error("APIC frame value should be an object with keys type, data and description");if(e.type<0||e.type>20)throw new Error("Incorrect APIC frame picture type");this._setPictureFrame(e.type,e.data,e.description,!!e.useUnicodeEncoding);break;case"TXXX":if(typeof e!="object"||!("description"in e)||!("value"in e))throw new Error("TXXX frame value should be an object with keys description and value");this._setUserStringFrame(e.description,e.value);break;case"WCOM":case"WCOP":case"WOAF":case"WOAR":case"WOAS":case"WORS":case"WPAY":case"WPUB":this._setUrlLinkFrame(t,e);break;case"COMM":if(e.language=e.language||"eng",typeof e!="object"||!("description"in e)||!("text"in e))throw new Error("COMM frame value should be an object with keys description and text");if(e.language&&!e.language.match(/[a-z]{3}/i))throw new Error("Language must be coded following the ISO 639-2 standards");this._setCommentFrame(e.language,e.description,e.text);break;case"PRIV":if(typeof e!="object"||!("id"in e)||!("data"in e))throw new Error("PRIV frame value should be an object with keys id and data");this._setPrivateFrame(e.id,e.data);break;case"IPLS":if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Error("IPLS frame value should be an array of pairs");this._setPairedTextFrame(t,e);break;case"SYLT":if(typeof e!="object"||!("type"in e)||!("text"in e)||!("timestampFormat"in e))throw new Error("SYLT frame value should be an object with keys type, text and timestampFormat");if(!Array.isArray(e.text)||!Array.isArray(e.text[0]))throw new Error("SYLT frame text value should be an array of pairs");if(e.type<0||e.type>6)throw new Error("Incorrect SYLT frame content type");if(e.timestampFormat<1||e.timestampFormat>2)throw new Error("Incorrect SYLT frame time stamp format");e.language=e.language||"eng",e.description=e.description||"",this._setSynchronisedLyricsFrame(e.type,e.text,e.timestampFormat,e.language,e.description);break;default:throw new Error(`Unsupported frame ${t}`)}return this}removeTag(){if(this.arrayBuffer.byteLength<10)return;const t=new Uint8Array(this.arrayBuffer),e=t[3],r=((i=[t[6],t[7],t[8],t[9]])[0]<<21)+(i[1]<<14)+(i[2]<<7)+i[3]+10;var i,n;(n=t)[0]!==73||n[1]!==68||n[2]!==51||e<2||e>4||(this.arrayBuffer=new Uint8Array(t.subarray(r)).buffer)}addTag(){this.removeTag();const t=[255,254],e=10+this.frames.reduce((o,d)=>o+d.size,0)+this.padding,r=new ArrayBuffer(this.arrayBuffer.byteLength+e),i=new Uint8Array(r);let n=0,s=[];return s=[73,68,51,3],i.set(s,n),n+=s.length,n++,n++,s=function(o){return[o>>>21&127,o>>>14&127,o>>>7&127,o&127]}(e-10),i.set(s,n),n+=s.length,this.frames.forEach(o=>{switch(s=ee(o.name),i.set(s,n),n+=s.length,s=qe(o.size-10),i.set(s,n),n+=s.length,n+=2,o.name){case"WCOM":case"WCOP":case"WOAF":case"WOAR":case"WOAS":case"WORS":case"WPAY":case"WPUB":s=ee(o.value),i.set(s,n),n+=s.length;break;case"TPE1":case"TCOM":case"TCON":case"TLAN":case"TIT1":case"TIT2":case"TIT3":case"TALB":case"TPE2":case"TPE3":case"TPE4":case"TRCK":case"TPOS":case"TKEY":case"TMED":case"TPUB":case"TCOP":case"TEXT":case"TSRC":s=[1].concat(t),i.set(s,n),n+=s.length,s=Y(o.value),i.set(s,n),n+=s.length;break;case"TXXX":case"USLT":case"COMM":s=[1],o.name!=="USLT"&&o.name!=="COMM"||(s=s.concat(o.language)),s=s.concat(t),i.set(s,n),n+=s.length,s=Y(o.description),i.set(s,n),n+=s.length,s=[0,0].concat(t),i.set(s,n),n+=s.length,s=Y(o.value),i.set(s,n),n+=s.length;break;case"TBPM":case"TLEN":case"TDAT":case"TYER":n++,s=ee(o.value),i.set(s,n),n+=s.length;break;case"PRIV":s=ee(o.id),i.set(s,n),n+=s.length,n++,i.set(new Uint8Array(o.value),n),n+=o.value.byteLength;break;case"APIC":s=[o.useUnicodeEncoding?1:0],i.set(s,n),n+=s.length,s=ee(o.mimeType),i.set(s,n),n+=s.length,s=[0,o.pictureType],i.set(s,n),n+=s.length,o.useUnicodeEncoding?(s=[].concat(t),i.set(s,n),n+=s.length,s=Y(o.description),i.set(s,n),n+=s.length,n+=2):(s=ee(o.description),i.set(s,n),n+=s.length,n++),i.set(new Uint8Array(o.value),n),n+=o.value.byteLength;break;case"IPLS":s=[1],i.set(s,n),n+=s.length,o.value.forEach(d=>{s=[].concat(t),i.set(s,n),n+=s.length,s=Y(d[0].toString()),i.set(s,n),n+=s.length,s=[0,0].concat(t),i.set(s,n),n+=s.length,s=Y(d[1].toString()),i.set(s,n),n+=s.length,s=[0,0],i.set(s,n),n+=s.length});break;case"SYLT":s=[1].concat(o.language).concat(o.timestampFormat).concat(o.type),i.set(s,n),n+=s.length,s=[].concat(t),i.set(s,n),n+=s.length,s=Y(o.description),i.set(s,n),n+=s.length,n+=2,o.value.forEach(d=>{s=[].concat(t),i.set(s,n),n+=s.length,s=Y(d[0].toString()),i.set(s,n),n+=s.length,s=[0,0],i.set(s,n),n+=s.length,s=qe(d[1]),i.set(s,n),n+=s.length})}}),n+=this.padding,i.set(new Uint8Array(this.arrayBuffer),n),this.arrayBuffer=r,r}getBlob(){return new Blob([this.arrayBuffer],{type:"audio/mpeg"})}getURL(){return this.url||(this.url=URL.createObjectURL(this.getBlob())),this.url}revokeURL(){URL.revokeObjectURL(this.url)}}const Xt=x.create("Mp3TagWriter");class Ht{writer;constructor(t){this.writer=new Bt(t)}setTitle(t){if(!t)throw new Error("Invalid value for title");this.writer.setFrame("TIT2",t)}setArtists(t){if(!t||t.length<1)throw new Error("Invalid value for artists");this.writer.setFrame("TPE1",t)}setAlbum(t){if(!t)throw new Error("Invalid value for album");this.writer.setFrame("TALB",t)}setComment(t){if(!t)throw new Error("Invalid value for comment");this.writer.setFrame("COMM",{text:t,description:""})}setTrackNumber(t){if(t<1||t>32767)throw new Error("Invalid value for trackNumber");this.writer.setFrame("TRCK",t.toString())}setYear(t){if(t<1)throw new Error("Invalud value for year");this.writer.setFrame("TYER",t)}setGrouping(t){if(!t)throw new Error("Invalid value for grouping");this.writer.setFrame("TIT1",t)}setArtwork(t){if(!t||t.byteLength<1)throw new Error("Invalid value for artworkBuffer");this.writer.setFrame("APIC",{type:3,data:t,description:""})}setSoundCloudTrackId(t){if(!t)throw new Error("Invalid value for SoundCloud Track ID");Xt.logDebug(`Attempting to set SoundCloudTrackID: ${t}`),this.writer.setFrame("TXXX",{description:"SoundCloudTrackID",value:t})}getBuffer(){return this.writer.addTag(),this.writer.getBlob().arrayBuffer().then(t=>({buffer:t,tagsApplied:!0}))}}function Wt(a){if(typeof a!="string")throw new TypeError("Expected a string");return a.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}var Ae=(a=>(a[a.Main=0]="Main",a[a.Feature=1]="Feature",a[a.Remixer=2]="Remixer",a[a.Producer=3]="Producer",a))(Ae||{}),$e=(a=>(a[a.Remix=0]="Remix",a[a.Flip=1]="Flip",a[a.Bootleg=2]="Bootleg",a[a.Mashup=3]="Mashup",a[a.Edit=4]="Edit",a))($e||{});function Gt(a){switch(a.toLowerCase().trim()){case"flip":return 1;case"bootleg":return 2;case"mashup":return 3;case"edit":return 4;case"remix":default:return 0}}function qt(a,t){return a.map((e,r)=>({data:e,index:r})).sort((e,r)=>e.data[t]<r.data[t]?-1:e.data[t]>r.data[t]?1:e.index-r.index).map(e=>e.data)}class C{constructor(t,e,r){this.title=t,this.username=e,this.userPermalink=r}static titleSeparators=["-","\u2013","\u2014","~"];static featureSeparators=["featuring","feat.","feat","ft."," ft ","w/"," w /"," w ","+"];static combiningFeatureSeparators=[...C.featureSeparators,", "," & "," x "];static remixIndicators=["remix","flip","bootleg","mashup","edit"];static producerIndicators=["prod. by ","prod by ","prod. ","p. ","prod "];static promotions=["free download","video in description","video in desc","vid in desc","Original Mix"];getArtists(){const t=this.preprocessTitle(this.title);let e=[];const r=this.splitByTitleSeparators(t,!0);e=e.concat(r.artistNames.map((g,f)=>({name:g,type:f===0?0:1})));const i=this.splitByProducer(r.title,!0);e=e.concat(i.artistNames.map(g=>({name:g,type:3})));const n=this.splitByRemix(i.title,!0);e=e.concat(n.artists);const s=this.splitByUnsafeProducers(n.title,!0);e=e.concat(s.artistNames.map(g=>({name:g,type:3})));const o=this.splitByFeatures(n.title,!0);if(e=e.concat(o.artistNames.map(g=>({name:g,type:1}))),!e.some(g=>g.type===0)){const g={name:this.sanitizeArtistName(this.username)||this.userPermalink,type:0};g.name&&(e.length>0?e=[g,...e]:e.push(g))}e=e.map(g=>this.removeTwitterHandle(g));const d=[];for(const g of e)d.some(f=>f.name==g.name)||d.push(g);return qt(d,"type")}getTitle(){let t=this.preprocessTitle(this.title);return t=this.splitByTitleSeparators(t,!1).title,t=this.splitByProducer(t,!1).title,t=this.splitByRemix(t,!1).title,t=this.splitByFeatures(t,!1).title,t=this.splitByUnsafeProducers(t,!1).title,this.sanitizeTitle(t)}removeTwitterHandle(t){t.name=t.name.replace(/^[@]+/,"");const e=/^([^(]+)\s?\(\s?@.+\)?$/.exec(t.name);return e&&e.length>1&&(t.name=e[1].trimEnd()),t}splitByTitleSeparators(t,e){let r=[];if(this.includes(t,C.titleSeparators)){const i=this.escapeRegexArray(C.titleSeparators),n=new RegExp(`^((.+)\\s[${i}]\\s)(.+)$`).exec(t);if(n&&n.length>0){const[s,o,d]=n;e&&(r=this.getArtistNames(d)),t=t.replace(o,"")}}return{artistNames:r,title:t}}splitByFeatures(t,e){let r=[];if(this.includes(t,C.featureSeparators)){const i=this.escapeRegexArray(C.featureSeparators).join("|"),n=new RegExp(`(?:${i})([^\\[\\]\\(\\)]+)`,"i").exec(t);if(n&&n.length>0){const[s,o]=n;e&&(r=this.getArtistNames(o)),t=t.replace(s,"")}}return{artistNames:r,title:t}}splitByProducer(t,e){let r=[];if(this.includes(t,C.producerIndicators)){const i=this.escapeRegexArray(C.producerIndicators).join("|"),n=new RegExp(`(?:${i})([^\\[\\]\\(\\)]+)`,"i").exec(t);if(n&&n.length>0){const[s,o]=n;e&&(r=this.getArtistNames(o)),t=t.replace(s,"")}}return{artistNames:r,title:t}}splitByUnsafeProducers(t,e){let r=[];const i=this.escapeRegexArray(C.featureSeparators).join("|"),n=new RegExp(`[\\(\\[](?!${i})(.+)[\\)\\]]`,"i").exec(t);if(n&&n.length>0){const[s,o]=n;e&&(r=this.getArtistNames(o)),t=t.replace(s,"")}return{artistNames:r,title:t}}splitByRemix(t,e){let r=[];if(this.includes(t,C.remixIndicators)){const i=this.escapeRegexArray(C.remixIndicators).join("|"),n=new RegExp(`[\\[\\(](.+)(${i})[\\]\\)]`,"i").exec(t);if(n&&n.length>0){const[s,o,d]=n;if(e){const g=this.getArtistNames(o),f=Gt(d);r=g.map(m=>({name:m,type:2,remixType:f}))}t=t.replace(s,"")}}return{artists:r,title:t}}getArtistNames(t){const e=this.escapeRegexArray(C.combiningFeatureSeparators).join("|"),r=new RegExp(`(.+)\\s?(${e})\\s?(.+)`,"i"),i=[];for(;;){const n=r.exec(t);if(!n){i.push(this.sanitizeArtistName(t));break}i.push(this.sanitizeArtistName(n[3])),t=n[1]}return i.reverse()}preprocessTitle(t){t=t.replace(/\+([+]+)/g,"+");const e=C.promotions.join("|"),r=new RegExp(`[\\[\\(]?\\s*(${e})\\s*[\\]\\)]?`,"i");return t.replace(r,"")}sanitizeArtistName(t){return this.removeNonAsciiCharacters(t).trim()}sanitizeTitle(t){let e=this.removeNonAsciiCharacters(t);return e=e.replace("()","").replace("[]",""),e.trim()}removeNonAsciiCharacters(t){return Pe.replace(t,Pe("[^\\p{L}\\p{N}\\p{Zs}\0-\x7F]","g"),"")}includes(t,e){const r=t.toLowerCase();return e.some(i=>r.includes(i))}escapeRegexArray(t){return t.map(e=>Wt(e))}}var De=function(){function a(){this.listeners={}}var t=a.prototype;return t.on=function(e,r){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(r)},t.off=function(e,r){if(!this.listeners[e])return!1;var i=this.listeners[e].indexOf(r);return this.listeners[e]=this.listeners[e].slice(0),this.listeners[e].splice(i,1),i>-1},t.trigger=function(e){var r=this.listeners[e];if(r)if(arguments.length===2)for(var i=r.length,n=0;n<i;++n)r[n].call(this,arguments[1]);else for(var s=Array.prototype.slice.call(arguments,1),o=r.length,d=0;d<o;++d)r[d].apply(this,s)},t.dispose=function(){this.listeners={}},t.pipe=function(e){this.on("data",function(r){e.push(r)})},a}();function te(){return te=Object.assign?Object.assign.bind():function(a){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var r in e)({}).hasOwnProperty.call(e,r)&&(a[r]=e[r])}return a},te.apply(null,arguments)}var ke,Ye;function jt(){if(Ye)return ke;Ye=1;var a;return typeof window<"u"?a=window:typeof Ne<"u"?a=Ne:typeof self<"u"?a=self:a={},ke=a,ke}var Yt=jt();const Ve=Et(Yt);var Vt=function(a){return Ve.atob?Ve.atob(a):Buffer.from(a,"base64").toString("binary")};function Qt(a){for(var t=Vt(a),e=new Uint8Array(t.length),r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */class zt extends De{constructor(){super(),this.buffer=""}push(t){let e;for(this.buffer+=t,e=this.buffer.indexOf(`
`);e>-1;e=this.buffer.indexOf(`
`))this.trigger("data",this.buffer.substring(0,e)),this.buffer=this.buffer.substring(e+1)}}const Kt="	",Re=function(a){const t=/([0-9.]*)?@?([0-9.]*)?/.exec(a||""),e={};return t[1]&&(e.length=parseInt(t[1],10)),t[2]&&(e.offset=parseInt(t[2],10)),e},Jt=function(){const a='(?:[^=]*)=(?:"[^"]*"|[^,]*)';return new RegExp("(?:^|,)("+a+")")},M=function(a){const t={};if(!a)return t;const e=a.split(Jt());let r=e.length,i;for(;r--;)e[r]!==""&&(i=/([^=]*)=(.*)/.exec(e[r]).slice(1),i[0]=i[0].replace(/^\s+|\s+$/g,""),i[1]=i[1].replace(/^\s+|\s+$/g,""),i[1]=i[1].replace(/^['"](.*)['"]$/g,"$1"),t[i[0]]=i[1]);return t},Qe=a=>{const t=a.split("x"),e={};return t[0]&&(e.width=parseInt(t[0],10)),t[1]&&(e.height=parseInt(t[1],10)),e};class Zt extends De{constructor(){super(),this.customParsers=[],this.tagMappers=[]}push(t){let e,r;if(t=t.trim(),t.length!==0){if(t[0]!=="#"){this.trigger("data",{type:"uri",uri:t});return}this.tagMappers.reduce((i,n)=>{const s=n(t);return s===t?i:i.concat([s])},[t]).forEach(i=>{for(let n=0;n<this.customParsers.length;n++)if(this.customParsers[n].call(this,i))return;if(i.indexOf("#EXT")!==0){this.trigger("data",{type:"comment",text:i.slice(1)});return}if(i=i.replace("\r",""),e=/^#EXTM3U/.exec(i),e){this.trigger("data",{type:"tag",tagType:"m3u"});return}if(e=/^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(i),e){r={type:"tag",tagType:"inf"},e[1]&&(r.duration=parseFloat(e[1])),e[2]&&(r.title=e[2]),this.trigger("data",r);return}if(e=/^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(i),e){r={type:"tag",tagType:"targetduration"},e[1]&&(r.duration=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-VERSION:([0-9.]*)?/.exec(i),e){r={type:"tag",tagType:"version"},e[1]&&(r.version=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(i),e){r={type:"tag",tagType:"media-sequence"},e[1]&&(r.number=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(i),e){r={type:"tag",tagType:"discontinuity-sequence"},e[1]&&(r.number=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(i),e){r={type:"tag",tagType:"playlist-type"},e[1]&&(r.playlistType=e[1]),this.trigger("data",r);return}if(e=/^#EXT-X-BYTERANGE:(.*)?$/.exec(i),e){r=te(Re(e[1]),{type:"tag",tagType:"byterange"}),this.trigger("data",r);return}if(e=/^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(i),e){r={type:"tag",tagType:"allow-cache"},e[1]&&(r.allowed=!/NO/.test(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-MAP:(.*)$/.exec(i),e){if(r={type:"tag",tagType:"map"},e[1]){const n=M(e[1]);n.URI&&(r.uri=n.URI),n.BYTERANGE&&(r.byterange=Re(n.BYTERANGE))}this.trigger("data",r);return}if(e=/^#EXT-X-STREAM-INF:(.*)$/.exec(i),e){r={type:"tag",tagType:"stream-inf"},e[1]&&(r.attributes=M(e[1]),r.attributes.RESOLUTION&&(r.attributes.RESOLUTION=Qe(r.attributes.RESOLUTION)),r.attributes.BANDWIDTH&&(r.attributes.BANDWIDTH=parseInt(r.attributes.BANDWIDTH,10)),r.attributes["FRAME-RATE"]&&(r.attributes["FRAME-RATE"]=parseFloat(r.attributes["FRAME-RATE"])),r.attributes["PROGRAM-ID"]&&(r.attributes["PROGRAM-ID"]=parseInt(r.attributes["PROGRAM-ID"],10))),this.trigger("data",r);return}if(e=/^#EXT-X-MEDIA:(.*)$/.exec(i),e){r={type:"tag",tagType:"media"},e[1]&&(r.attributes=M(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-ENDLIST/.exec(i),e){this.trigger("data",{type:"tag",tagType:"endlist"});return}if(e=/^#EXT-X-DISCONTINUITY/.exec(i),e){this.trigger("data",{type:"tag",tagType:"discontinuity"});return}if(e=/^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(i),e){r={type:"tag",tagType:"program-date-time"},e[1]&&(r.dateTimeString=e[1],r.dateTimeObject=new Date(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-KEY:(.*)$/.exec(i),e){r={type:"tag",tagType:"key"},e[1]&&(r.attributes=M(e[1]),r.attributes.IV&&(r.attributes.IV.substring(0,2).toLowerCase()==="0x"&&(r.attributes.IV=r.attributes.IV.substring(2)),r.attributes.IV=r.attributes.IV.match(/.{8}/g),r.attributes.IV[0]=parseInt(r.attributes.IV[0],16),r.attributes.IV[1]=parseInt(r.attributes.IV[1],16),r.attributes.IV[2]=parseInt(r.attributes.IV[2],16),r.attributes.IV[3]=parseInt(r.attributes.IV[3],16),r.attributes.IV=new Uint32Array(r.attributes.IV))),this.trigger("data",r);return}if(e=/^#EXT-X-START:(.*)$/.exec(i),e){r={type:"tag",tagType:"start"},e[1]&&(r.attributes=M(e[1]),r.attributes["TIME-OFFSET"]=parseFloat(r.attributes["TIME-OFFSET"]),r.attributes.PRECISE=/YES/.test(r.attributes.PRECISE)),this.trigger("data",r);return}if(e=/^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(i),e){r={type:"tag",tagType:"cue-out-cont"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-CUE-OUT:(.*)?$/.exec(i),e){r={type:"tag",tagType:"cue-out"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-CUE-IN:?(.*)?$/.exec(i),e){r={type:"tag",tagType:"cue-in"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-SKIP:(.*)$/.exec(i),e&&e[1]){r={type:"tag",tagType:"skip"},r.attributes=M(e[1]),r.attributes.hasOwnProperty("SKIPPED-SEGMENTS")&&(r.attributes["SKIPPED-SEGMENTS"]=parseInt(r.attributes["SKIPPED-SEGMENTS"],10)),r.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")&&(r.attributes["RECENTLY-REMOVED-DATERANGES"]=r.attributes["RECENTLY-REMOVED-DATERANGES"].split(Kt)),this.trigger("data",r);return}if(e=/^#EXT-X-PART:(.*)$/.exec(i),e&&e[1]){r={type:"tag",tagType:"part"},r.attributes=M(e[1]),["DURATION"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),["INDEPENDENT","GAP"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=/YES/.test(r.attributes[n]))}),r.attributes.hasOwnProperty("BYTERANGE")&&(r.attributes.byterange=Re(r.attributes.BYTERANGE)),this.trigger("data",r);return}if(e=/^#EXT-X-SERVER-CONTROL:(.*)$/.exec(i),e&&e[1]){r={type:"tag",tagType:"server-control"},r.attributes=M(e[1]),["CAN-SKIP-UNTIL","PART-HOLD-BACK","HOLD-BACK"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),["CAN-SKIP-DATERANGES","CAN-BLOCK-RELOAD"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=/YES/.test(r.attributes[n]))}),this.trigger("data",r);return}if(e=/^#EXT-X-PART-INF:(.*)$/.exec(i),e&&e[1]){r={type:"tag",tagType:"part-inf"},r.attributes=M(e[1]),["PART-TARGET"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),this.trigger("data",r);return}if(e=/^#EXT-X-PRELOAD-HINT:(.*)$/.exec(i),e&&e[1]){r={type:"tag",tagType:"preload-hint"},r.attributes=M(e[1]),["BYTERANGE-START","BYTERANGE-LENGTH"].forEach(function(n){if(r.attributes.hasOwnProperty(n)){r.attributes[n]=parseInt(r.attributes[n],10);const s=n==="BYTERANGE-LENGTH"?"length":"offset";r.attributes.byterange=r.attributes.byterange||{},r.attributes.byterange[s]=r.attributes[n],delete r.attributes[n]}}),this.trigger("data",r);return}if(e=/^#EXT-X-RENDITION-REPORT:(.*)$/.exec(i),e&&e[1]){r={type:"tag",tagType:"rendition-report"},r.attributes=M(e[1]),["LAST-MSN","LAST-PART"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseInt(r.attributes[n],10))}),this.trigger("data",r);return}if(e=/^#EXT-X-DATERANGE:(.*)$/.exec(i),e&&e[1]){r={type:"tag",tagType:"daterange"},r.attributes=M(e[1]),["ID","CLASS"].forEach(function(s){r.attributes.hasOwnProperty(s)&&(r.attributes[s]=String(r.attributes[s]))}),["START-DATE","END-DATE"].forEach(function(s){r.attributes.hasOwnProperty(s)&&(r.attributes[s]=new Date(r.attributes[s]))}),["DURATION","PLANNED-DURATION"].forEach(function(s){r.attributes.hasOwnProperty(s)&&(r.attributes[s]=parseFloat(r.attributes[s]))}),["END-ON-NEXT"].forEach(function(s){r.attributes.hasOwnProperty(s)&&(r.attributes[s]=/YES/i.test(r.attributes[s]))}),["SCTE35-CMD"," SCTE35-OUT","SCTE35-IN"].forEach(function(s){r.attributes.hasOwnProperty(s)&&(r.attributes[s]=r.attributes[s].toString(16))});const n=/^X-([A-Z]+-)+[A-Z]+$/;for(const s in r.attributes){if(!n.test(s))continue;const o=/[0-9A-Fa-f]{6}/g.test(r.attributes[s]),d=/^\d+(\.\d+)?$/.test(r.attributes[s]);r.attributes[s]=o?r.attributes[s].toString(16):d?parseFloat(r.attributes[s]):String(r.attributes[s])}this.trigger("data",r);return}if(e=/^#EXT-X-INDEPENDENT-SEGMENTS/.exec(i),e){this.trigger("data",{type:"tag",tagType:"independent-segments"});return}if(e=/^#EXT-X-I-FRAMES-ONLY/.exec(i),e){this.trigger("data",{type:"tag",tagType:"i-frames-only"});return}if(e=/^#EXT-X-CONTENT-STEERING:(.*)$/.exec(i),e){r={type:"tag",tagType:"content-steering"},r.attributes=M(e[1]),this.trigger("data",r);return}if(e=/^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(i),e){r={type:"tag",tagType:"i-frame-playlist"},r.attributes=M(e[1]),r.attributes.URI&&(r.uri=r.attributes.URI),r.attributes.BANDWIDTH&&(r.attributes.BANDWIDTH=parseInt(r.attributes.BANDWIDTH,10)),r.attributes.RESOLUTION&&(r.attributes.RESOLUTION=Qe(r.attributes.RESOLUTION)),r.attributes["AVERAGE-BANDWIDTH"]&&(r.attributes["AVERAGE-BANDWIDTH"]=parseInt(r.attributes["AVERAGE-BANDWIDTH"],10)),r.attributes["FRAME-RATE"]&&(r.attributes["FRAME-RATE"]=parseFloat(r.attributes["FRAME-RATE"])),this.trigger("data",r);return}if(e=/^#EXT-X-DEFINE:(.*)$/.exec(i),e){r={type:"tag",tagType:"define"},r.attributes=M(e[1]),this.trigger("data",r);return}this.trigger("data",{type:"tag",data:i.slice(4)})})}}addParser({expression:t,customType:e,dataParser:r,segment:i}){typeof r!="function"&&(r=n=>n),this.customParsers.push(n=>{if(t.exec(n))return this.trigger("data",{type:"custom",data:r(n),customType:e,segment:i}),!0})}addTagMapper({expression:t,map:e}){const r=i=>t.test(i)?e(i):i;this.tagMappers.push(r)}}const er=a=>a.toLowerCase().replace(/-(\w)/g,t=>t[1].toUpperCase()),V=function(a){const t={};return Object.keys(a).forEach(function(e){t[er(e)]=a[e]}),t},Se=function(a){const{serverControl:t,targetDuration:e,partTargetDuration:r}=a;if(!t)return;const i="#EXT-X-SERVER-CONTROL",n="holdBack",s="partHoldBack",o=e&&e*3,d=r&&r*2;e&&!t.hasOwnProperty(n)&&(t[n]=o,this.trigger("info",{message:`${i} defaulting HOLD-BACK to targetDuration * 3 (${o}).`})),o&&t[n]<o&&(this.trigger("warn",{message:`${i} clamping HOLD-BACK (${t[n]}) to targetDuration * 3 (${o})`}),t[n]=o),r&&!t.hasOwnProperty(s)&&(t[s]=r*3,this.trigger("info",{message:`${i} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${t[s]}).`})),r&&t[s]<d&&(this.trigger("warn",{message:`${i} clamping PART-HOLD-BACK (${t[s]}) to partTargetDuration * 2 (${d}).`}),t[s]=d)};class tr extends De{constructor(t={}){super(),this.lineStream=new zt,this.parseStream=new Zt,this.lineStream.pipe(this.parseStream),this.mainDefinitions=t.mainDefinitions||{},this.params=new URL(t.uri,"https://a.com").searchParams,this.lastProgramDateTime=null;const e=this,r=[];let i={},n,s,o=!1;const d=function(){},g={AUDIO:{},VIDEO:{},"CLOSED-CAPTIONS":{},SUBTITLES:{}},f="urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";let m=0;this.manifest={allowCache:!0,discontinuityStarts:[],dateRanges:[],iFramePlaylists:[],segments:[]};let E=0,y=0;const A={};this.on("end",()=>{i.uri||!i.parts&&!i.preloadHints||(!i.map&&n&&(i.map=n),!i.key&&s&&(i.key=s),!i.timeline&&typeof m=="number"&&(i.timeline=m),this.manifest.preloadSegment=i)}),this.parseStream.on("data",function(l){let R,_;if(e.manifest.definitions){for(const u in e.manifest.definitions)if(l.uri&&(l.uri=l.uri.replace(`{$${u}}`,e.manifest.definitions[u])),l.attributes)for(const c in l.attributes)typeof l.attributes[c]=="string"&&(l.attributes[c]=l.attributes[c].replace(`{$${u}}`,e.manifest.definitions[u]))}({tag(){({version(){l.version&&(this.manifest.version=l.version)},"allow-cache"(){this.manifest.allowCache=l.allowed,"allowed"in l||(this.trigger("info",{message:"defaulting allowCache to YES"}),this.manifest.allowCache=!0)},byterange(){const u={};"length"in l&&(i.byterange=u,u.length=l.length,"offset"in l||(l.offset=E)),"offset"in l&&(i.byterange=u,u.offset=l.offset),E=u.offset+u.length},endlist(){this.manifest.endList=!0},inf(){"mediaSequence"in this.manifest||(this.manifest.mediaSequence=0,this.trigger("info",{message:"defaulting media sequence to zero"})),"discontinuitySequence"in this.manifest||(this.manifest.discontinuitySequence=0,this.trigger("info",{message:"defaulting discontinuity sequence to zero"})),l.title&&(i.title=l.title),l.duration>0&&(i.duration=l.duration),l.duration===0&&(i.duration=.01,this.trigger("info",{message:"updating zero segment duration to a small value"})),this.manifest.segments=r},key(){if(!l.attributes){this.trigger("warn",{message:"ignoring key declaration without attribute list"});return}if(l.attributes.METHOD==="NONE"){s=null;return}if(!l.attributes.URI){this.trigger("warn",{message:"ignoring key declaration without URI"});return}if(l.attributes.KEYFORMAT==="com.apple.streamingkeydelivery"){this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.apple.fps.1_0"]={attributes:l.attributes};return}if(l.attributes.KEYFORMAT==="com.microsoft.playready"){this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.microsoft.playready"]={uri:l.attributes.URI};return}if(l.attributes.KEYFORMAT===f){if(["SAMPLE-AES","SAMPLE-AES-CTR","SAMPLE-AES-CENC"].indexOf(l.attributes.METHOD)===-1){this.trigger("warn",{message:"invalid key method provided for Widevine"});return}if(l.attributes.METHOD==="SAMPLE-AES-CENC"&&this.trigger("warn",{message:"SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"}),l.attributes.URI.substring(0,23)!=="data:text/plain;base64,"){this.trigger("warn",{message:"invalid key URI provided for Widevine"});return}if(!(l.attributes.KEYID&&l.attributes.KEYID.substring(0,2)==="0x")){this.trigger("warn",{message:"invalid key ID provided for Widevine"});return}this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.widevine.alpha"]={attributes:{schemeIdUri:l.attributes.KEYFORMAT,keyId:l.attributes.KEYID.substring(2)},pssh:Qt(l.attributes.URI.split(",")[1])};return}l.attributes.METHOD||this.trigger("warn",{message:"defaulting key method to AES-128"}),s={method:l.attributes.METHOD||"AES-128",uri:l.attributes.URI},typeof l.attributes.IV<"u"&&(s.iv=l.attributes.IV)},"media-sequence"(){if(!isFinite(l.number)){this.trigger("warn",{message:"ignoring invalid media sequence: "+l.number});return}this.manifest.mediaSequence=l.number},"discontinuity-sequence"(){if(!isFinite(l.number)){this.trigger("warn",{message:"ignoring invalid discontinuity sequence: "+l.number});return}this.manifest.discontinuitySequence=l.number,m=l.number},"playlist-type"(){if(!/VOD|EVENT/.test(l.playlistType)){this.trigger("warn",{message:"ignoring unknown playlist type: "+l.playlist});return}this.manifest.playlistType=l.playlistType},map(){n={},l.uri&&(n.uri=l.uri),l.byterange&&(n.byterange=l.byterange),s&&(n.key=s)},"stream-inf"(){if(this.manifest.playlists=r,this.manifest.mediaGroups=this.manifest.mediaGroups||g,!l.attributes){this.trigger("warn",{message:"ignoring empty stream-inf attributes"});return}i.attributes||(i.attributes={}),te(i.attributes,l.attributes)},media(){if(this.manifest.mediaGroups=this.manifest.mediaGroups||g,!(l.attributes&&l.attributes.TYPE&&l.attributes["GROUP-ID"]&&l.attributes.NAME)){this.trigger("warn",{message:"ignoring incomplete or missing media group"});return}const u=this.manifest.mediaGroups[l.attributes.TYPE];u[l.attributes["GROUP-ID"]]=u[l.attributes["GROUP-ID"]]||{},R=u[l.attributes["GROUP-ID"]],_={default:/yes/i.test(l.attributes.DEFAULT)},_.default?_.autoselect=!0:_.autoselect=/yes/i.test(l.attributes.AUTOSELECT),l.attributes.LANGUAGE&&(_.language=l.attributes.LANGUAGE),l.attributes.URI&&(_.uri=l.attributes.URI),l.attributes["INSTREAM-ID"]&&(_.instreamId=l.attributes["INSTREAM-ID"]),l.attributes.CHARACTERISTICS&&(_.characteristics=l.attributes.CHARACTERISTICS),l.attributes.FORCED&&(_.forced=/yes/i.test(l.attributes.FORCED)),R[l.attributes.NAME]=_},discontinuity(){m+=1,i.discontinuity=!0,this.manifest.discontinuityStarts.push(r.length)},"program-date-time"(){typeof this.manifest.dateTimeString>"u"&&(this.manifest.dateTimeString=l.dateTimeString,this.manifest.dateTimeObject=l.dateTimeObject),i.dateTimeString=l.dateTimeString,i.dateTimeObject=l.dateTimeObject;const{lastProgramDateTime:u}=this;this.lastProgramDateTime=new Date(l.dateTimeString).getTime(),u===null&&this.manifest.segments.reduceRight((c,b)=>(b.programDateTime=c-b.duration*1e3,b.programDateTime),this.lastProgramDateTime)},targetduration(){if(!isFinite(l.duration)||l.duration<0){this.trigger("warn",{message:"ignoring invalid target duration: "+l.duration});return}this.manifest.targetDuration=l.duration,Se.call(this,this.manifest)},start(){if(!l.attributes||isNaN(l.attributes["TIME-OFFSET"])){this.trigger("warn",{message:"ignoring start declaration without appropriate attribute list"});return}this.manifest.start={timeOffset:l.attributes["TIME-OFFSET"],precise:l.attributes.PRECISE}},"cue-out"(){i.cueOut=l.data},"cue-out-cont"(){i.cueOutCont=l.data},"cue-in"(){i.cueIn=l.data},skip(){this.manifest.skip=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-SKIP",l.attributes,["SKIPPED-SEGMENTS"])},part(){o=!0;const u=this.manifest.segments.length,c=V(l.attributes);i.parts=i.parts||[],i.parts.push(c),c.byterange&&(c.byterange.hasOwnProperty("offset")||(c.byterange.offset=y),y=c.byterange.offset+c.byterange.length);const b=i.parts.length-1;this.warnOnMissingAttributes_(`#EXT-X-PART #${b} for segment #${u}`,l.attributes,["URI","DURATION"]),this.manifest.renditionReports&&this.manifest.renditionReports.forEach((w,I)=>{w.hasOwnProperty("lastPart")||this.trigger("warn",{message:`#EXT-X-RENDITION-REPORT #${I} lacks required attribute(s): LAST-PART`})})},"server-control"(){const u=this.manifest.serverControl=V(l.attributes);u.hasOwnProperty("canBlockReload")||(u.canBlockReload=!1,this.trigger("info",{message:"#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"})),Se.call(this,this.manifest),u.canSkipDateranges&&!u.hasOwnProperty("canSkipUntil")&&this.trigger("warn",{message:"#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"})},"preload-hint"(){const u=this.manifest.segments.length,c=V(l.attributes),b=c.type&&c.type==="PART";i.preloadHints=i.preloadHints||[],i.preloadHints.push(c),c.byterange&&(c.byterange.hasOwnProperty("offset")||(c.byterange.offset=b?y:0,b&&(y=c.byterange.offset+c.byterange.length)));const w=i.preloadHints.length-1;if(this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${w} for segment #${u}`,l.attributes,["TYPE","URI"]),!!c.type)for(let I=0;I<i.preloadHints.length-1;I++){const O=i.preloadHints[I];O.type&&O.type===c.type&&this.trigger("warn",{message:`#EXT-X-PRELOAD-HINT #${w} for segment #${u} has the same TYPE ${c.type} as preload hint #${I}`})}},"rendition-report"(){const u=V(l.attributes);this.manifest.renditionReports=this.manifest.renditionReports||[],this.manifest.renditionReports.push(u);const c=this.manifest.renditionReports.length-1,b=["LAST-MSN","URI"];o&&b.push("LAST-PART"),this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${c}`,l.attributes,b)},"part-inf"(){this.manifest.partInf=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-PART-INF",l.attributes,["PART-TARGET"]),this.manifest.partInf.partTarget&&(this.manifest.partTargetDuration=this.manifest.partInf.partTarget),Se.call(this,this.manifest)},daterange(){this.manifest.dateRanges.push(V(l.attributes));const u=this.manifest.dateRanges.length-1;this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${u}`,l.attributes,["ID","START-DATE"]);const c=this.manifest.dateRanges[u];c.endDate&&c.startDate&&new Date(c.endDate)<new Date(c.startDate)&&this.trigger("warn",{message:"EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"}),c.duration&&c.duration<0&&this.trigger("warn",{message:"EXT-X-DATERANGE DURATION must not be negative"}),c.plannedDuration&&c.plannedDuration<0&&this.trigger("warn",{message:"EXT-X-DATERANGE PLANNED-DURATION must not be negative"});const b=!!c.endOnNext;if(b&&!c.class&&this.trigger("warn",{message:"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"}),b&&(c.duration||c.endDate)&&this.trigger("warn",{message:"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"}),c.duration&&c.endDate){const w=c.startDate.getTime()+c.duration*1e3;this.manifest.dateRanges[u].endDate=new Date(w)}if(!A[c.id])A[c.id]=c;else{for(const I in A[c.id])if(c[I]&&JSON.stringify(A[c.id][I])!==JSON.stringify(c[I])){this.trigger("warn",{message:"EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"});break}const w=this.manifest.dateRanges.findIndex(I=>I.id===c.id);this.manifest.dateRanges[w]=te(this.manifest.dateRanges[w],c),A[c.id]=te(A[c.id],c),this.manifest.dateRanges.pop()}},"independent-segments"(){this.manifest.independentSegments=!0},"i-frames-only"(){this.manifest.iFramesOnly=!0,this.requiredCompatibilityversion(this.manifest.version,4)},"content-steering"(){this.manifest.contentSteering=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING",l.attributes,["SERVER-URI"])},define(){this.manifest.definitions=this.manifest.definitions||{};const u=(c,b)=>{if(c in this.manifest.definitions){this.trigger("error",{message:`EXT-X-DEFINE: Duplicate name ${c}`});return}this.manifest.definitions[c]=b};if("QUERYPARAM"in l.attributes){if("NAME"in l.attributes||"IMPORT"in l.attributes){this.trigger("error",{message:"EXT-X-DEFINE: Invalid attributes"});return}const c=this.params.get(l.attributes.QUERYPARAM);if(!c){this.trigger("error",{message:`EXT-X-DEFINE: No query param ${l.attributes.QUERYPARAM}`});return}u(l.attributes.QUERYPARAM,decodeURIComponent(c));return}if("NAME"in l.attributes){if("IMPORT"in l.attributes){this.trigger("error",{message:"EXT-X-DEFINE: Invalid attributes"});return}if(!("VALUE"in l.attributes)||typeof l.attributes.VALUE!="string"){this.trigger("error",{message:`EXT-X-DEFINE: No value for ${l.attributes.NAME}`});return}u(l.attributes.NAME,l.attributes.VALUE);return}if("IMPORT"in l.attributes){if(!this.mainDefinitions[l.attributes.IMPORT]){this.trigger("error",{message:`EXT-X-DEFINE: No value ${l.attributes.IMPORT} to import, or IMPORT used on main playlist`});return}u(l.attributes.IMPORT,this.mainDefinitions[l.attributes.IMPORT]);return}this.trigger("error",{message:"EXT-X-DEFINE: No attribute"})},"i-frame-playlist"(){this.manifest.iFramePlaylists.push({attributes:l.attributes,uri:l.uri,timeline:m}),this.warnOnMissingAttributes_("#EXT-X-I-FRAME-STREAM-INF",l.attributes,["BANDWIDTH","URI"])}}[l.tagType]||d).call(e)},uri(){i.uri=l.uri,r.push(i),this.manifest.targetDuration&&!("duration"in i)&&(this.trigger("warn",{message:"defaulting segment duration to the target duration"}),i.duration=this.manifest.targetDuration),s&&(i.key=s),i.timeline=m,n&&(i.map=n),y=0,this.lastProgramDateTime!==null&&(i.programDateTime=this.lastProgramDateTime,this.lastProgramDateTime+=i.duration*1e3),i={}},comment(){},custom(){l.segment?(i.custom=i.custom||{},i.custom[l.customType]=l.data):(this.manifest.custom=this.manifest.custom||{},this.manifest.custom[l.customType]=l.data)}})[l.type].call(e)})}requiredCompatibilityversion(t,e){(t<e||!t)&&this.trigger("warn",{message:`manifest must be at least version ${e}`})}warnOnMissingAttributes_(t,e,r){const i=[];r.forEach(function(n){e.hasOwnProperty(n)||i.push(n)}),i.length&&this.trigger("warn",{message:`${t} lacks required attribute(s): ${i.join(", ")}`})}push(t){this.lineStream.push(t)}end(){this.lineStream.push(`
`),this.manifest.dateRanges.length&&this.lastProgramDateTime===null&&this.trigger("warn",{message:"A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"}),this.lastProgramDateTime=null,this.trigger("end")}addParser(t){this.parseStream.addParser(t)}addTagMapper(t){this.parseStream.addTagMapper(t)}}console.log("DOWNLOAD_HANDLER.TS IS BEING LOADED AND PARSED");const ze=x.create("DownloadHandler_EarlyTest",X.Debug);ze.logError("DOWNLOAD_HANDLER.TS - EARLY ERROR LOG TEST"),ze.logDebug("DOWNLOAD_HANDLER.TS - EARLY DEBUG LOG TEST");class B extends Error{constructor(t,e){super(`${t} (TrackId: ${e})`)}}const h=x.create("DownloadHandler",X.Debug),re=new Le;function rr(a){return a&&a.kind==="track"&&a.state==="finished"&&(a.streamable||a.downloadable)}function ar(a){return typeof a=="object"&&a!==null&&"protocol"in a}function ir(a){if(a?.media?.transcodings?.length<1)return h.logDebug(`[DownloadHandler TrackId: ${a.id}] No transcodings array or empty in track.media.`),null;h.logDebug(`[DownloadHandler TrackId: ${a.id}] Raw transcodings:`,JSON.stringify(a.media.transcodings,null,2));const t=a.media.transcodings.filter(r=>(r.format?.protocol==="progressive"||r.format?.protocol==="hls")&&(r.format?.mime_type?.startsWith("audio/mpeg")||r.format?.mime_type?.startsWith("audio/mp4"))&&!r.snipped).map(r=>({protocol:r.format.protocol,url:r.url,quality:r.quality}));if(t.length<1)return h.logWarn("[DownloadHandler] No transcodings streams could be determined for Track "+a.id),null;let e=t.sort((r,i)=>r.quality==="hq"&&i.quality==="sq"?-1:r.quality==="sq"&&i.quality==="hq"?1:r.protocol==="progressive"&&i.protocol==="hls"?-1:r.protocol==="hls"&&i.protocol==="progressive"?1:0);return v("download-hq-version")||(e=e.filter(r=>r.quality!=="hq")),e.some(r=>r.quality==="hq")&&h.logInfo("[DownloadHandler] Including high quality streams for Track "+a.id),e}async function Ke(a,t,e,r,i){if(!rr(a))throw h.logError("[DownloadHandler] Track does not satisfy constraints needed to be downloadable",a),new B("Track does not satisfy constraints needed to be downloadable",a.id);const n=[];if(v("download-original-version")&&a.downloadable&&a.has_downloads_left){const o=await re.getOriginalDownloadUrl(a.id);if(o){const d={url:o,hls:!1,extension:void 0};n.push(d)}}const s=ir(a);if(s&&n.push(...s),n.length<1){const o=`[DownloadHandler] No download details could be determined for track: "${a.title}"`;throw new B(o,a.id)}for(const o of n){let d=null,g=!1,f=null,m;try{if(ar(o))if(h.logDebug(`[DownloadHandler TrackId: ${a.id}] Getting stream details for transcoding`,o),d=await re.getStreamDetails(o.url),d)g=d.hls,f=d.url,m=d.extension;else{h.logWarn(`[DownloadHandler TrackId: ${a.id}] Failed to get stream details for transcoding option (url: ${o.url}), trying next...`);continue}else d=o,f=d.url,g=d.hls,m=d.extension,h.logDebug(`[DownloadHandler TrackId: ${a.id}] Using direct download detail (original file?)`,{url:f,hls:g,extension:m});if(!f){h.logWarn(`[DownloadHandler TrackId: ${a.id}] No stream URL resolved, trying next...`,{downloadDetail:o});continue}let E=f,y=g;const A={trackId:a.id,duration:a.duration,uploadDate:new Date(a.display_date),streamUrl:E,fileExtension:m,title:a.title,username:a.user.username,userPermalink:a.user.permalink,artworkUrl:a.artwork_url,avatarUrl:a.user.avatar_url,trackNumber:t,albumName:e,playlistName:r,hls:y,wasOriginallyHls:g};h.logDebug(`[DownloadHandler TrackId: ${a.id}] Calling handleDownload with data`,{downloadData:A});const l=await nr(A,i);return h.logInfo(`[DownloadHandler TrackId: ${a.id}] handleDownload returned browserDownloadId: ${l} for stream: ${E}`),i(101,l),l}catch(E){h.logWarn(`[DownloadHandler TrackId: ${a.id}] Download attempt failed for option. Error: ${E?.message||E}`,{downloadDetail:o,streamUrl:f})}}throw h.logError(`[DownloadHandler TrackId: ${a.id}] All download attempts failed after trying ${n.length} options.`),i(102),new B("No version of this track could be downloaded",a.id)}async function nr(a,t){h.logDebug(`[handleDownload ENTRY] Processing TrackId: ${a.trackId}. History check comes later.`);let e=a.username,r=a.title,i,n=a.artworkUrl,s,o,d,g,f,m,E,y,A;try{try{if(h.logInfo(`Initiating metadata processing for ${a.trackId} with payload`,{payload:a}),v("normalize-track")){const u=new C(a.title,a.username,a.userPermalink);let c=u.getArtists();v("include-producers")||(c=c.filter(w=>w.type!==Ae.Producer)),e=c.map(w=>w.name).join(", "),r=u.getTitle();const b=c.filter(w=>w.type===Ae.Remixer);if(b.length>0){const w=b.map(O=>O.name).join(" & "),I=$e[b[0].remixType||$e.Remix].toString();r+=` (${w} ${I})`}}e||(e="Unknown"),r||(r="Unknown"),i=ce(`${e} - ${r}`)}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during metadata processing:`,u),new B(`Metadata processing failed for track ${a.trackId}: ${u.message}`,a.trackId)}d=!v("download-without-prompt"),g=v("default-download-location"),f=v("skipExistingFiles");try{const u=a.fileExtension||"mp3";if(A=i+"."+u,!d&&g)if(a.playlistName){const c=ce(a.playlistName);A=g+"/"+c+"/"+A}else A=g+"/"+A;if(f){let c="";if(g)if(a.playlistName){const N=ce(a.playlistName);c=g+"/"+N+"/"}else c=g+"/";const b=`track-${a.trackId}`,w=await Me("track-download-history")||{};if(h.logDebug(`[History Check] shouldSkipExisting=${f}, trackIdKey=${b}, history exists=${!!w}`),Object.keys(w).length>0&&h.logDebug(`[History Check] History has ${Object.keys(w).length} entries`),w&&w[b]){const N=w[b];h.logInfo(`Skipping download for TrackId: ${a.trackId}. Previously downloaded as: ${N.filename} at ${new Date(N.timestamp).toLocaleString()}`),t(101);const U=Math.floor(Math.random()*1e6)+1e3;return h.logInfo(`Using fake download ID ${U} for skipped track ${a.trackId}`),U}const I={filename:`${c}${i}.${a.fileExtension||"mp3"}`};h.logDebug(`[History Check] Searching downloads with exactQuery: ${JSON.stringify(I)}`);const O=await pe(I);h.logDebug(`[History Check] exactMatches found: ${O.length}`);const K=c.replace(/[-/^$*+?.()|[\]{}]/g,"\\$&"),J=i.replace(/[-/^$*+?.()|[\]{}]/g,"\\$&"),le={filenameRegex:`^${K}${J}\\..+$`};h.logDebug(`[History Check] Searching downloads with regexQuery: ${JSON.stringify(le)}`);const ne=O.length===0?await pe(le):[];h.logDebug(`[History Check] regexMatches found: ${ne.length}`);const Z={filenameRegex:`${J}\\..+$`};h.logDebug(`[History Check] Searching downloads with titleArtistQuery: ${JSON.stringify(Z)}`);const S=O.length===0&&ne.length===0?await pe(Z):[];h.logDebug(`[History Check] titleArtistMatches found: ${S.length}`);const F=[...O,...ne,...S].filter(N=>N.state==="complete");if(F.length>0){h.logInfo(`Skipping download for TrackId: ${a.trackId}. File already exists in download history: ${F[0].filename}`),F.length>0&&F.slice(0,3).forEach((U,nt)=>{h.logDebug(`[History Check] Match ${nt}: filename=${U.filename}, state=${U.state}`)}),w[b]={filename:F[0].filename,timestamp:Date.now()},await L("track-download-history",w),t(101);const N=Math.floor(Math.random()*1e6)+1e3;return h.logInfo(`Using fake download ID ${N} for already downloaded track ${a.trackId}`),N}else h.logDebug(`No matching downloads found for TrackId: ${a.trackId} with filename base "${i}"`)}else h.logDebug("[History Check] Skip existing files check is disabled")}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during filename/skip logic:`,u),new B(`Filename/skip logic failed for track ${a.trackId}: ${u.message}`,a.trackId)}try{n||(h.logInfo(`No Artwork URL in data. Fallback to User Avatar (TrackId: ${a.trackId})`),n=a.avatarUrl)}catch(u){h.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Error checking/falling back artwork URL: ${u.message}. Will attempt with current value.`)}h.logInfo(`Starting download of '${i}' (TrackId: ${a.trackId})...`);let l;try{if(a.hls){h.logInfo(`[TrackId: ${a.trackId}] Starting HLS segment fetching from: ${a.streamUrl}`);const[u,c]=await re.downloadStream(a.streamUrl,S=>{S!==void 0&&t(S*.1)});if(o=c,!u)throw new Error("HLS playlist download failed or returned empty buffer.");const b=new TextDecoder().decode(u),w=new tr;w.push(b),w.end();let I=null;if(w.manifest?.segments?.length>0){const S=w.manifest.segments.find(F=>F.map?.uri);if(S?.map?.uri){let F=S.map.uri;try{F.startsWith("http://")||F.startsWith("https://")||(F=new URL(F,a.streamUrl).href)}catch{if(!(F.startsWith("http://")||F.startsWith("https://")))throw new Error(`Failed to resolve relative HLS init segment URI: ${F}`)}const[N]=await re.downloadStream(F,U=>{U!==void 0&&t(5+U*.05)});if(!N)throw new Error(`Failed to download HLS init segment: ${F}`);I=N}}let O=[];if(w.manifest?.segments?.length>0&&(O=w.manifest.segments.map(S=>{try{return new URL(S.uri,a.streamUrl).href}catch{if(S.uri.startsWith("http://")||S.uri.startsWith("https://"))return S.uri;throw new Error(`Failed to resolve relative HLS segment URI: ${S.uri}`)}})),O.length===0&&!I)throw new Error("HLS playlist contains no media segments or init segment.");const K=[],J=O.length,le=I?10:5,ne=I?80:85;for(let S=0;S<J;S++){const[F]=await re.downloadStream(O[S],U=>{U!==void 0&&t(le+(S+U/100)/J*ne)});if(!F)throw new Error(`Failed to download HLS segment: ${O[S]}`);K.push(F);const N=v("hls-rate-limit-delay-ms")??0;N>0&&S<J-1&&await new Promise(U=>setTimeout(U,N))}const Z=[];I&&Z.push(I),Z.push(...K),s=Fe(Z),a.hls=!1}else[s,o]=await re.downloadStream(a.streamUrl,t);if(!s)throw new B("Stream buffer is undefined after download attempts",a.trackId);if(l=s.slice(0),h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] Initial streamBuffer byteLength: ${s?.byteLength}, originalStreamBuffer byteLength: ${l?.byteLength}`),a.wasOriginallyHls&&a.fileExtension&&/^[a-f0-9]{4}$/i.test(a.fileExtension)&&a.streamUrl.includes("/aac")?(h.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Correcting likely bogus HLS AAC extension '${a.fileExtension}' to 'm4a'.`),a.fileExtension="m4a"):a.wasOriginallyHls&&a.fileExtension&&a.fileExtension.toLowerCase()==="m3u8"&&(h.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Correcting HLS extension from 'm3u8' to 'm4a' (assuming AAC).`),a.fileExtension="m4a"),!a.fileExtension&&o){m=o.get("content-type");let u="mp3";m==="audio/mp4"?u="m4a":(m==="audio/x-wav"||m==="audio/wav")&&(u="wav"),a.fileExtension=u}else a.fileExtension||(a.fileExtension="mp3");if(v("ffmpeg-remux-hls-mp4")&&(a.fileExtension==="m4a"||a.fileExtension==="mp4")){t(85);const u=c=>{const b=85+Math.floor(c*.13);t(b)};try{h.logInfo(`[DownloadHandler TrackId: ${a.trackId}] Sending remux task to FFmpegManager. Original streamBuffer byteLength before remux: ${l?.byteLength}`),s=await Mt(a.trackId.toString(),l,a.fileExtension||"mp4",u),(a.fileExtension==="m4a"||a.fileExtension==="mp4")&&(m="audio/mp4"),t(99),h.logInfo(`[DownloadHandler TrackId: ${a.trackId}] Remux task completed by FFmpegManager.`)}catch(c){h.logError(`[FFMPEG_MANAGER] Error during remux via manager. Proceeding with original. TrackId: ${a.trackId}`,c),s=l.slice(0),h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] FFmpeg failed. Fallen back to originalStreamBuffer. ByteLength: ${s?.byteLength}`)}}else h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] FFmpeg remux skipped (disabled or not applicable filetype).`)}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during download/FFmpeg stage:`,u),new B(`Download/FFmpeg failed for track ${a.trackId}: ${u.message}`,a.trackId)}let R;try{const u=v("set-metadata");if(h.logDebug(`[Metadata Check Before If] TrackId: ${a.trackId}, setMetadata config: ${u}, streamBuffer exists: ${!!s}`),u&&s){let c;const b=s.slice(0);if(a.fileExtension==="mp3"?c=new Ht(b):(a.fileExtension==="m4a"||a.fileExtension==="mp4")&&(c=new k(b)),c){if(r&&c.setTitle(r),e&&c.setArtists([e]),a.albumName?c.setAlbum(a.albumName):a.playlistName&&c.setAlbum(a.playlistName),a.uploadDate){const I=a.uploadDate.getFullYear();isNaN(I)||c.setYear(I)}if(a.trackNumber&&c.setTrackNumber(a.trackNumber),a.trackId?c.setSoundCloudTrackId(a.trackId.toString()):h.logWarn(`[Metadata] TrackId is missing in data, cannot set SoundCloudTrackID for tagging. Track Title: ${a.title}`),n)try{const I=n.replace("-large.jpg","-t500x500.jpg"),O=await fetch(I);if(!O.ok)throw new Error(`Artwork fetch failed: ${O.statusText}`);const K=await O.arrayBuffer();c.setArtwork(K)}catch(I){h.logWarn(`[Artwork] Failed to fetch/set artwork for tagging TrackId: ${a.trackId}`,I)}const w=await c.getBuffer();h.logDebug(`[Metadata] TagWriter result for TrackId ${a.trackId} (ext: ${a.fileExtension}): applied=${w.tagsApplied}, message='${w.message||"none"}'`),w?.buffer?.byteLength>0?R=w.buffer:(h.logWarn("[Metadata] TagWriter returned invalid buffer. Using untagged buffer."),R=s.slice(0))}else h.logWarn(`[TrackId: ${a.trackId}] No TagWriter for ext '${a.fileExtension}'. Using untagged buffer.`),R=s.slice(0)}else h.logInfo(`[TrackId: ${a.trackId}] Metadata disabled or no streamBuffer. Using untagged.`),R=s?.slice(0)}catch(u){h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during metadata tagging:`,u),R=s?.slice(0)}let _;try{_=R?.byteLength>0?R:s?.byteLength>0?s.slice(0):l?.byteLength>0?l.slice(0):(()=>{throw new B(`All buffers invalid for ${a.trackId}`,a.trackId)})(),_.byteLength<100&&h.logWarn(`Final buffer small: ${_.byteLength} bytes.`),h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] Final bufferToSave byteLength before Blob creation: ${_?.byteLength}`);const u={};m?u.type=m:a.fileExtension==="mp3"?u.type="audio/mpeg":a.fileExtension==="m4a"||a.fileExtension==="mp4"?u.type="audio/mp4":a.fileExtension==="wav"&&(u.type="audio/wav");const c=new Blob([_],u);h.logInfo(`Creating URL for download (TrackId: ${a.trackId}). Service worker context: ${ot()}`),y=await lt(c)}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error preparing final buffer or Blob/DataURL:`,u),new B(`Failed to prepare buffer/DataURL for track ${a.trackId}: ${u.message}`,a.trackId)}if(E=i+"."+(a.fileExtension||"mp3"),!d&&g){const u=g.endsWith("/")?g.slice(0,-1):g,c=a.playlistName?`/${ce(a.playlistName)}`:"",b=E.split("/").pop()||E;E=`${u}${c}/${b}`}try{h.logInfo(`Downloading track as '${E}' (TrackId: ${a.trackId}). SaveAs: ${d}`);const u=y;if(!u)throw new Error("Data URL for download is undefined.");const c=await gt(u,E,d);if(h.logInfo(`Successfully initiated browser download for '${i}' (TrackId: ${a.trackId}) with browserDownloadId: ${c}`),f){const b=`track-${a.trackId}`,w=await Me("track-download-history")||{};w[b]={filename:E,timestamp:Date.now()},await L("track-download-history",w)}return c}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Download save stage error:`,u),new B(`Save failed for track ${a.trackId}: ${u.message}`,a.trackId)}}catch(l){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Uncaught error in handleDownload`,l),l instanceof B?l:new B(`Unknown error during download: ${l?.message||l}`,a.trackId)}}const ae=x.create("Semaphore",X.Debug);class Je{tasks=[];count;maxCount;constructor(t){if(t<=0)throw new Error("Semaphore count must be a positive integer.");this.count=t,this.maxCount=t}async acquire(){return ae.logDebug(`Acquire attempt: current count ${this.count}, tasks in queue ${this.tasks.length}`),this.count>0?(this.count--,ae.logDebug(`Acquired immediately. New count ${this.count}`),Promise.resolve()):new Promise(t=>{this.tasks.push(t),ae.logDebug(`Queued. New queue length ${this.tasks.length}`)})}release(){if(this.count++,ae.logDebug(`Released. New count ${this.count}`),this.tasks.length>0){const t=this.tasks.shift();t&&(this.count--,ae.logDebug(`Processing queued task. New count ${this.count}, New queue length ${this.tasks.length}`),t())}this.count>this.maxCount&&(ae.logWarn(`Semaphore count (${this.count}) exceeded maxCount (${this.maxCount}) after release. This might indicate an issue.`),this.count=this.maxCount)}async withLock(t){await this.acquire();try{return await t()}finally{this.release()}}getAvailablePermits(){return this.count}getQueueLength(){return this.tasks.length}}const oe=new Le,p=x.create("Background",X.Debug),sr=ct(),P=[];let ve=!1;const me="persistentDownloadQueue_v1";async function G(){try{const a=JSON.parse(JSON.stringify(P));await chrome.storage.local.set({[me]:a}),p.logDebug("[Queue Persistence] Queue state saved.")}catch(a){p.logError("[Queue Persistence] Failed to save queue state:",a)}}async function or(){try{const a=(await chrome.storage.local.get(me))[me];if(Array.isArray(a)){p.logInfo(`[Queue Persistence] Loading ${a.length} items from storage (key: ${me}).`);const t=[];let e=0;for(const r of a)if(r&&typeof r.id=="string"&&typeof r.type=="string"&&typeof r.status=="string"&&typeof r.url=="string"&&typeof r.addedAt=="number"&&r.originalMessage!==void 0){const i=r;i.status==="processing"&&(i.status="pending",i.progress=0,e++),t.push(i)}else p.logWarn("[Queue Persistence] Discarding invalid item from saved queue:",r);P.splice(0,P.length,...t),p.logInfo(`[Queue Persistence] Queue initialized. ${e} items reset from processing to pending.`),z(),ie()}else p.logInfo("[Queue Persistence] No saved queue found or invalid format.")}catch(a){const t="[Queue Persistence] Failed to load queue state";if(a instanceof Error){const e=a.message||"[No message property]",r=a.stack||"[No stack trace]";p.logError(`${t}: ${e}
Stack: ${r}`)}else a?p.logError(`${t}. Caught non-Error object: ${String(a)}`):(p.logError(`${t}. An undefined or null error was caught.`),console.error("[Queue Persistence] Raw undefined/null error value that was caught by loadAndInitializeQueue:",a))}}const z=()=>{p.logDebug("[Queue Broadcast] Sending queue update."),chrome?.runtime?.sendMessage?chrome.runtime.sendMessage({type:"QUEUE_UPDATED_BROADCAST",queuePayload:P},a=>{if(chrome.runtime.lastError){const t=chrome.runtime.lastError.message?.toLowerCase()||"";!t.includes("message port closed")&&!t.includes("receiving end does not exist")&&p.logWarn("[Queue Broadcast] Error sending queue update:",chrome.runtime.lastError.message)}}):p.logWarn("[Queue Broadcast] chrome.runtime.sendMessage not available?")},lr=async a=>{p.logInfo(`[QueueProcessor _executeDownloadTask] Starting task for ID: ${a.id}, Type: ${a.type}, URL: ${a.url}`),a.status="processing",await G(),a.originalMessage?.track?.title&&(a.title=a.originalMessage.track.title),a.originalMessage?.track?.artwork_url?a.artworkUrl=a.originalMessage.track.artwork_url:a.originalMessage?.set?.title?a.title=a.originalMessage.set.title:a.originalMessage?.set?.artwork_url&&(a.artworkUrl=a.originalMessage.set.artwork_url),z(),a.tabId&&q(a.tabId,a.id,0,void 0,"Resuming");const t=(e,r)=>{e!==void 0&&(a.progress=e,a.tabId&&q(a.tabId,a.id,e,void 0,r?void 0:"Resuming",r))};try{if(a.type==="DOWNLOAD"){const e=a.originalMessage.url;if(!e)throw new Error("Missing URL in original message for DOWNLOAD item");p.logInfo(`[QueueProcessor _executeDownloadTask] Resolving track URL: ${e} for item ${a.id}`);const r=await oe.resolveUrl(e);if(!r||r.kind!=="track")throw new Error(`Failed to resolve URL to a valid track: ${e}`);a.title=r.title,a.artworkUrl=r.artwork_url,z(),p.logInfo(`[QueueProcessor _executeDownloadTask] Track resolved: ${r.title}. Starting download for item ${a.id}`),await Ke(r,void 0,void 0,void 0,t),a.status="completed",await G(),p.logInfo(`[QueueProcessor _executeDownloadTask] DOWNLOAD complete for item ${a.id}: ${r.title}`)}else if(a.type==="DOWNLOAD_SET"){const e=a.originalMessage.url;if(!e)throw new Error("Missing URL in original message for DOWNLOAD_SET item");p.logInfo(`[QueueProcessor _executeDownloadTask] Resolving set URL: ${e} for item ${a.id}`);const r=await oe.resolveUrl(e);if(!r||!r.tracks||r.tracks.length===0)throw new Error(`Failed to resolve URL to a valid playlist or playlist is empty: ${e}`);a.title=r.title;const i=r.tracks.map(A=>A.id);if(i.length===0){p.logWarn(`[Queue Set ${a.id}] Playlist resolved but contains no track IDs?`),a.status="completed";return}p.logInfo(`[QueueProcessor _executeDownloadTask] Set resolved: ${r.title}. Fetching full details for ${i.length} tracks for item ${a.id}`);const n=cr(i,50),s=[];for(const A of n){const l=await oe.getTracks(A);s.push(...Object.values(l))}p.logInfo(`[QueueProcessor _executeDownloadTask] Fetched full details for ${s.length} tracks.`),!a.artworkUrl&&s.length>0&&(a.artworkUrl=s[0].artwork_url),z();const o={};let d=!1,g=null;const f=()=>{const A=Object.values(o).reduce((l,R)=>l+R,0);return s.length>0?A/s.length:0};a.progress=0,t(0);const m=r.set_type==="album"||r.set_type==="ep"?r.title:void 0,E=r.set_type!=="album"&&r.set_type!=="ep"?r.title:void 0,y=[];for(let A=0;A<s.length;A++){const l=s[A],R=A+1,_=(u,c)=>{if(u!==void 0){o[l.id]=u;const b=f();t(b,c)}};y.push(et.withLock(()=>(p.logDebug(`[Queue Set ${a.id}] Starting download for track ${R}/${s.length}: ${l.title} (ID: ${l.id})`),Ke(l,R,m,E,_))).catch(u=>{p.logWarn(`[Queue Set ${a.id}] Failed to download track ${R}: ${l.title}`,u),d=!0,g=u?.message||String(u),o[l.id]=100;const c=f();t(c)}))}p.logInfo(`[Queue Set ${a.id}] Waiting for ${y.length} track downloads to complete...`),await Promise.all(y),p.logInfo(`[Queue Set ${a.id}] All track download attempts finished.`),d?(a.status="error",a.error="One or more tracks failed to download within the set.",await G(),p.logWarn(`[Queue Set ${a.id}] DOWNLOAD_SET completed with errors. Last individual error logged was: ${g||"None recorded"}`),a.tabId&&q(a.tabId,a.id,102,a.error)):(a.status="completed",a.progress=101,await G(),p.logInfo(`[Queue Set ${a.id}] DOWNLOAD_SET completed successfully.`),a.tabId&&q(a.tabId,a.id,101))}else a.type==="DOWNLOAD_SET_RANGE"?(p.logWarn(`[QueueProcessor _executeDownloadTask] DOWNLOAD_SET_RANGE for ${a.id} not yet implemented in queue processor.`),a.status="error",a.error="Set range downloads via queue not yet implemented.",await G(),a.tabId&&q(a.tabId,a.id,void 0,a.error)):(p.logError(`[QueueProcessor _executeDownloadTask] Unknown item type: ${a.type} for item ID: ${a.id}`),a.status="error",a.error="Unknown download type",await G(),a.tabId&&q(a.tabId,a.id,void 0,a.error))}catch(e){p.logError(`[QueueProcessor _executeDownloadTask] Error processing item ${a.id}:`,e),a.status="error",a.error=e.message||"Unknown error during processing",await G(),a.tabId&&q(a.tabId,a.id,void 0,a.error,void 0)}finally{z()}},gr=async()=>{if(ve)return;ve=!0;const a=P.findIndex(t=>t.status==="pending");if(a!==-1){const t=P[a];await lr(t);const e=P.findIndex(r=>r.id===t.id);e!==-1&&(P[e].status==="completed"||P[e].status==="error")&&(p.logInfo(`[QueueProcessor] Removing finalized item ${P[e].id} (Status: ${P[e].status}) from queue.`),P.splice(e,1),await G(),z())}ve=!1,P.some(t=>t.status==="pending")&&ie()},ie=()=>{setTimeout(()=>{p.logInfo("[QueueProcessor trigger] Checking queue..."),gr()},0)},Ze=()=>Math.max(1,Math.min(Number(v("maxConcurrentTrackDownloads"))||3,10));let et=new Je(Ze());p.logInfo(`Download track semaphore initialized with concurrency: ${Ze()}`),Ee("maxConcurrentTrackDownloads",a=>{const t=Math.max(1,Math.min(Number(a)||3,10));p.logInfo(`Updating download track semaphore concurrency to: ${t}`),et=new Je(t)});async function tt(a){await ht(a)}async function rt(a){await mt(a)}p.logInfo("Starting with version: "+sr.version),dt(At),p.logInfo("Initial message listener registered."),Oe(!0).then(async()=>{p.logInfo("Initial configuration loaded."),await or(),p.logInfo("Setting initial DNR rules.");const a=v("oauth-token");await tt(a);const t=v("client-id");await rt(t),a&&await it(a),Lt()});function q(a,t,e,r,i,n){if(!t||typeof t!="string"||t.trim()===""){p.logError(`Attempted to send download progress with invalid downloadId: ${JSON.stringify(t)}`);const d=new Error().stack;if(p.logError(`Call stack for invalid downloadId: ${d}`),e===101||e===102){p.logWarn(`Attempting to send COMPLETION message (${e}) even with missing downloadId`);const g={downloadId:"undefined_completion",progress:e,error:typeof r=="string"?r:r instanceof Error?r.message:"",status:i,completionWithoutId:!0,timestamp:Date.now(),browserDownloadId:n};ge(a,g).catch(f=>{p.logError(`Failed to send fallback completion message: ${f}`)})}return}let s="";r instanceof Error?s=r.message:typeof r=="string"&&(s=r),e===101||e===102?p.logInfo(`Sending COMPLETION message for download ${t} to tab ${a}, progress=${e}`):e===100&&p.logInfo(`Sending FINISHING message for download ${t} to tab ${a}`);const o={downloadId:t,progress:e,error:s,status:i,timestamp:Date.now(),browserDownloadId:n};e===101||e===102?(p.logInfo(`Sending SINGLE COMPLETION message for download ${t} to tab ${a}, progress=${e} (BrowserDownloadId: ${n||"N/A"})`),ge(a,o).catch(d=>{p.logWarn(`Failed to send completion message to tab ${a}:`,d)})):ge(a,o).catch(d=>{p.logWarn(`Failed to send progress/status message to tab ${a}:`,d)})}function cr(a,t){const e=[];for(let r=0;r<a.length;r+=t){const i=a.slice(r,r+t);e.push(i)}return e}const at=new RegExp("OAuth (.+)"),dr=new RegExp("/me/followings/(\\d+)");ut(a=>{if(_e()){const r=v("oauth-token");if(a.requestHeaders){for(let i=0;i<a.requestHeaders.length;i++)if(a.requestHeaders[i].name.toLowerCase()==="authorization"){const n=a.requestHeaders[i].value,s=at.exec(n);s&&s.length>=2&&s[1]!==r&&(p.logInfo("Sniffed and storing OAuth token from request header (all envs)."),L("oauth-token",s[1]));break}}return{}}let t=!1;const e=v("oauth-token");if(a.requestHeaders){for(let r=0;r<a.requestHeaders.length;r++)if(a.requestHeaders[r].name.toLowerCase()==="authorization"){t=!0;const i=a.requestHeaders[r].value,n=at.exec(i);n&&n.length>=2&&n[1]!==e&&(p.logInfo("Sniffed and storing OAuth token (Firefox/non-DNR)."),L("oauth-token",n[1]));break}if(!t&&e)return a.requestHeaders.push({name:"Authorization",value:"OAuth "+e}),{requestHeaders:a.requestHeaders}}return{}},["*://api-v2.soundcloud.com/*"],["blocking","requestHeaders"]),ft(a=>{const t=new URL(a.url);if(t.pathname==="/connect/session"&&v("oauth-token")===null)p.logInfo("User logged in - clearing potentially stale token."),L("oauth-token",void 0);else if(t.pathname==="/sign-out")p.logInfo("User logged out"),L("oauth-token",null),L("user-id",null),L("followed-artists",[]);else if(t.pathname.startsWith("/me/followings/")){const e=dr.exec(t.pathname);if(e&&e.length===2){const r=+e[1];if(r){let i=v("followed-artists")||[];a.method==="POST"?i.includes(r)||i.push(r):a.method==="DELETE"&&(i=i.filter(n=>n!==r)),L("followed-artists",i)}}}else{const e=t.searchParams.get("client_id");if(e){const r=v("client-id");e!==r&&(p.logInfo(`Found new client_id: ${e}. Storing it.`),L("client-id",e))}else if(!_e()){const r=v("client-id");if(r)return p.logDebug(`Adding ClientId to ${a.url} via redirect (Firefox/non-DNR)`),t.searchParams.append("client_id",r),{redirectUrl:t.toString()}}}return{}},["*://api-v2.soundcloud.com/*","*://api-auth.soundcloud.com/*"],["blocking"]);const it=async a=>{if(!a){L("user-id",null),p.logInfo("OAuth token cleared, user ID cleared.");return}const t=await oe.getCurrentUser();if(!t){p.logError("Failed to fetch currently logged in user (after token change/init)");return}L("user-id",t.id),p.logInfo("Logged in as",t.username);const e=await oe.getFollowedArtistIds(t.id);if(!e){p.logError("Failed to fetch ids of followed artists");return}L("followed-artists",e)};Ee("oauth-token",async a=>{await tt(a),await it(a)}),Ee("client-id",async a=>{p.logInfo(`client-id config changed to: ${a}. Updating DNR rule.`),await rt(a)});
