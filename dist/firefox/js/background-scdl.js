import{L as x,a as X}from"./logger-scdl-C1suKzoJ.js";import{s as de,g as lt,c as Oe,d as Pe,a as we,i as gt,b as dt,o as ct,e as ut,f as ft,h as ht,j as mt,u as Ne}from"./compatibilityStubs-scdl-DBF9jRnU.js";import{c as Le,l as Ue,a as pt,g as $,s as L,X as Ce,b as xe,d as wt,e as te,f as Be,r as Ee}from"./config-scdl-C_FU04Dg.js";class ce extends Error{constructor(t){super(t),this.name="RateLimitError"}}class Xe{baseUrl="https://api-v2.soundcloud.com";logger;globalBackoffUntil=null;globalBackoffDurationMs=61*1e3;constructor(){this.logger=x.create("SoundCloudApi")}async retryWithBackoff(t,e=3,r=2e3,s){if(this.globalBackoffUntil&&Date.now()<this.globalBackoffUntil){const u=this.globalBackoffUntil-Date.now();this.logger.logWarn(`[Global Backoff] Active. Waiting for ${Math.ceil(u/1e3)}s before proceeding with ${s||"operation"}.`),await new Promise(d=>setTimeout(d,u)),this.logger.logInfo(`[Global Backoff] Wait completed for ${s||"operation"}. Optimistically clearing global trigger.`),this.globalBackoffUntil=null}let n=0,o=r;for(;n<=e;)try{if(n>0&&this.globalBackoffUntil&&Date.now()<this.globalBackoffUntil){const d=this.globalBackoffUntil-Date.now();this.logger.logWarn(`[Global Backoff] Re-activated during retries. Waiting for ${Math.ceil(d/1e3)}s for ${s||"operation"}.`),await new Promise(f=>setTimeout(f,d)),this.logger.logInfo(`[Global Backoff] Secondary wait completed for ${s||"operation"}. Optimistically clearing global trigger.`),this.globalBackoffUntil=null}this.logger.logDebug(`[Retry] Attempt ${n+1}/${e+1} for ${s||"operation"}`);const u=await t();return this.globalBackoffUntil!==null&&(this.logger.logInfo(`[${s||"operation"}] Succeeded. Clearing active global backoff trigger.`),this.globalBackoffUntil=null),u}catch(u){if(u instanceof ce)if(n<e)n++,this.logger.logWarn(`[Retry] Rate limit hit for ${s||"operation"}. Retrying in ${o/1e3}s... (Attempt ${n+1}/${e+1})`),await new Promise(d=>setTimeout(d,o)),o=Math.min(o*2,3e4);else throw this.logger.logError(`[Retry] Failed for ${s||"operation"} after ${n+1} attempts due to persistent rate limit. Activating global backoff.`),this.globalBackoffUntil=Date.now()+this.globalBackoffDurationMs,this.logger.logWarn(`[Global Backoff] Activated for ${this.globalBackoffDurationMs/1e3}s due to persistent rate limiting on ${s||"operation"}.`),u;else throw this.logger.logError(`[Retry] Failed for ${s||"operation"} with non-retryable or unexpected error after ${n+1} attempts:`,u.message||u),u}const i=`[Retry] Exhausted retries for ${s||"operation"} without explicit success or failure handling.`;throw this.logger.logError(i),new Error(i)}resolveUrl(t){const e=`${this.baseUrl}/resolve?url=${t}`;return this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`resolveUrl: ${t}`)}getCurrentUser(){const t=`${this.baseUrl}/me`;return this.retryWithBackoff(()=>this._fetchJsonInternal(t),3,2e3,"getCurrentUser")}async getFollowedArtistIds(t){const e=`${this.baseUrl}/users/${t}/followings/ids`,r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getFollowedArtistIds: ${t}`);return!r||!r.collection?null:r.collection}async getTracks(t){const e=`${this.baseUrl}/tracks?ids=${t.join(",")}`;this.logger.logInfo("Fetching tracks with Ids",{trackIds:t});const r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getTracks: ${t.length} IDs`);return t.reduce((s,n,o)=>(s[n]=r[o],s),{})}async getStreamDetails(t){const e=await this.retryWithBackoff(()=>this._fetchJsonInternal(t),3,2e3,`getStreamDetails: ${t}`);if(!e||!e.url)return this.logger.logError("Invalid stream response",e),null;let r,s=!1;const n=/(?:(\w{3,4})\/playlist)?\.(\w{3,4})(?:$|\?)/.exec(e.url);return n.length>=2&&(n[2]==="m3u8"?(r=n[1],s=!0):r=n[2]),{url:e.url,extension:r,hls:s}}async getOriginalDownloadUrl(t){const e=`${this.baseUrl}/tracks/${t}/download`;this.logger.logInfo("Getting original download URL for track with Id",t);try{const r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getOriginalDownloadUrl: ${t}`);return!r||!r.redirectUri?(this.logger.logError("Invalid original file response",r),null):r.redirectUri}catch(r){return this.logger.logError(`Failed to get original download URL for track ${t} after retries`,r),null}}async downloadArtwork(t){const[e]=await this.retryWithBackoff(()=>this._fetchArrayBufferInternal(t),3,2e3,`downloadArtwork: ${t}`);return e}downloadStream(t,e){return this.retryWithBackoff(()=>this._fetchArrayBufferInternal(t,e),3,1e3,`downloadStream: ${t}`)}async _fetchArrayBufferInternal(t,e){try{const r=await fetch(t);if(!r.ok){if(r.status===404)return this.logger.logDebug(`[fetchArrayBuffer] Resource not found (404) for ${t}`),[null,r.headers];if(r.status===429)throw this.logger.logWarn(`[fetchArrayBuffer] Rate limited (429) while fetching ${t}.`),new ce(`Rate limited (status 429) on ${t}`);const w=`[fetchArrayBuffer] HTTP error for ${t} - Status: ${r.status} ${r.statusText}`;throw new Error(w)}if(!r.body)throw this.logger.logError(`Response for ${t} has no body, despite response.ok being true.`),new Error(`Response for ${t} has no body.`);const s=r.headers.get("Content-Length"),n=s?parseInt(s,10):0;let o=0;const i=[],u=r.body.getReader();for(e&&n>0&&e(0);;){const{done:w,value:y}=await u.read();if(w)break;i.push(y),o+=y.byteLength,e&&n>0&&e(Math.round(o/n*100))}e&&e(100);const d=new ArrayBuffer(o),f=new Uint8Array(d);let p=0;for(const w of i)f.set(w,p),p+=w.byteLength;return o===0&&r.status===200&&this.logger.logWarn(`[fetchArrayBuffer] Fetched ${t} (Status: ${r.status}) but received an empty (0 bytes) buffer.`),[d,r.headers]}catch(r){throw this.logger.logError(`[fetchArrayBuffer] Generic error for ${t}:`,r),r instanceof ce?r:new Error(`Failed to fetch array buffer from ${t}: ${r instanceof Error?r.message:String(r)}`)}}async _fetchJsonInternal(t,e="GET",r){const s={Accept:"application/json"};e!=="GET"&&e!=="HEAD"&&(s["Content-Type"]="application/json");let n;try{this.logger.logDebug(`[API Fetch] Attempting ${e} to ${t}`),n=await fetch(t,{method:e,headers:s,body:r?JSON.stringify(r):void 0})}catch(o){throw this.logger.logError(`[API Fetch] Network error for ${e} ${t}: ${o.message}`,o),new Error(`Network error: ${o.message}`)}if(n.ok){const o=await n.text();if(!o&&(n.status===204||n.status===202))return this.logger.logDebug(`[API Fetch] Successful ${e} to ${t} with status ${n.status} (No Content).`),null;if(!o)return this.logger.logWarn(`[API Fetch] Successful ${e} to ${t} with status ${n.status} but received an empty response body.`),null;try{return JSON.parse(o)}catch(i){throw this.logger.logError(`[API Fetch] Successful ${e} to ${t} (status ${n.status}) but failed to parse JSON response: ${i.message}. Response text: "${o.substring(0,100)}"`),new Error(`JSON parsing error: ${i.message}`)}}else if(n.status===429){const o=`Rate limited (429) while fetching ${e} ${t}.`;throw this.logger.logWarn(o),new ce(o)}else{const o=await n.text().catch(()=>`Failed to read error response body for status ${n.status}`),i=`HTTP error ${n.status} ${n.statusText} for ${e} ${t}. Response: ${o.substring(0,200)}`;throw this.logger.logError(i),new Error(i)}}}const G=8,ie=16,He=G+ie;class We{_metadataPath=["moov","udta","meta","ilst"];_buffer;_bufferView;_atoms=[];_loggedErrors=new Set;_hasValidStructure=!1;_logger;get hasValidMp4Structure(){return this._hasValidStructure}_logError(t){this._loggedErrors.has(t)||(this._logger.logDebug(`MP4 metadata: ${t}`),this._loggedErrors.add(t))}constructor(t){this._buffer=t,this._bufferView=new DataView(t),this._logger=x.create("MP4TagWriterInternals",X.Debug)}parse(){if(!this._buffer)throw new Error("Buffer can not be null");if(this._atoms.length>0)throw new Error("Buffer already parsed");this._logger.logDebug("Starting MP4 parse...");let t=0,e,r=[];for(;;){if(e=this._readAtom(t),!e||e.length<1||t>=this._buffer.byteLength){t<this._buffer.byteLength?this._logger.logDebug(`Parsing stopped: _readAtom returned invalid atom or zero length at offset ${t}.`):this._logger.logDebug(`Parsing stopped: Reached end of buffer at offset ${t}.`);break}if(r.push({name:e.name||"undefined",length:e.length,offset:e.offset}),this._atoms.push(e),t=e.offset+e.length,t<=e.offset){this._logger.logError(`Parsing stopped: Invalid offset progression. Current offset ${e.offset}, next offset calculated as ${t}.`);break}}if(this._logger.logDebug(`Finished MP4 parse. Found ${this._atoms.length} top-level atoms.`),this._logger.logDebug(`Top-level atoms summary: ${JSON.stringify(r)}`),this._atoms.length<1){this._logError("Buffer could not be parsed - no valid top-level atoms found."),this._hasValidStructure=!1;return}const s=this._atoms.find(n=>n.name?.toLowerCase()==="moov");this._hasValidStructure=!!s,this._hasValidStructure?this._logger.logDebug("File structure check passed: Found top-level 'moov' atom (case-insensitive check)."):this._logError("File structure check failed: Did not find a top-level 'moov' atom (checked case-insensitively).")}setDuration(t){try{if(!this._hasValidStructure){this._logError("Cannot set duration - file doesn't have a valid MP4 structure");return}const e=this._findAtom(this._atoms,["moov","mvhd"]);if(!e)throw new Error("'mvhd' atom could not be found");this._bufferView.setUint32(e.offset+G+16,t)}catch(e){this._logError(`Failed to set duration: ${e.message}`)}}addMetadataAtom(t,e){try{if(!this._hasValidStructure){this._logError(`Cannot add ${t} metadata - file doesn't have a valid MP4 structure`);return}if(t.length>4||t.length<1)throw new Error(`Unsupported atom name: '${t}'`);let r;if(e instanceof ArrayBuffer)r=e;else if(typeof e=="string")r=this._getBufferFromString(e);else if(typeof e=="number")r=new ArrayBuffer(4),new DataView(r).setUint32(0,e);else throw new Error(`Unsupported data: '${e}'`);const s={name:t,length:He+r.byteLength,data:r};this._insertAtom(s,this._metadataPath)}catch(r){this._logError(`Failed to add metadata atom '${t}': ${r.message}`)}}getBuffer(){const t=[];let e=0;for(const r of this._atoms){if(!r.children){const o=this._buffer.slice(r.offset,r.offset+r.length);t.push(o),e++;continue}r.length=G;const s=[{parent:r,offset:e,childIndex:0}];let n=0;for(;;){const{parent:o,offset:i,childIndex:u}=s[n];if(u>=o.children.length){n--,s.pop();let f=G;o.name==="meta"?(o.length+=4,f+=4):o.name==="stsd"&&(o.length+=8,f+=8),this._bufferView.setUint32(o.offset,o.length);const p=this._buffer.slice(o.offset,o.offset+f);if(t.splice(i,0,p),n<0)break;const w=s[n].parent;w.length+=o.length,s[n].childIndex++;continue}const d=o.children[u];if(d.children){d.length=G,s.push({parent:d,offset:e,childIndex:0}),n++;continue}else if(d.data){const f=this._getHeaderBufferFromAtom(d);t.push(f),t.push(d.data)}else{const f=this._buffer.slice(d.offset,d.offset+d.length);t.push(f)}e++,o.length+=d.length,s[n].childIndex++}}return this._bufferView=null,this._buffer=null,this._atoms=[],Le(t)}_insertAtom(t,e){try{if(this._logger.logDebug(`Attempting to insert atom '${t.name}' at path '${e.join(" > ")}'.`),!e||e[e.length-1]!=="ilst"){this._logError(`Cannot insert tag atom '${t.name}': Path does not end in 'ilst'.`);return}const r=this._createMetadataPath();if(!r){this._logError(`Cannot insert atom '${t.name}': Failed to find or create parent 'ilst' atom.`);return}r.children===void 0&&(r.children=this._readChildAtoms(r),this._logger.logDebug(`Loaded children for '${r.name}' in _insertAtom.`));const s=r.children.findIndex(o=>o.name===t.name);s!==-1&&(this._logger.logDebug(`Replacing existing atom '${t.name}' in '${r.name}'.`),r.children.splice(s,1));let n=r.offset+this._getAtomHeaderLength(r);if(r.children.length>0){const o=r.children[r.children.length-1];n=o.offset+o.length}t.offset=n,r.children.push(t),this._logger.logDebug(`Successfully prepared atom '${t.name}' for insertion into '${r.name}'.`)}catch(r){this._logError(`Error during _insertAtom for '${t.name}': ${r.message}`)}}_findAtom(t,e){if(!e||e.length<1)throw new Error("Path can not be empty");const r=[...e],s=r.shift();this._logger.logDebug(`_findAtom: Searching for '${s}' in ${t.length} atoms. Remaining path: [${r.join(",")}]`);const n=t.find(o=>o.name===s);return n?(this._logger.logDebug(`_findAtom: Found '${n.name}' (length: ${n.length}, offset: ${n.offset})`),r.length<1?(this._logger.logDebug(`_findAtom: Path complete. Returning '${n.name}'.`),n.children===void 0&&(this._logger.logDebug(`_findAtom: Reading children for final element '${n.name}' before returning.`),n.children=this._readChildAtoms(n)),n):(n.children===void 0&&(this._logger.logDebug(`_findAtom: Reading children for '${n.name}' to continue traversal.`),n.children=this._readChildAtoms(n)),!n.children||n.children.length<1?(this._logger.logDebug(`_findAtom: '${n.name}' has no children to continue search for [${r.join(",")}]`),null):this._findAtom(n.children,r))):(this._logger.logDebug(`_findAtom: '${s}' not found.`),null)}_readChildAtoms(t){const e=[];this._logger.logDebug(`_readChildAtoms: Reading children for parent '${t.name}' (length: ${t.length}, offset: ${t.offset})`);const r=t.offset+t.length;let s=t.offset+G;t.name==="meta"?s+=4:t.name==="stsd"?s+=8:t.name==="ilst"?this._logger.logDebug(`_readChildAtoms: Parent is '${t.name}', standard child offset: ${s}`):t.name&&(t.name==="\xA9nam"||t.name==="\xA9ART"||t.name==="\xA9alb"||t.name==="\xA9day"||t.name==="trkn"||t.name==="scid"||t.name==="covr"||t.name==="\xA9too")&&this._logger.logDebug(`_readChildAtoms: Parent is item atom '${t.name}', standard child offset: ${s}`);let n=0;for(;;){if(s>=r){this._logger.logDebug(`_readChildAtoms: Reached end of parent '${t.name}' at offset ${s}. Found ${n} children.`);break}const o=this._readAtom(s);if(n++,this._logger.logDebug(`_readChildAtoms: For parent '${t.name}', read potential child ${n}: '${o.name||"?"}' (length: ${o.length}, offset: ${o.offset})`),!o||o.length<1){this._logger.logWarn(`_readChildAtoms: Invalid child atom or zero length for parent '${t.name}' at offset ${s}. Stopping child read.`);break}if(o.offset+o.length>r){this._logger.logWarn(`_readChildAtoms: Child atom '${o.name}' (offset ${o.offset}, length ${o.length}) exceeds parent '${t.name}' (ends at ${r}). Stopping.`);break}if(e.push(o),s=o.offset+o.length,s<=o.offset){this._logger.logError(`_readChildAtoms: Invalid offset progression for parent '${t.name}'. Child offset ${o.offset}, next offset ${s}. Stopping.`);break}}return this._logger.logDebug(`_readChildAtoms: Finished reading for parent '${t.name}'. Total children found: ${e.length}`),e}_readAtom(t){const e=t,r=t+G,s=this._buffer.slice(e,r);if(s.byteLength<G)return{length:s.byteLength,offset:t};const n=new DataView(s);let o=n.getUint32(0,!1),i="";for(let u=0;u<4;u++)i+=String.fromCharCode(n.getUint8(4+u));return{name:i,length:o,offset:t}}_getHeaderBufferFromAtom(t){if(!t||t.length<1||!t.name||!t.data)throw new Error("Can not compute header buffer for this atom");const e=new ArrayBuffer(He),r=new DataView(e);r.setUint32(0,t.length);const s=this._getCharCodes(t.name);for(let o=0;o<s.length;o++)r.setUint8(4+o,s[o]);r.setUint32(8,ie+t.data.byteLength);const n=this._getCharCodes("data");for(let o=0;o<n.length;o++)r.setUint8(12+o,n[o]);return r.setUint32(16,this._getFlags(t.name)),e}_getBufferFromString(t){const e=new ArrayBuffer(t.length),r=new DataView(e),s=this._getCharCodes(t);for(let n=0;n<s.length;n++)r.setUint8(n,s[n]);return e}_getCharCodes(t){const e=[];for(let r=0;r<t.length;r++)e.push(t.charCodeAt(r));return e}_getFlags(t){switch(t){case"covr":return 13;case"trkn":case"disk":return 0;case"tmpo":case"cpil":case"rtng":return 21;default:return 1}}_createMetadataPath(){try{this._logger.logDebug("Attempting to ensure metadata path moov > udta > meta > ilst exists.");const t=this._findAtom(this._atoms,["moov"]);if(!t)return this._logError("Cannot create metadata path: Required 'moov' atom not found."),null;t.children===void 0&&(t.children=this._readChildAtoms(t));let e=t;const r=["udta","meta","ilst"];for(const s of r){let n=this._findAtom(e.children,[s]);if(n)this._logger.logDebug(`Found existing '${s}' atom.`),n.children===void 0&&(n.children=this._readChildAtoms(n));else{this._logger.logDebug(`Creating missing '${s}' atom.`);let o=e.offset+this._getAtomHeaderLength(e);if(e.children.length>0){const u=e.children[e.children.length-1];o=u.offset+u.length}const i=this._getAtomHeaderLength({name:s});n={name:s,length:i,offset:o,children:[]},e.children.push(n),this._logger.logDebug(`Created '${s}' atom.`)}e=n}return this._logger.logDebug("Metadata path creation/verification successful. Returning 'ilst' atom."),e}catch(t){return this._logError(`Failed during _createMetadataPath: ${t.message}`),null}}_getAtomHeaderLength(t){let e=G;return t.name==="meta"?e+=4:t.name==="stsd"&&(e+=8),e}findAndReadTextAtomData(t){try{const e=this._findAtom(this._atoms,t);if(e&&e.children&&e.children.length>0){const r=e.children.find(s=>s.name==="data");if(r){const s=r.offset+ie,n=r.length-ie;if(n>0&&this._buffer&&s+n<=this._buffer.byteLength){const o=this._buffer.slice(s,s+n);return new TextDecoder().decode(o)}else return this._logError(`Invalid data length or buffer bounds for atom at path ${t.join(" > ")}. Data atom length: ${r.length}, Header: ${ie}`),null}else return this._logError(`No 'data' child atom found for atom at path ${t.join(" > ")}`),null}else this._logError(`Target atom not found or has no children at path ${t.join(" > ")}`);return null}catch(e){return this._logError(`Error finding or reading text atom at path ${t.join(" > ")}: ${e.message}`),null}}}class S{_originalBuffer;_mp4;_hasValidMp4=!1;static _loggedErrors=new Set;static _logger=x.create("MP4TagWriter",X.Debug);static _logError(t){S._loggedErrors.has(t)||(S._logger.logDebug(`MP4 metadata: ${t}`),S._loggedErrors.add(t))}constructor(t){try{this._originalBuffer=t.slice(0),S._logger.logDebug(`Creating Mp4TagWriter with buffer of size: ${this._originalBuffer.byteLength}`);try{this._mp4=new We(this._originalBuffer),this._mp4.parse(),this._hasValidMp4=this._mp4.hasValidMp4Structure,this._hasValidMp4?S._logger.logDebug("MP4 structure validation passed. TagWriter ready for use."):S._logError("MP4 structure validation failed. Tags will not be applied but original audio will still be saved.")}catch(e){this._hasValidMp4=!1,S._logError(`Failed to initialize MP4 parser: ${e.message}`)}}catch(e){S._logError(`Mp4TagWriter constructor error: ${e.message}`),this._originalBuffer=new ArrayBuffer(0),this._hasValidMp4=!1}}setTitle(t){try{if(!t)throw new Error("Invalid value for title");this._mp4.addMetadataAtom("\xA9nam",t)}catch(e){S._logError(`Failed to set title: ${e.message}`)}}setArtists(t){try{if(!t||t.length<1)throw new Error("Invalid value for artists");this._mp4.addMetadataAtom("\xA9ART",t.join(", "))}catch(e){S._logError(`Failed to set artists: ${e.message}`)}}setAlbum(t){try{if(!t)throw new Error("Invalid value for album");this._mp4.addMetadataAtom("\xA9alb",t)}catch(e){S._logError(`Failed to set album: ${e.message}`)}}setComment(t){try{if(!t)throw new Error("Invalid value for comment");this._mp4.addMetadataAtom("\xA9cmt",t)}catch(e){S._logError(`Failed to set comment: ${e.message}`)}}setTrackNumber(t){try{if(t<1||t>32767)throw new Error("Invalid value for trackNumber");this._mp4.addMetadataAtom("trkn",t)}catch(e){S._logError(`Failed to set track number: ${e.message}`)}}setYear(t){try{if(t<1)throw new Error("Invalid value for year");this._mp4.addMetadataAtom("\xA9day",t.toString())}catch(e){S._logError(`Failed to set year: ${e.message}`)}}setGrouping(t){try{if(!t)throw new Error("Invalid value for grouping");this._mp4.addMetadataAtom("\xA9grp",t)}catch(e){S._logError(`Failed to set grouping: ${e.message}`)}}setArtwork(t){try{if(!t||t.byteLength<1)throw new Error("Invalid value for artworkBuffer");this._mp4.addMetadataAtom("covr",t)}catch(e){S._logError(`Failed to set artwork: ${e.message}`)}}setSoundCloudTrackId(t){if(!this._hasValidMp4){S._logError("Cannot set SoundCloud Track ID - MP4 structure is invalid or not parsed.");return}if(!t){S._logError("Invalid value for SoundCloud Track ID");return}S._logger.logDebug(`[Mp4TagWriter] Attempting to set SoundCloudTrackID (scid): ${t}`),this._mp4.addMetadataAtom("scid",t)}setDuration(t){try{if(t<1)throw new Error("Invalid value for duration");this._mp4.setDuration(t)}catch(e){S._logError(`Failed to set duration: ${e.message}`)}}getBuffer(){try{if(!this._originalBuffer||this._originalBuffer.byteLength===0)throw new Error("Original buffer is missing or empty");if(!this._mp4||!this._hasValidMp4)return S._logError("MP4 structure check failed. Returning original buffer without applying tags."),Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:"Invalid MP4 structure for tagging."});let t;try{if(t=this._mp4.getBuffer(),!t||t.byteLength===0)throw new Error("Processed buffer is empty or null");t=t.slice(0)}catch(s){return S._logError(`Failed to get processed buffer: ${s.message}`),Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:`Failed to process MP4 buffer: ${s.message}`})}let e=!0,r;return t.byteLength!==this._originalBuffer.byteLength&&(e=!0,r=`Successfully applied tags (original: ${this._originalBuffer.byteLength}, new: ${t.byteLength})`),Promise.resolve({buffer:t,tagsApplied:e,message:r})}catch(t){const e=`Failed to get processed buffer: ${t.message}. Using original buffer as fallback.`;S._logError(e);try{return Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:e})}catch(r){return S._logError(`CRITICAL: Failed to create copy of original buffer: ${r.message}`),Promise.resolve({buffer:new ArrayBuffer(0),tagsApplied:!1,message:`CRITICAL ERROR: ${e} + ${r.message}`})}}}}const Et="DOWNLOAD_SET",bt="DOWNLOAD",yt="DOWNLOAD_SET_RANGE",Tt="PAUSE_DOWNLOAD",It="RESUME_DOWNLOAD",be="PAUSE_ALL_DOWNLOADS",ye="RESUME_ALL_DOWNLOADS",Te="GET_GLOBAL_PAUSE_STATE",Ie="GET_QUEUE_DATA",ue="GET_EXTENSION_CONFIG",Ge={},I=x.create("MessageHandler",X.Debug);async function $t(a,t){let e={};try{e=JSON.parse(JSON.stringify(a))}catch{e={errorParsingMessage:!0,rawMessage:String(a)}}I.logDebug("[MessageHandler DEBUG] Received message:",e);const r=[ue,Ie,be,ye,Te,"EXTRACT_SCID_FROM_M4A","RESTORE_HISTORY_FROM_IDS"];(!a||a.downloadId===void 0&&a.type!==void 0&&!r.includes(a.type))&&I.logError(`CRITICAL: MessageHandler received message with type ${a.type} that requires a downloadId, but it was missing!`,e);const s=t.tab?.id,{downloadId:n,url:o,type:i}=a,u=[ue,Ie,be,ye,Te];if(!s&&i&&!u.includes(i))return I.logWarn(`Message type ${i} received without a valid tab ID and is not allowed.`,{sender:t,message:a}),{error:`No valid tab ID found for message type ${i}`};if(i===ue){I.logDebug(`[MessageHandler] Received GET_EXTENSION_CONFIG request from tab ${s}`);try{const d=await Ue(!1),f={};for(const p of pt)d[p].secret||(f[p]={value:d[p].value});return I.logDebug("[MessageHandler] Sending non-secret configuration to content script:",f),Promise.resolve(f)}catch(d){return I.logError("[MessageHandler] Error loading or preparing configuration for content script:",d),Promise.reject({error:"Failed to retrieve extension configuration."})}}if(i&&!u.includes(i)&&!s)return I.logError(`CRITICAL: Message type ${i} requires a tabId, but it was missing after initial checks.`,{sender:t,message:a}),{error:`Missing tab ID for message type ${i}`};if(i===bt||i===Et||i===yt){if(!s)return I.logError(`CRITICAL: Download operation ${i} missing tabId.`),{error:"Download operations require a tabId."};I.logInfo(`[MessageHandler] Queuing request: ${i} for URL: ${o} with ID: ${n}`);const d={id:n,type:i,url:o,originalMessage:a,status:"pending",tabId:s,addedAt:Date.now()};O.push(d),await H(),I.logDebug(`[MessageHandler] Item added to queue and saved. Current queue size: ${O.length}`,d),Q();const f={success:!0,message:`${i} request added to queue.`,originalDownloadId:n};return de(s,f).then(()=>I.logInfo(`[MessageHandler TX Ack] Queued ACK for ${n} sent to tab ${s}.`)).catch(p=>I.logError(`[MessageHandler TX Ack] Queued ACK for ${n} FAILED to send to tab ${s}:`,p)),ne(),Promise.resolve(f)}else{if(i===be)return I.logInfo("[MessageHandler] Received PAUSE_ALL_DOWNLOADS request."),Object.keys(O).forEach(d=>{}),globalThis.isBackgroundGloballyPaused=!0,ne(),Promise.resolve({success:!0,message:"All downloads paused globally."});if(i===ye)return I.logInfo("[MessageHandler] Received RESUME_ALL_DOWNLOADS request."),globalThis.isBackgroundGloballyPaused=!1,ne(),Promise.resolve({success:!0,message:"All downloads resumed globally."});if(i===Te){I.logInfo("[MessageHandler] Received GET_GLOBAL_PAUSE_STATE request.");const d=!!globalThis.isBackgroundGloballyPaused;return Promise.resolve({isGloballyPaused:d})}else if(i==="EXTRACT_SCID_FROM_M4A"){if(!a.payload||!a.payload.buffer||!a.payload.filename)return I.logError("[MessageHandler] Invalid payload for EXTRACT_SCID_FROM_M4A:",a.payload),Promise.reject({error:"Invalid payload for SCID extraction."});const{filename:d,buffer:f}=a.payload;I.logInfo(`[MessageHandler] EXTRACT_SCID_FROM_M4A: Received buffer for ${d} (size: ${f.byteLength})`);try{const p=new We(f);if(p.parse(),!p.hasValidMp4Structure)return I.logWarn(`[MessageHandler] EXTRACT_SCID_FROM_M4A: File ${d} does not have a valid MP4 structure.`),Promise.resolve({error:`File ${d} is not a valid MP4.`});const w=["moov","udta","meta","ilst","scid"],y=p.findAndReadTextAtomData(w);return y?(I.logInfo(`[MessageHandler] EXTRACT_SCID_FROM_M4A: Extracted SCID '${y}' from ${d}`),Promise.resolve({trackId:y})):(I.logWarn(`[MessageHandler] EXTRACT_SCID_FROM_M4A: SCID atom not found or no data in ${d}`),Promise.resolve({error:`SCID not found in ${d}`}))}catch(p){return I.logError(`[MessageHandler] EXTRACT_SCID_FROM_M4A: Error parsing ${d}:`,p),Promise.resolve({error:`Error parsing MP4 file ${d}: ${p.message||p}`})}}else if(i==="RESTORE_HISTORY_FROM_IDS"){if(!a.payload||!Array.isArray(a.payload.trackIds))return I.logError("[MessageHandler] Invalid payload for RESTORE_HISTORY_FROM_IDS:",a.payload),Promise.reject({error:"Invalid payload for history restoration."});const{trackIds:d}=a.payload;if(I.logInfo(`[MessageHandler] RESTORE_HISTORY_FROM_IDS: Received ${d.length} track IDs to restore.`),d.length===0)return Promise.resolve({message:"No track IDs provided to restore."});try{const f=await $("track-download-history")||{};let p=0;return d.forEach(w=>{if(typeof w=="string"&&w.trim()!==""){const y=`track-${w}`;f[y]?I.logDebug(`[MessageHandler] RESTORE_HISTORY_FROM_IDS: Track ${w} already in history, skipping.`):(f[y]={filename:`Restored: TrackID ${w}`,timestamp:Date.now()},p++)}}),await L("track-download-history",f),I.logInfo(`[MessageHandler] RESTORE_HISTORY_FROM_IDS: Successfully restored ${p} new tracks to history.`),Promise.resolve({message:`Successfully restored ${p} new tracks out of ${d.length} to download history.`})}catch(f){return I.logError("[MessageHandler] RESTORE_HISTORY_FROM_IDS: Error accessing storage or processing IDs:",f),Promise.resolve({error:`Error restoring history: ${f.message||f}`})}}else if(i===Tt){if(!s)return{error:"Pause ops require tabId"};const d=a;return I.logInfo(`Received pause request for download: ${d.downloadId}`),Ge[d.downloadId]=!0,W(s,d.downloadId,void 0,void 0,"Paused"),{success:!0,action:"paused",downloadId:d.downloadId}}else if(i===It){if(!s)return{error:"Resume ops require tabId"};const d=a;I.logInfo(`Received resume request for download: ${d.downloadId}`),delete Ge[d.downloadId];const f=O.find(p=>p.id===d.downloadId);return f&&f.status==="pending"?I.logInfo(`Resume for pending item ${f.id}. Will be picked by processor.`):f&&f.status==="processing"&&I.logInfo(`Resume for actively processing item ${f.id}. Processor will handle.`),ne(),W(s,d.downloadId,void 0,void 0,"Resuming"),{success:!0,action:"resumed",downloadId:d.downloadId}}else{if(i===Ie)return I.logInfo("[MessageHandler] Received GET_QUEUE_DATA request (likely from popup)."),Promise.resolve(O);if(i!==ue)return I.logWarn(`[MessageHandler] Unknown message type received: ${i}`,a),Promise.reject({error:`Unknown message type: ${i}`})}}}var A;(function(a){a.LOAD="LOAD",a.EXEC="EXEC",a.FFPROBE="FFPROBE",a.WRITE_FILE="WRITE_FILE",a.READ_FILE="READ_FILE",a.DELETE_FILE="DELETE_FILE",a.RENAME="RENAME",a.CREATE_DIR="CREATE_DIR",a.LIST_DIR="LIST_DIR",a.DELETE_DIR="DELETE_DIR",a.ERROR="ERROR",a.DOWNLOAD="DOWNLOAD",a.PROGRESS="PROGRESS",a.LOG="LOG",a.MOUNT="MOUNT",a.UNMOUNT="UNMOUNT"})(A||(A={}));const At=(()=>{let a=0;return()=>a++})(),Dt=new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),Rt=new Error("called FFmpeg.terminate()");class kt{#t=null;#a={};#r={};#s=[];#n=[];loaded=!1;#o=()=>{this.#t&&(this.#t.onmessage=({data:{id:t,type:e,data:r}})=>{switch(e){case A.LOAD:this.loaded=!0,this.#a[t](r);break;case A.MOUNT:case A.UNMOUNT:case A.EXEC:case A.FFPROBE:case A.WRITE_FILE:case A.READ_FILE:case A.DELETE_FILE:case A.RENAME:case A.CREATE_DIR:case A.LIST_DIR:case A.DELETE_DIR:this.#a[t](r);break;case A.LOG:this.#s.forEach(s=>s(r));break;case A.PROGRESS:this.#n.forEach(s=>s(r));break;case A.ERROR:this.#r[t](r);break}delete this.#a[t],delete this.#r[t]})};#e=({type:t,data:e},r=[],s)=>this.#t?new Promise((n,o)=>{const i=At();this.#t&&this.#t.postMessage({id:i,type:t,data:e},r),this.#a[i]=n,this.#r[i]=o,s?.addEventListener("abort",()=>{o(new DOMException(`Message # ${i} was aborted`,"AbortError"))},{once:!0})}):Promise.reject(Dt);on(t,e){t==="log"?this.#s.push(e):t==="progress"&&this.#n.push(e)}off(t,e){t==="log"?this.#s=this.#s.filter(r=>r!==e):t==="progress"&&(this.#n=this.#n.filter(r=>r!==e))}load=({classWorkerURL:t,...e}={},{signal:r}={})=>(this.#t||(this.#t=t?new Worker(new URL(t,import.meta.url),{type:"module"}):new Worker(new URL("/assets/worker-BAOIWoxA.js",import.meta.url),{type:"module"}),this.#o()),this.#e({type:A.LOAD,data:e},void 0,r));exec=(t,e=-1,{signal:r}={})=>this.#e({type:A.EXEC,data:{args:t,timeout:e}},void 0,r);ffprobe=(t,e=-1,{signal:r}={})=>this.#e({type:A.FFPROBE,data:{args:t,timeout:e}},void 0,r);terminate=()=>{const t=Object.keys(this.#r);for(const e of t)this.#r[e](Rt),delete this.#r[e],delete this.#a[e];this.#t&&(this.#t.terminate(),this.#t=null,this.loaded=!1)};writeFile=(t,e,{signal:r}={})=>{const s=[];return e instanceof Uint8Array&&s.push(e.buffer),this.#e({type:A.WRITE_FILE,data:{path:t,data:e}},s,r)};mount=(t,e,r)=>{const s=[];return this.#e({type:A.MOUNT,data:{fsType:t,options:e,mountPoint:r}},s)};unmount=t=>{const e=[];return this.#e({type:A.UNMOUNT,data:{mountPoint:t}},e)};readFile=(t,e="binary",{signal:r}={})=>this.#e({type:A.READ_FILE,data:{path:t,encoding:e}},void 0,r);deleteFile=(t,{signal:e}={})=>this.#e({type:A.DELETE_FILE,data:{path:t}},void 0,e);rename=(t,e,{signal:r}={})=>this.#e({type:A.RENAME,data:{oldPath:t,newPath:e}},void 0,r);createDir=(t,{signal:e}={})=>this.#e({type:A.CREATE_DIR,data:{path:t}},void 0,e);listDir=(t,{signal:e}={})=>this.#e({type:A.LIST_DIR,data:{path:t}},void 0,e);deleteDir=(t,{signal:e}={})=>this.#e({type:A.DELETE_DIR,data:{path:t}},void 0,e)}var qe;(function(a){a.MEMFS="MEMFS",a.NODEFS="NODEFS",a.NODERAWFS="NODERAWFS",a.IDBFS="IDBFS",a.WORKERFS="WORKERFS",a.PROXYFS="PROXYFS"})(qe||(qe={}));const St=new Error("failed to get response body reader"),vt=new Error("failed to complete download"),Ft="Content-Length",_t=async(a,t)=>{const e=await fetch(a);let r;try{const s=parseInt(e.headers.get(Ft)||"-1"),n=e.body?.getReader();if(!n)throw St;const o=[];let i=0;for(;;){const{done:f,value:p}=await n.read(),w=p?p.length:0;if(f){if(s!=-1&&s!==i)throw vt;t&&t({url:a,total:s,received:i,delta:w,done:f});break}o.push(p),i+=w,t&&t({url:a,total:s,received:i,delta:w,done:f})}const u=new Uint8Array(i);let d=0;for(const f of o)u.set(f,d),d+=f.length;r=u.buffer}catch(s){console.log("failed to send download progress event: ",s),r=await e.arrayBuffer()}return r},$e=async(a,t,e=!1,r)=>{const s=e?await _t(a,r):await(await fetch(a)).arrayBuffer(),n=new Blob([s],{type:t});return URL.createObjectURL(n)},Mt=x.create("FFmpegInstance",X.Debug);async function je(a){const t=a?x.create(`FFmpegInstance:${a}`,X.Debug):Mt,e=new kt;e.on("log",({message:r})=>{r.startsWith("frame=")||t.logDebug(`[FFMPEG_WASM_LOG] ${r}`)}),t.logInfo("[FFMPEG_WASM] Initializing new FFmpeg.wasm instance from local files (using toBlobURL strategy)...");try{const r=lt("ffmpeg-core/");if(!r)return t.logError("[FFMPEG_WASM] Failed to get base URL for FFmpeg core files."),null;const s=r+"ffmpeg-core.js",n=r+"ffmpeg-core.wasm",o=r+"worker.js";t.logInfo(`[FFMPEG_WASM] Base URL for Blob: ${r}`),t.logInfo("[FFMPEG_WASM] Attempting to create Blob URLs for core files (including worker)...");const i=await $e(s,"text/javascript"),u=await $e(n,"application/wasm"),d=await $e(o,"text/javascript");return t.logInfo("[FFMPEG_WASM] Blob URLs created. Loading FFmpeg instance with worker..."),await e.load({coreURL:i,wasmURL:u,workerURL:d}),t.logInfo("[FFMPEG_WASM] FFmpeg.wasm instance loaded successfully via Blob URLs (worker enabled)."),e}catch(r){return t.logError("[FFMPEG_WASM] Failed to load FFmpeg.wasm instance via Blob URLs",r),null}}const k=x.create("FFmpegManager",X.Debug),Ot=Math.max(1,Math.min(Number($("maxConcurrentTrackDownloads"))||2,10)),fe=Ot;k.logInfo(`FFmpegManager initialized with MAX_CONCURRENT_OPERATIONS: ${fe}`);const q=[],he=[];let z=!1,j=null;async function Ye(){return z?Promise.resolve():j||(k.logInfo(`Initializing FFmpeg instance pool with size: ${fe}`),j=(async()=>{try{const a=[];for(let e=0;e<fe;e++)a.push(je(e));const t=await Promise.all(a);for(let e=0;e<t.length;e++){const r=t[e];r?q.push({id:e,instance:r,isAvailable:!0,isCompromised:!1}):k.logError(`Failed to load FFmpeg instance ${e} for the pool.`)}if(q.length===0&&fe>0)throw new Error("No FFmpeg instances could be initialized for the pool.");z=!0,k.logInfo(`FFmpeg instance pool initialized with ${q.length} instances.`)}catch(a){throw k.logError("Failed to initialize FFmpeg pool",a),z=!1,j=null,a}})(),j)}async function Pt(a,t){const{instance:e,id:r}=a,{taskId:s,inputBuffer:n,fileExtension:o,progressCallback:i,resolve:u,reject:d}=t,f=`input_${s}_${r}.${o||"mp4"}`,p=`output_remuxed_${s}_${r}.${o||"mp4"}`;k.logInfo(`[FFmpegManager] Instance ${r} starting remux for task ${s}: ${f} -> ${p}`);let w;try{let y;try{k.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Attempting inputBuffer.slice(0). Input buffer byteLength: ${n?.byteLength}`);const D=n.slice(0);k.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Successfully sliced buffer. Slice byteLength: ${D?.byteLength}. Attempting new Uint8Array().`),y=new Uint8Array(D),k.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Created Uint8Array with byteLength: ${y?.byteLength}. About to call instance.writeFile with ${f}.`)}catch(D){throw k.logError(`[FFmpegManager] Instance ${r}, Task ${s}: ERROR during buffer slice or Uint8Array creation:`,D),D}await e.writeFile(f,y),k.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Successfully called instance.writeFile with ${f}.`);const F=["-loglevel","debug","-i",f,"-c","copy",p];if(k.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: FFmpeg exec arguments:`,F),i){let D=-1;w=({progress:R})=>{const c=Math.round(R*100);c>D&&c<=100&&(i(c),D=c)},e.on("progress",w)}await e.exec(F);const l=await e.readFile(p);if(typeof l=="string")throw new Error("FFmpeg remux output was a string, expected Uint8Array");k.logInfo(`[FFmpegManager] Instance ${r} finished remux for task ${s}`),u(l.buffer.slice(0))}catch(y){k.logError(`[FFmpegManager] Instance ${r} FAILED remux for task ${s}`,y),a.isCompromised=!0,d(y)}finally{w&&typeof e.off=="function"&&e.off("progress",w);try{await e.deleteFile(f),await e.deleteFile(p)}catch(y){k.logWarn(`[FFmpegManager] Instance ${r} failed to cleanup files for task ${s}`,y),a.isCompromised=!0}}}function Ve(){if(!z||he.length===0)return;const a=q.find(e=>e.isAvailable);if(!a){k.logDebug("No FFmpeg instance available right now, queue length: "+he.length);return}const t=he.shift();t&&(a.isAvailable=!1,k.logDebug(`Assigning task ${t.taskId} to FFmpeg instance ${a.id}`),Pt(a,t).finally(async()=>{if(a.isCompromised){k.logWarn(`[FFmpegManager] Instance ${a.id} is compromised. Terminating and attempting to replace.`);try{await a.instance.terminate(),k.logInfo(`[FFmpegManager] Terminated compromised instance ${a.id}.`)}catch(s){k.logError(`[FFmpegManager] Error terminating compromised instance ${a.id}:`,s)}const e=q.findIndex(s=>s.id===a.id);e>-1&&q.splice(e,1),k.logInfo(`[FFmpegManager] Attempting to create new FFmpeg instance to replace ${a.id}.`);const r=await je(a.id);r?(q.push({id:a.id,instance:r,isAvailable:!0,isCompromised:!1}),k.logInfo(`[FFmpegManager] Successfully replaced instance ${a.id}. Pool size: ${q.length}`)):k.logError(`[FFmpegManager] Failed to create new FFmpeg instance to replace ${a.id}. Pool size will be reduced.`)}else a.isAvailable=!0,k.logDebug(`FFmpeg instance ${a.id} is now available.`);Ve()}))}async function Nt(a,t,e,r){return!z&&!j&&Ye().catch(s=>{k.logError("FFmpeg Pool Initialization failed lazily, subsequent requests might fail.",s)}),j&&await j,!z||q.length===0?Promise.reject(new Error("FFmpegManager: Pool not initialized or no instances available after init attempt.")):new Promise((s,n)=>{k.logDebug(`Task ${a} added to FFmpeg remux queue.`),he.push({taskId:a,inputBuffer:t,fileExtension:e,progressCallback:r,resolve:s,reject:n}),Ve()})}function Lt(){!z&&!j&&Ye().catch(a=>{k.logError("Pre-initialization of FFmpeg Pool failed.",a)})}function Qe(a){return String(a).split("").map(t=>t.charCodeAt(0))}function re(a){return new Uint8Array(Qe(a))}function Y(a){const t=new ArrayBuffer(2*a.length),e=new Uint8Array(t);return new Uint16Array(t).set(Qe(a)),e}function ze(a){return[a>>>24&255,a>>>16&255,a>>>8&255,a&255]}function Ke(a){return 11+a}function Ut(a,t,e,r){return 11+t+1+1+(r?2+2*(e+1):e+1)+a}function Ct(a){let t=0;return a.forEach(e=>{t+=2+2*e[0].length+2+2+2*e[1].length+2}),11+t}function xt(a,t){const e=2*t;let r=0;return a.forEach(s=>{r+=2+2*s[0].length+2+4}),18+e+2+r}class Bt{_setIntegerFrame(t,e){const r=parseInt(e,10);this.frames.push({name:t,value:r,size:Ke(r.toString().length)})}_setStringFrame(t,e){const r=e.toString();let s=13+2*r.length;t==="TDAT"&&(s=Ke(r.length)),this.frames.push({name:t,value:r,size:s})}_setPictureFrame(t,e,r,s){const n=function(i){if(!i||!i.length)return null;if(i[0]===255&&i[1]===216&&i[2]===255)return"image/jpeg";if(i[0]===137&&i[1]===80&&i[2]===78&&i[3]===71)return"image/png";if(i[0]===71&&i[1]===73&&i[2]===70)return"image/gif";if(i[8]===87&&i[9]===69&&i[10]===66&&i[11]===80)return"image/webp";const u=i[0]===73&&i[1]===73&&i[2]===42&&i[3]===0,d=i[0]===77&&i[1]===77&&i[2]===0&&i[3]===42;return u||d?"image/tiff":i[0]===66&&i[1]===77?"image/bmp":i[0]===0&&i[1]===0&&i[2]===1&&i[3]===0?"image/x-icon":null}(new Uint8Array(e)),o=r.toString();if(!n)throw new Error("Unknown picture MIME type");r||(s=!1),this.frames.push({name:"APIC",value:e,pictureType:t,mimeType:n,useUnicodeEncoding:s,description:o,size:Ut(e.byteLength,n.length,o.length,s)})}_setLyricsFrame(t,e,r){const s=t.split("").map(d=>d.charCodeAt(0)),n=e.toString(),o=r.toString();var i,u;this.frames.push({name:"USLT",value:o,language:s,description:n,size:(i=n.length,u=o.length,16+2*i+2+2+2*u)})}_setCommentFrame(t,e,r){const s=t.split("").map(d=>d.charCodeAt(0)),n=e.toString(),o=r.toString();var i,u;this.frames.push({name:"COMM",value:o,language:s,description:n,size:(i=n.length,u=o.length,16+2*i+2+2+2*u)})}_setPrivateFrame(t,e){const r=t.toString();var s,n;this.frames.push({name:"PRIV",value:e,id:r,size:(s=r.length,n=e.byteLength,10+s+1+n)})}_setUserStringFrame(t,e){const r=t.toString(),s=e.toString();var n,o;this.frames.push({name:"TXXX",description:r,value:s,size:(n=r.length,o=s.length,13+2*n+2+2+2*o)})}_setUrlLinkFrame(t,e){const r=e.toString();var s;this.frames.push({name:t,value:r,size:(s=r.length,10+s)})}_setPairedTextFrame(t,e){this.frames.push({name:t,value:e,size:Ct(e)})}_setSynchronisedLyricsFrame(t,e,r,s,n){const o=n.toString(),i=s.split("").map(u=>u.charCodeAt(0));this.frames.push({name:"SYLT",value:e,language:i,description:o,type:t,timestampFormat:r,size:xt(e,o.length)})}constructor(t){if(!t||typeof t!="object"||!("byteLength"in t))throw new Error("First argument should be an instance of ArrayBuffer or Buffer");this.arrayBuffer=t,this.padding=4096,this.frames=[],this.url=""}setFrame(t,e){switch(t){case"TPE1":case"TCOM":case"TCON":{if(!Array.isArray(e))throw new Error(`${t} frame value should be an array of strings`);const r=t==="TCON"?";":"/",s=e.join(r);this._setStringFrame(t,s);break}case"TLAN":case"TIT1":case"TIT2":case"TIT3":case"TALB":case"TPE2":case"TPE3":case"TPE4":case"TRCK":case"TPOS":case"TMED":case"TPUB":case"TCOP":case"TKEY":case"TEXT":case"TDAT":case"TCMP":case"TSRC":this._setStringFrame(t,e);break;case"TBPM":case"TLEN":case"TYER":this._setIntegerFrame(t,e);break;case"USLT":if(e.language=e.language||"eng",typeof e!="object"||!("description"in e)||!("lyrics"in e))throw new Error("USLT frame value should be an object with keys description and lyrics");if(e.language&&!e.language.match(/[a-z]{3}/i))throw new Error("Language must be coded following the ISO 639-2 standards");this._setLyricsFrame(e.language,e.description,e.lyrics);break;case"APIC":if(typeof e!="object"||!("type"in e)||!("data"in e)||!("description"in e))throw new Error("APIC frame value should be an object with keys type, data and description");if(e.type<0||e.type>20)throw new Error("Incorrect APIC frame picture type");this._setPictureFrame(e.type,e.data,e.description,!!e.useUnicodeEncoding);break;case"TXXX":if(typeof e!="object"||!("description"in e)||!("value"in e))throw new Error("TXXX frame value should be an object with keys description and value");this._setUserStringFrame(e.description,e.value);break;case"WCOM":case"WCOP":case"WOAF":case"WOAR":case"WOAS":case"WORS":case"WPAY":case"WPUB":this._setUrlLinkFrame(t,e);break;case"COMM":if(e.language=e.language||"eng",typeof e!="object"||!("description"in e)||!("text"in e))throw new Error("COMM frame value should be an object with keys description and text");if(e.language&&!e.language.match(/[a-z]{3}/i))throw new Error("Language must be coded following the ISO 639-2 standards");this._setCommentFrame(e.language,e.description,e.text);break;case"PRIV":if(typeof e!="object"||!("id"in e)||!("data"in e))throw new Error("PRIV frame value should be an object with keys id and data");this._setPrivateFrame(e.id,e.data);break;case"IPLS":if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Error("IPLS frame value should be an array of pairs");this._setPairedTextFrame(t,e);break;case"SYLT":if(typeof e!="object"||!("type"in e)||!("text"in e)||!("timestampFormat"in e))throw new Error("SYLT frame value should be an object with keys type, text and timestampFormat");if(!Array.isArray(e.text)||!Array.isArray(e.text[0]))throw new Error("SYLT frame text value should be an array of pairs");if(e.type<0||e.type>6)throw new Error("Incorrect SYLT frame content type");if(e.timestampFormat<1||e.timestampFormat>2)throw new Error("Incorrect SYLT frame time stamp format");e.language=e.language||"eng",e.description=e.description||"",this._setSynchronisedLyricsFrame(e.type,e.text,e.timestampFormat,e.language,e.description);break;default:throw new Error(`Unsupported frame ${t}`)}return this}removeTag(){if(this.arrayBuffer.byteLength<10)return;const t=new Uint8Array(this.arrayBuffer),e=t[3],r=((s=[t[6],t[7],t[8],t[9]])[0]<<21)+(s[1]<<14)+(s[2]<<7)+s[3]+10;var s,n;(n=t)[0]!==73||n[1]!==68||n[2]!==51||e<2||e>4||(this.arrayBuffer=new Uint8Array(t.subarray(r)).buffer)}addTag(){this.removeTag();const t=[255,254],e=10+this.frames.reduce((i,u)=>i+u.size,0)+this.padding,r=new ArrayBuffer(this.arrayBuffer.byteLength+e),s=new Uint8Array(r);let n=0,o=[];return o=[73,68,51,3],s.set(o,n),n+=o.length,n++,n++,o=function(i){return[i>>>21&127,i>>>14&127,i>>>7&127,i&127]}(e-10),s.set(o,n),n+=o.length,this.frames.forEach(i=>{switch(o=re(i.name),s.set(o,n),n+=o.length,o=ze(i.size-10),s.set(o,n),n+=o.length,n+=2,i.name){case"WCOM":case"WCOP":case"WOAF":case"WOAR":case"WOAS":case"WORS":case"WPAY":case"WPUB":o=re(i.value),s.set(o,n),n+=o.length;break;case"TPE1":case"TCOM":case"TCON":case"TLAN":case"TIT1":case"TIT2":case"TIT3":case"TALB":case"TPE2":case"TPE3":case"TPE4":case"TRCK":case"TPOS":case"TKEY":case"TMED":case"TPUB":case"TCOP":case"TEXT":case"TSRC":o=[1].concat(t),s.set(o,n),n+=o.length,o=Y(i.value),s.set(o,n),n+=o.length;break;case"TXXX":case"USLT":case"COMM":o=[1],i.name!=="USLT"&&i.name!=="COMM"||(o=o.concat(i.language)),o=o.concat(t),s.set(o,n),n+=o.length,o=Y(i.description),s.set(o,n),n+=o.length,o=[0,0].concat(t),s.set(o,n),n+=o.length,o=Y(i.value),s.set(o,n),n+=o.length;break;case"TBPM":case"TLEN":case"TDAT":case"TYER":n++,o=re(i.value),s.set(o,n),n+=o.length;break;case"PRIV":o=re(i.id),s.set(o,n),n+=o.length,n++,s.set(new Uint8Array(i.value),n),n+=i.value.byteLength;break;case"APIC":o=[i.useUnicodeEncoding?1:0],s.set(o,n),n+=o.length,o=re(i.mimeType),s.set(o,n),n+=o.length,o=[0,i.pictureType],s.set(o,n),n+=o.length,i.useUnicodeEncoding?(o=[].concat(t),s.set(o,n),n+=o.length,o=Y(i.description),s.set(o,n),n+=o.length,n+=2):(o=re(i.description),s.set(o,n),n+=o.length,n++),s.set(new Uint8Array(i.value),n),n+=i.value.byteLength;break;case"IPLS":o=[1],s.set(o,n),n+=o.length,i.value.forEach(u=>{o=[].concat(t),s.set(o,n),n+=o.length,o=Y(u[0].toString()),s.set(o,n),n+=o.length,o=[0,0].concat(t),s.set(o,n),n+=o.length,o=Y(u[1].toString()),s.set(o,n),n+=o.length,o=[0,0],s.set(o,n),n+=o.length});break;case"SYLT":o=[1].concat(i.language).concat(i.timestampFormat).concat(i.type),s.set(o,n),n+=o.length,o=[].concat(t),s.set(o,n),n+=o.length,o=Y(i.description),s.set(o,n),n+=o.length,n+=2,i.value.forEach(u=>{o=[].concat(t),s.set(o,n),n+=o.length,o=Y(u[0].toString()),s.set(o,n),n+=o.length,o=[0,0],s.set(o,n),n+=o.length,o=ze(u[1]),s.set(o,n),n+=o.length})}}),n+=this.padding,s.set(new Uint8Array(this.arrayBuffer),n),this.arrayBuffer=r,r}getBlob(){return new Blob([this.arrayBuffer],{type:"audio/mpeg"})}getURL(){return this.url||(this.url=URL.createObjectURL(this.getBlob())),this.url}revokeURL(){URL.revokeObjectURL(this.url)}}const Xt=x.create("Mp3TagWriter");class Ht{writer;constructor(t){this.writer=new Bt(t)}setTitle(t){if(!t)throw new Error("Invalid value for title");this.writer.setFrame("TIT2",t)}setArtists(t){if(!t||t.length<1)throw new Error("Invalid value for artists");this.writer.setFrame("TPE1",t)}setAlbum(t){if(!t)throw new Error("Invalid value for album");this.writer.setFrame("TALB",t)}setComment(t){if(!t)throw new Error("Invalid value for comment");this.writer.setFrame("COMM",{text:t,description:""})}setTrackNumber(t){if(t<1||t>32767)throw new Error("Invalid value for trackNumber");this.writer.setFrame("TRCK",t.toString())}setYear(t){if(t<1)throw new Error("Invalud value for year");this.writer.setFrame("TYER",t)}setGrouping(t){if(!t)throw new Error("Invalid value for grouping");this.writer.setFrame("TIT1",t)}setArtwork(t){if(!t||t.byteLength<1)throw new Error("Invalid value for artworkBuffer");this.writer.setFrame("APIC",{type:3,data:t,description:""})}setSoundCloudTrackId(t){if(!t)throw new Error("Invalid value for SoundCloud Track ID");Xt.logDebug(`Attempting to set SoundCloudTrackID: ${t}`),this.writer.setFrame("TXXX",{description:"SoundCloudTrackID",value:t})}getBuffer(){return this.writer.addTag(),this.writer.getBlob().arrayBuffer().then(t=>({buffer:t,tagsApplied:!0}))}}function Wt(a){if(typeof a!="string")throw new TypeError("Expected a string");return a.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}var Ae=(a=>(a[a.Main=0]="Main",a[a.Feature=1]="Feature",a[a.Remixer=2]="Remixer",a[a.Producer=3]="Producer",a))(Ae||{}),De=(a=>(a[a.Remix=0]="Remix",a[a.Flip=1]="Flip",a[a.Bootleg=2]="Bootleg",a[a.Mashup=3]="Mashup",a[a.Edit=4]="Edit",a))(De||{});function Gt(a){switch(a.toLowerCase().trim()){case"flip":return 1;case"bootleg":return 2;case"mashup":return 3;case"edit":return 4;case"remix":default:return 0}}function qt(a,t){return a.map((e,r)=>({data:e,index:r})).sort((e,r)=>e.data[t]<r.data[t]?-1:e.data[t]>r.data[t]?1:e.index-r.index).map(e=>e.data)}class U{constructor(t,e,r){this.title=t,this.username=e,this.userPermalink=r}static titleSeparators=["-","\u2013","\u2014","~"];static featureSeparators=["featuring","feat.","feat","ft."," ft ","w/"," w /"," w ","+"];static combiningFeatureSeparators=[...U.featureSeparators,", "," & "," x "];static remixIndicators=["remix","flip","bootleg","mashup","edit"];static producerIndicators=["prod. by ","prod by ","prod. ","p. ","prod "];static promotions=["free download","video in description","video in desc","vid in desc","Original Mix"];getArtists(){const t=this.preprocessTitle(this.title);let e=[];const r=this.splitByTitleSeparators(t,!0);e=e.concat(r.artistNames.map((d,f)=>({name:d,type:f===0?0:1})));const s=this.splitByProducer(r.title,!0);e=e.concat(s.artistNames.map(d=>({name:d,type:3})));const n=this.splitByRemix(s.title,!0);e=e.concat(n.artists);const o=this.splitByUnsafeProducers(n.title,!0);e=e.concat(o.artistNames.map(d=>({name:d,type:3})));const i=this.splitByFeatures(n.title,!0);if(e=e.concat(i.artistNames.map(d=>({name:d,type:1}))),!e.some(d=>d.type===0)){const d={name:this.sanitizeArtistName(this.username)||this.userPermalink,type:0};d.name&&(e.length>0?e=[d,...e]:e.push(d))}e=e.map(d=>this.removeTwitterHandle(d));const u=[];for(const d of e)u.some(f=>f.name==d.name)||u.push(d);return qt(u,"type")}getTitle(){let t=this.preprocessTitle(this.title);return t=this.splitByTitleSeparators(t,!1).title,t=this.splitByProducer(t,!1).title,t=this.splitByRemix(t,!1).title,t=this.splitByFeatures(t,!1).title,t=this.splitByUnsafeProducers(t,!1).title,this.sanitizeTitle(t)}removeTwitterHandle(t){t.name=t.name.replace(/^[@]+/,"");const e=/^([^(]+)\s?\(\s?@.+\)?$/.exec(t.name);return e&&e.length>1&&(t.name=e[1].trimEnd()),t}splitByTitleSeparators(t,e){let r=[];if(this.includes(t,U.titleSeparators)){const s=this.escapeRegexArray(U.titleSeparators),n=new RegExp(`^((.+)\\s[${s}]\\s)(.+)$`).exec(t);if(n&&n.length>0){const[o,i,u]=n;e&&(r=this.getArtistNames(u)),t=t.replace(i,"")}}return{artistNames:r,title:t}}splitByFeatures(t,e){let r=[];if(this.includes(t,U.featureSeparators)){const s=this.escapeRegexArray(U.featureSeparators).join("|"),n=new RegExp(`(?:${s})([^\\[\\]\\(\\)]+)`,"i").exec(t);if(n&&n.length>0){const[o,i]=n;e&&(r=this.getArtistNames(i)),t=t.replace(o,"")}}return{artistNames:r,title:t}}splitByProducer(t,e){let r=[];if(this.includes(t,U.producerIndicators)){const s=this.escapeRegexArray(U.producerIndicators).join("|"),n=new RegExp(`(?:${s})([^\\[\\]\\(\\)]+)`,"i").exec(t);if(n&&n.length>0){const[o,i]=n;e&&(r=this.getArtistNames(i)),t=t.replace(o,"")}}return{artistNames:r,title:t}}splitByUnsafeProducers(t,e){let r=[];const s=this.escapeRegexArray(U.featureSeparators).join("|"),n=new RegExp(`[\\(\\[](?!${s})(.+)[\\)\\]]`,"i").exec(t);if(n&&n.length>0){const[o,i]=n;e&&(r=this.getArtistNames(i)),t=t.replace(o,"")}return{artistNames:r,title:t}}splitByRemix(t,e){let r=[];if(this.includes(t,U.remixIndicators)){const s=this.escapeRegexArray(U.remixIndicators).join("|"),n=new RegExp(`[\\[\\(](.+)(${s})[\\]\\)]`,"i").exec(t);if(n&&n.length>0){const[o,i,u]=n;if(e){const d=this.getArtistNames(i),f=Gt(u);r=d.map(p=>({name:p,type:2,remixType:f}))}t=t.replace(o,"")}}return{artists:r,title:t}}getArtistNames(t){const e=this.escapeRegexArray(U.combiningFeatureSeparators).join("|"),r=new RegExp(`(.+)\\s?(${e})\\s?(.+)`,"i"),s=[];for(;;){const n=r.exec(t);if(!n){s.push(this.sanitizeArtistName(t));break}s.push(this.sanitizeArtistName(n[3])),t=n[1]}return s.reverse()}preprocessTitle(t){t=t.replace(/\+([+]+)/g,"+");const e=U.promotions.join("|"),r=new RegExp(`[\\[\\(]?\\s*(${e})\\s*[\\]\\)]?`,"i");return t.replace(r,"")}sanitizeArtistName(t){return this.removeNonAsciiCharacters(t).trim()}sanitizeTitle(t){let e=this.removeNonAsciiCharacters(t);return e=e.replace("()","").replace("[]",""),e.trim()}removeNonAsciiCharacters(t){return Ce.replace(t,Ce("[^\\p{L}\\p{N}\\p{Zs}\0-\x7F]","g"),"")}includes(t,e){const r=t.toLowerCase();return e.some(s=>r.includes(s))}escapeRegexArray(t){return t.map(e=>Wt(e))}}var Re=function(){function a(){this.listeners={}}var t=a.prototype;return t.on=function(e,r){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(r)},t.off=function(e,r){if(!this.listeners[e])return!1;var s=this.listeners[e].indexOf(r);return this.listeners[e]=this.listeners[e].slice(0),this.listeners[e].splice(s,1),s>-1},t.trigger=function(e){var r=this.listeners[e];if(r)if(arguments.length===2)for(var s=r.length,n=0;n<s;++n)r[n].call(this,arguments[1]);else for(var o=Array.prototype.slice.call(arguments,1),i=r.length,u=0;u<i;++u)r[u].apply(this,o)},t.dispose=function(){this.listeners={}},t.pipe=function(e){this.on("data",function(r){e.push(r)})},a}();function ae(){return ae=Object.assign?Object.assign.bind():function(a){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var r in e)({}).hasOwnProperty.call(e,r)&&(a[r]=e[r])}return a},ae.apply(null,arguments)}var ke,Je;function jt(){if(Je)return ke;Je=1;var a;return typeof window<"u"?a=window:typeof xe<"u"?a=xe:typeof self<"u"?a=self:a={},ke=a,ke}var Yt=jt();const Ze=wt(Yt);var Vt=function(a){return Ze.atob?Ze.atob(a):Buffer.from(a,"base64").toString("binary")};function Qt(a){for(var t=Vt(a),e=new Uint8Array(t.length),r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */class zt extends Re{constructor(){super(),this.buffer=""}push(t){let e;for(this.buffer+=t,e=this.buffer.indexOf(`
`);e>-1;e=this.buffer.indexOf(`
`))this.trigger("data",this.buffer.substring(0,e)),this.buffer=this.buffer.substring(e+1)}}const Kt="	",Se=function(a){const t=/([0-9.]*)?@?([0-9.]*)?/.exec(a||""),e={};return t[1]&&(e.length=parseInt(t[1],10)),t[2]&&(e.offset=parseInt(t[2],10)),e},Jt=function(){const a='(?:[^=]*)=(?:"[^"]*"|[^,]*)';return new RegExp("(?:^|,)("+a+")")},N=function(a){const t={};if(!a)return t;const e=a.split(Jt());let r=e.length,s;for(;r--;)e[r]!==""&&(s=/([^=]*)=(.*)/.exec(e[r]).slice(1),s[0]=s[0].replace(/^\s+|\s+$/g,""),s[1]=s[1].replace(/^\s+|\s+$/g,""),s[1]=s[1].replace(/^['"](.*)['"]$/g,"$1"),t[s[0]]=s[1]);return t},et=a=>{const t=a.split("x"),e={};return t[0]&&(e.width=parseInt(t[0],10)),t[1]&&(e.height=parseInt(t[1],10)),e};class Zt extends Re{constructor(){super(),this.customParsers=[],this.tagMappers=[]}push(t){let e,r;if(t=t.trim(),t.length!==0){if(t[0]!=="#"){this.trigger("data",{type:"uri",uri:t});return}this.tagMappers.reduce((s,n)=>{const o=n(t);return o===t?s:s.concat([o])},[t]).forEach(s=>{for(let n=0;n<this.customParsers.length;n++)if(this.customParsers[n].call(this,s))return;if(s.indexOf("#EXT")!==0){this.trigger("data",{type:"comment",text:s.slice(1)});return}if(s=s.replace("\r",""),e=/^#EXTM3U/.exec(s),e){this.trigger("data",{type:"tag",tagType:"m3u"});return}if(e=/^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(s),e){r={type:"tag",tagType:"inf"},e[1]&&(r.duration=parseFloat(e[1])),e[2]&&(r.title=e[2]),this.trigger("data",r);return}if(e=/^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"targetduration"},e[1]&&(r.duration=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-VERSION:([0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"version"},e[1]&&(r.version=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"media-sequence"},e[1]&&(r.number=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"discontinuity-sequence"},e[1]&&(r.number=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(s),e){r={type:"tag",tagType:"playlist-type"},e[1]&&(r.playlistType=e[1]),this.trigger("data",r);return}if(e=/^#EXT-X-BYTERANGE:(.*)?$/.exec(s),e){r=ae(Se(e[1]),{type:"tag",tagType:"byterange"}),this.trigger("data",r);return}if(e=/^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(s),e){r={type:"tag",tagType:"allow-cache"},e[1]&&(r.allowed=!/NO/.test(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-MAP:(.*)$/.exec(s),e){if(r={type:"tag",tagType:"map"},e[1]){const n=N(e[1]);n.URI&&(r.uri=n.URI),n.BYTERANGE&&(r.byterange=Se(n.BYTERANGE))}this.trigger("data",r);return}if(e=/^#EXT-X-STREAM-INF:(.*)$/.exec(s),e){r={type:"tag",tagType:"stream-inf"},e[1]&&(r.attributes=N(e[1]),r.attributes.RESOLUTION&&(r.attributes.RESOLUTION=et(r.attributes.RESOLUTION)),r.attributes.BANDWIDTH&&(r.attributes.BANDWIDTH=parseInt(r.attributes.BANDWIDTH,10)),r.attributes["FRAME-RATE"]&&(r.attributes["FRAME-RATE"]=parseFloat(r.attributes["FRAME-RATE"])),r.attributes["PROGRAM-ID"]&&(r.attributes["PROGRAM-ID"]=parseInt(r.attributes["PROGRAM-ID"],10))),this.trigger("data",r);return}if(e=/^#EXT-X-MEDIA:(.*)$/.exec(s),e){r={type:"tag",tagType:"media"},e[1]&&(r.attributes=N(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-ENDLIST/.exec(s),e){this.trigger("data",{type:"tag",tagType:"endlist"});return}if(e=/^#EXT-X-DISCONTINUITY/.exec(s),e){this.trigger("data",{type:"tag",tagType:"discontinuity"});return}if(e=/^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(s),e){r={type:"tag",tagType:"program-date-time"},e[1]&&(r.dateTimeString=e[1],r.dateTimeObject=new Date(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-KEY:(.*)$/.exec(s),e){r={type:"tag",tagType:"key"},e[1]&&(r.attributes=N(e[1]),r.attributes.IV&&(r.attributes.IV.substring(0,2).toLowerCase()==="0x"&&(r.attributes.IV=r.attributes.IV.substring(2)),r.attributes.IV=r.attributes.IV.match(/.{8}/g),r.attributes.IV[0]=parseInt(r.attributes.IV[0],16),r.attributes.IV[1]=parseInt(r.attributes.IV[1],16),r.attributes.IV[2]=parseInt(r.attributes.IV[2],16),r.attributes.IV[3]=parseInt(r.attributes.IV[3],16),r.attributes.IV=new Uint32Array(r.attributes.IV))),this.trigger("data",r);return}if(e=/^#EXT-X-START:(.*)$/.exec(s),e){r={type:"tag",tagType:"start"},e[1]&&(r.attributes=N(e[1]),r.attributes["TIME-OFFSET"]=parseFloat(r.attributes["TIME-OFFSET"]),r.attributes.PRECISE=/YES/.test(r.attributes.PRECISE)),this.trigger("data",r);return}if(e=/^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(s),e){r={type:"tag",tagType:"cue-out-cont"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-CUE-OUT:(.*)?$/.exec(s),e){r={type:"tag",tagType:"cue-out"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-CUE-IN:?(.*)?$/.exec(s),e){r={type:"tag",tagType:"cue-in"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-SKIP:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"skip"},r.attributes=N(e[1]),r.attributes.hasOwnProperty("SKIPPED-SEGMENTS")&&(r.attributes["SKIPPED-SEGMENTS"]=parseInt(r.attributes["SKIPPED-SEGMENTS"],10)),r.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")&&(r.attributes["RECENTLY-REMOVED-DATERANGES"]=r.attributes["RECENTLY-REMOVED-DATERANGES"].split(Kt)),this.trigger("data",r);return}if(e=/^#EXT-X-PART:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"part"},r.attributes=N(e[1]),["DURATION"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),["INDEPENDENT","GAP"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=/YES/.test(r.attributes[n]))}),r.attributes.hasOwnProperty("BYTERANGE")&&(r.attributes.byterange=Se(r.attributes.BYTERANGE)),this.trigger("data",r);return}if(e=/^#EXT-X-SERVER-CONTROL:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"server-control"},r.attributes=N(e[1]),["CAN-SKIP-UNTIL","PART-HOLD-BACK","HOLD-BACK"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),["CAN-SKIP-DATERANGES","CAN-BLOCK-RELOAD"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=/YES/.test(r.attributes[n]))}),this.trigger("data",r);return}if(e=/^#EXT-X-PART-INF:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"part-inf"},r.attributes=N(e[1]),["PART-TARGET"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),this.trigger("data",r);return}if(e=/^#EXT-X-PRELOAD-HINT:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"preload-hint"},r.attributes=N(e[1]),["BYTERANGE-START","BYTERANGE-LENGTH"].forEach(function(n){if(r.attributes.hasOwnProperty(n)){r.attributes[n]=parseInt(r.attributes[n],10);const o=n==="BYTERANGE-LENGTH"?"length":"offset";r.attributes.byterange=r.attributes.byterange||{},r.attributes.byterange[o]=r.attributes[n],delete r.attributes[n]}}),this.trigger("data",r);return}if(e=/^#EXT-X-RENDITION-REPORT:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"rendition-report"},r.attributes=N(e[1]),["LAST-MSN","LAST-PART"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseInt(r.attributes[n],10))}),this.trigger("data",r);return}if(e=/^#EXT-X-DATERANGE:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"daterange"},r.attributes=N(e[1]),["ID","CLASS"].forEach(function(o){r.attributes.hasOwnProperty(o)&&(r.attributes[o]=String(r.attributes[o]))}),["START-DATE","END-DATE"].forEach(function(o){r.attributes.hasOwnProperty(o)&&(r.attributes[o]=new Date(r.attributes[o]))}),["DURATION","PLANNED-DURATION"].forEach(function(o){r.attributes.hasOwnProperty(o)&&(r.attributes[o]=parseFloat(r.attributes[o]))}),["END-ON-NEXT"].forEach(function(o){r.attributes.hasOwnProperty(o)&&(r.attributes[o]=/YES/i.test(r.attributes[o]))}),["SCTE35-CMD"," SCTE35-OUT","SCTE35-IN"].forEach(function(o){r.attributes.hasOwnProperty(o)&&(r.attributes[o]=r.attributes[o].toString(16))});const n=/^X-([A-Z]+-)+[A-Z]+$/;for(const o in r.attributes){if(!n.test(o))continue;const i=/[0-9A-Fa-f]{6}/g.test(r.attributes[o]),u=/^\d+(\.\d+)?$/.test(r.attributes[o]);r.attributes[o]=i?r.attributes[o].toString(16):u?parseFloat(r.attributes[o]):String(r.attributes[o])}this.trigger("data",r);return}if(e=/^#EXT-X-INDEPENDENT-SEGMENTS/.exec(s),e){this.trigger("data",{type:"tag",tagType:"independent-segments"});return}if(e=/^#EXT-X-I-FRAMES-ONLY/.exec(s),e){this.trigger("data",{type:"tag",tagType:"i-frames-only"});return}if(e=/^#EXT-X-CONTENT-STEERING:(.*)$/.exec(s),e){r={type:"tag",tagType:"content-steering"},r.attributes=N(e[1]),this.trigger("data",r);return}if(e=/^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(s),e){r={type:"tag",tagType:"i-frame-playlist"},r.attributes=N(e[1]),r.attributes.URI&&(r.uri=r.attributes.URI),r.attributes.BANDWIDTH&&(r.attributes.BANDWIDTH=parseInt(r.attributes.BANDWIDTH,10)),r.attributes.RESOLUTION&&(r.attributes.RESOLUTION=et(r.attributes.RESOLUTION)),r.attributes["AVERAGE-BANDWIDTH"]&&(r.attributes["AVERAGE-BANDWIDTH"]=parseInt(r.attributes["AVERAGE-BANDWIDTH"],10)),r.attributes["FRAME-RATE"]&&(r.attributes["FRAME-RATE"]=parseFloat(r.attributes["FRAME-RATE"])),this.trigger("data",r);return}if(e=/^#EXT-X-DEFINE:(.*)$/.exec(s),e){r={type:"tag",tagType:"define"},r.attributes=N(e[1]),this.trigger("data",r);return}this.trigger("data",{type:"tag",data:s.slice(4)})})}}addParser({expression:t,customType:e,dataParser:r,segment:s}){typeof r!="function"&&(r=n=>n),this.customParsers.push(n=>{if(t.exec(n))return this.trigger("data",{type:"custom",data:r(n),customType:e,segment:s}),!0})}addTagMapper({expression:t,map:e}){const r=s=>t.test(s)?e(s):s;this.tagMappers.push(r)}}const er=a=>a.toLowerCase().replace(/-(\w)/g,t=>t[1].toUpperCase()),V=function(a){const t={};return Object.keys(a).forEach(function(e){t[er(e)]=a[e]}),t},ve=function(a){const{serverControl:t,targetDuration:e,partTargetDuration:r}=a;if(!t)return;const s="#EXT-X-SERVER-CONTROL",n="holdBack",o="partHoldBack",i=e&&e*3,u=r&&r*2;e&&!t.hasOwnProperty(n)&&(t[n]=i,this.trigger("info",{message:`${s} defaulting HOLD-BACK to targetDuration * 3 (${i}).`})),i&&t[n]<i&&(this.trigger("warn",{message:`${s} clamping HOLD-BACK (${t[n]}) to targetDuration * 3 (${i})`}),t[n]=i),r&&!t.hasOwnProperty(o)&&(t[o]=r*3,this.trigger("info",{message:`${s} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${t[o]}).`})),r&&t[o]<u&&(this.trigger("warn",{message:`${s} clamping PART-HOLD-BACK (${t[o]}) to partTargetDuration * 2 (${u}).`}),t[o]=u)};class tr extends Re{constructor(t={}){super(),this.lineStream=new zt,this.parseStream=new Zt,this.lineStream.pipe(this.parseStream),this.mainDefinitions=t.mainDefinitions||{},this.params=new URL(t.uri,"https://a.com").searchParams,this.lastProgramDateTime=null;const e=this,r=[];let s={},n,o,i=!1;const u=function(){},d={AUDIO:{},VIDEO:{},"CLOSED-CAPTIONS":{},SUBTITLES:{}},f="urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";let p=0;this.manifest={allowCache:!0,discontinuityStarts:[],dateRanges:[],iFramePlaylists:[],segments:[]};let w=0,y=0;const F={};this.on("end",()=>{s.uri||!s.parts&&!s.preloadHints||(!s.map&&n&&(s.map=n),!s.key&&o&&(s.key=o),!s.timeline&&typeof p=="number"&&(s.timeline=p),this.manifest.preloadSegment=s)}),this.parseStream.on("data",function(l){let D,R;if(e.manifest.definitions){for(const c in e.manifest.definitions)if(l.uri&&(l.uri=l.uri.replace(`{$${c}}`,e.manifest.definitions[c])),l.attributes)for(const g in l.attributes)typeof l.attributes[g]=="string"&&(l.attributes[g]=l.attributes[g].replace(`{$${c}}`,e.manifest.definitions[c]))}({tag(){({version(){l.version&&(this.manifest.version=l.version)},"allow-cache"(){this.manifest.allowCache=l.allowed,"allowed"in l||(this.trigger("info",{message:"defaulting allowCache to YES"}),this.manifest.allowCache=!0)},byterange(){const c={};"length"in l&&(s.byterange=c,c.length=l.length,"offset"in l||(l.offset=w)),"offset"in l&&(s.byterange=c,c.offset=l.offset),w=c.offset+c.length},endlist(){this.manifest.endList=!0},inf(){"mediaSequence"in this.manifest||(this.manifest.mediaSequence=0,this.trigger("info",{message:"defaulting media sequence to zero"})),"discontinuitySequence"in this.manifest||(this.manifest.discontinuitySequence=0,this.trigger("info",{message:"defaulting discontinuity sequence to zero"})),l.title&&(s.title=l.title),l.duration>0&&(s.duration=l.duration),l.duration===0&&(s.duration=.01,this.trigger("info",{message:"updating zero segment duration to a small value"})),this.manifest.segments=r},key(){if(!l.attributes){this.trigger("warn",{message:"ignoring key declaration without attribute list"});return}if(l.attributes.METHOD==="NONE"){o=null;return}if(!l.attributes.URI){this.trigger("warn",{message:"ignoring key declaration without URI"});return}if(l.attributes.KEYFORMAT==="com.apple.streamingkeydelivery"){this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.apple.fps.1_0"]={attributes:l.attributes};return}if(l.attributes.KEYFORMAT==="com.microsoft.playready"){this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.microsoft.playready"]={uri:l.attributes.URI};return}if(l.attributes.KEYFORMAT===f){if(["SAMPLE-AES","SAMPLE-AES-CTR","SAMPLE-AES-CENC"].indexOf(l.attributes.METHOD)===-1){this.trigger("warn",{message:"invalid key method provided for Widevine"});return}if(l.attributes.METHOD==="SAMPLE-AES-CENC"&&this.trigger("warn",{message:"SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"}),l.attributes.URI.substring(0,23)!=="data:text/plain;base64,"){this.trigger("warn",{message:"invalid key URI provided for Widevine"});return}if(!(l.attributes.KEYID&&l.attributes.KEYID.substring(0,2)==="0x")){this.trigger("warn",{message:"invalid key ID provided for Widevine"});return}this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.widevine.alpha"]={attributes:{schemeIdUri:l.attributes.KEYFORMAT,keyId:l.attributes.KEYID.substring(2)},pssh:Qt(l.attributes.URI.split(",")[1])};return}l.attributes.METHOD||this.trigger("warn",{message:"defaulting key method to AES-128"}),o={method:l.attributes.METHOD||"AES-128",uri:l.attributes.URI},typeof l.attributes.IV<"u"&&(o.iv=l.attributes.IV)},"media-sequence"(){if(!isFinite(l.number)){this.trigger("warn",{message:"ignoring invalid media sequence: "+l.number});return}this.manifest.mediaSequence=l.number},"discontinuity-sequence"(){if(!isFinite(l.number)){this.trigger("warn",{message:"ignoring invalid discontinuity sequence: "+l.number});return}this.manifest.discontinuitySequence=l.number,p=l.number},"playlist-type"(){if(!/VOD|EVENT/.test(l.playlistType)){this.trigger("warn",{message:"ignoring unknown playlist type: "+l.playlist});return}this.manifest.playlistType=l.playlistType},map(){n={},l.uri&&(n.uri=l.uri),l.byterange&&(n.byterange=l.byterange),o&&(n.key=o)},"stream-inf"(){if(this.manifest.playlists=r,this.manifest.mediaGroups=this.manifest.mediaGroups||d,!l.attributes){this.trigger("warn",{message:"ignoring empty stream-inf attributes"});return}s.attributes||(s.attributes={}),ae(s.attributes,l.attributes)},media(){if(this.manifest.mediaGroups=this.manifest.mediaGroups||d,!(l.attributes&&l.attributes.TYPE&&l.attributes["GROUP-ID"]&&l.attributes.NAME)){this.trigger("warn",{message:"ignoring incomplete or missing media group"});return}const c=this.manifest.mediaGroups[l.attributes.TYPE];c[l.attributes["GROUP-ID"]]=c[l.attributes["GROUP-ID"]]||{},D=c[l.attributes["GROUP-ID"]],R={default:/yes/i.test(l.attributes.DEFAULT)},R.default?R.autoselect=!0:R.autoselect=/yes/i.test(l.attributes.AUTOSELECT),l.attributes.LANGUAGE&&(R.language=l.attributes.LANGUAGE),l.attributes.URI&&(R.uri=l.attributes.URI),l.attributes["INSTREAM-ID"]&&(R.instreamId=l.attributes["INSTREAM-ID"]),l.attributes.CHARACTERISTICS&&(R.characteristics=l.attributes.CHARACTERISTICS),l.attributes.FORCED&&(R.forced=/yes/i.test(l.attributes.FORCED)),D[l.attributes.NAME]=R},discontinuity(){p+=1,s.discontinuity=!0,this.manifest.discontinuityStarts.push(r.length)},"program-date-time"(){typeof this.manifest.dateTimeString>"u"&&(this.manifest.dateTimeString=l.dateTimeString,this.manifest.dateTimeObject=l.dateTimeObject),s.dateTimeString=l.dateTimeString,s.dateTimeObject=l.dateTimeObject;const{lastProgramDateTime:c}=this;this.lastProgramDateTime=new Date(l.dateTimeString).getTime(),c===null&&this.manifest.segments.reduceRight((g,b)=>(b.programDateTime=g-b.duration*1e3,b.programDateTime),this.lastProgramDateTime)},targetduration(){if(!isFinite(l.duration)||l.duration<0){this.trigger("warn",{message:"ignoring invalid target duration: "+l.duration});return}this.manifest.targetDuration=l.duration,ve.call(this,this.manifest)},start(){if(!l.attributes||isNaN(l.attributes["TIME-OFFSET"])){this.trigger("warn",{message:"ignoring start declaration without appropriate attribute list"});return}this.manifest.start={timeOffset:l.attributes["TIME-OFFSET"],precise:l.attributes.PRECISE}},"cue-out"(){s.cueOut=l.data},"cue-out-cont"(){s.cueOutCont=l.data},"cue-in"(){s.cueIn=l.data},skip(){this.manifest.skip=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-SKIP",l.attributes,["SKIPPED-SEGMENTS"])},part(){i=!0;const c=this.manifest.segments.length,g=V(l.attributes);s.parts=s.parts||[],s.parts.push(g),g.byterange&&(g.byterange.hasOwnProperty("offset")||(g.byterange.offset=y),y=g.byterange.offset+g.byterange.length);const b=s.parts.length-1;this.warnOnMissingAttributes_(`#EXT-X-PART #${b} for segment #${c}`,l.attributes,["URI","DURATION"]),this.manifest.renditionReports&&this.manifest.renditionReports.forEach((E,T)=>{E.hasOwnProperty("lastPart")||this.trigger("warn",{message:`#EXT-X-RENDITION-REPORT #${T} lacks required attribute(s): LAST-PART`})})},"server-control"(){const c=this.manifest.serverControl=V(l.attributes);c.hasOwnProperty("canBlockReload")||(c.canBlockReload=!1,this.trigger("info",{message:"#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"})),ve.call(this,this.manifest),c.canSkipDateranges&&!c.hasOwnProperty("canSkipUntil")&&this.trigger("warn",{message:"#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"})},"preload-hint"(){const c=this.manifest.segments.length,g=V(l.attributes),b=g.type&&g.type==="PART";s.preloadHints=s.preloadHints||[],s.preloadHints.push(g),g.byterange&&(g.byterange.hasOwnProperty("offset")||(g.byterange.offset=b?y:0,b&&(y=g.byterange.offset+g.byterange.length)));const E=s.preloadHints.length-1;if(this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${E} for segment #${c}`,l.attributes,["TYPE","URI"]),!!g.type)for(let T=0;T<s.preloadHints.length-1;T++){const M=s.preloadHints[T];M.type&&M.type===g.type&&this.trigger("warn",{message:`#EXT-X-PRELOAD-HINT #${E} for segment #${c} has the same TYPE ${g.type} as preload hint #${T}`})}},"rendition-report"(){const c=V(l.attributes);this.manifest.renditionReports=this.manifest.renditionReports||[],this.manifest.renditionReports.push(c);const g=this.manifest.renditionReports.length-1,b=["LAST-MSN","URI"];i&&b.push("LAST-PART"),this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${g}`,l.attributes,b)},"part-inf"(){this.manifest.partInf=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-PART-INF",l.attributes,["PART-TARGET"]),this.manifest.partInf.partTarget&&(this.manifest.partTargetDuration=this.manifest.partInf.partTarget),ve.call(this,this.manifest)},daterange(){this.manifest.dateRanges.push(V(l.attributes));const c=this.manifest.dateRanges.length-1;this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${c}`,l.attributes,["ID","START-DATE"]);const g=this.manifest.dateRanges[c];g.endDate&&g.startDate&&new Date(g.endDate)<new Date(g.startDate)&&this.trigger("warn",{message:"EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"}),g.duration&&g.duration<0&&this.trigger("warn",{message:"EXT-X-DATERANGE DURATION must not be negative"}),g.plannedDuration&&g.plannedDuration<0&&this.trigger("warn",{message:"EXT-X-DATERANGE PLANNED-DURATION must not be negative"});const b=!!g.endOnNext;if(b&&!g.class&&this.trigger("warn",{message:"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"}),b&&(g.duration||g.endDate)&&this.trigger("warn",{message:"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"}),g.duration&&g.endDate){const E=g.startDate.getTime()+g.duration*1e3;this.manifest.dateRanges[c].endDate=new Date(E)}if(!F[g.id])F[g.id]=g;else{for(const T in F[g.id])if(g[T]&&JSON.stringify(F[g.id][T])!==JSON.stringify(g[T])){this.trigger("warn",{message:"EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"});break}const E=this.manifest.dateRanges.findIndex(T=>T.id===g.id);this.manifest.dateRanges[E]=ae(this.manifest.dateRanges[E],g),F[g.id]=ae(F[g.id],g),this.manifest.dateRanges.pop()}},"independent-segments"(){this.manifest.independentSegments=!0},"i-frames-only"(){this.manifest.iFramesOnly=!0,this.requiredCompatibilityversion(this.manifest.version,4)},"content-steering"(){this.manifest.contentSteering=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING",l.attributes,["SERVER-URI"])},define(){this.manifest.definitions=this.manifest.definitions||{};const c=(g,b)=>{if(g in this.manifest.definitions){this.trigger("error",{message:`EXT-X-DEFINE: Duplicate name ${g}`});return}this.manifest.definitions[g]=b};if("QUERYPARAM"in l.attributes){if("NAME"in l.attributes||"IMPORT"in l.attributes){this.trigger("error",{message:"EXT-X-DEFINE: Invalid attributes"});return}const g=this.params.get(l.attributes.QUERYPARAM);if(!g){this.trigger("error",{message:`EXT-X-DEFINE: No query param ${l.attributes.QUERYPARAM}`});return}c(l.attributes.QUERYPARAM,decodeURIComponent(g));return}if("NAME"in l.attributes){if("IMPORT"in l.attributes){this.trigger("error",{message:"EXT-X-DEFINE: Invalid attributes"});return}if(!("VALUE"in l.attributes)||typeof l.attributes.VALUE!="string"){this.trigger("error",{message:`EXT-X-DEFINE: No value for ${l.attributes.NAME}`});return}c(l.attributes.NAME,l.attributes.VALUE);return}if("IMPORT"in l.attributes){if(!this.mainDefinitions[l.attributes.IMPORT]){this.trigger("error",{message:`EXT-X-DEFINE: No value ${l.attributes.IMPORT} to import, or IMPORT used on main playlist`});return}c(l.attributes.IMPORT,this.mainDefinitions[l.attributes.IMPORT]);return}this.trigger("error",{message:"EXT-X-DEFINE: No attribute"})},"i-frame-playlist"(){this.manifest.iFramePlaylists.push({attributes:l.attributes,uri:l.uri,timeline:p}),this.warnOnMissingAttributes_("#EXT-X-I-FRAME-STREAM-INF",l.attributes,["BANDWIDTH","URI"])}}[l.tagType]||u).call(e)},uri(){s.uri=l.uri,r.push(s),this.manifest.targetDuration&&!("duration"in s)&&(this.trigger("warn",{message:"defaulting segment duration to the target duration"}),s.duration=this.manifest.targetDuration),o&&(s.key=o),s.timeline=p,n&&(s.map=n),y=0,this.lastProgramDateTime!==null&&(s.programDateTime=this.lastProgramDateTime,this.lastProgramDateTime+=s.duration*1e3),s={}},comment(){},custom(){l.segment?(s.custom=s.custom||{},s.custom[l.customType]=l.data):(this.manifest.custom=this.manifest.custom||{},this.manifest.custom[l.customType]=l.data)}})[l.type].call(e)})}requiredCompatibilityversion(t,e){(t<e||!t)&&this.trigger("warn",{message:`manifest must be at least version ${e}`})}warnOnMissingAttributes_(t,e,r){const s=[];r.forEach(function(n){e.hasOwnProperty(n)||s.push(n)}),s.length&&this.trigger("warn",{message:`${t} lacks required attribute(s): ${s.join(", ")}`})}push(t){this.lineStream.push(t)}end(){this.lineStream.push(`
`),this.manifest.dateRanges.length&&this.lastProgramDateTime===null&&this.trigger("warn",{message:"A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"}),this.lastProgramDateTime=null,this.trigger("end")}addParser(t){this.parseStream.addParser(t)}addTagMapper(t){this.parseStream.addTagMapper(t)}}console.log("DOWNLOAD_HANDLER.TS IS BEING LOADED AND PARSED");const tt=x.create("DownloadHandler_EarlyTest",X.Debug);tt.logError("DOWNLOAD_HANDLER.TS - EARLY ERROR LOG TEST"),tt.logDebug("DOWNLOAD_HANDLER.TS - EARLY DEBUG LOG TEST");class B extends Error{constructor(t,e){super(`${t} (TrackId: ${e})`)}}const m=x.create("DownloadHandler",X.Debug),se=new Xe;function rr(a){return a&&a.kind==="track"&&a.state==="finished"&&(a.streamable||a.downloadable)}function ar(a){return typeof a=="object"&&a!==null&&"protocol"in a}function sr(a){if(a?.media?.transcodings?.length<1)return m.logDebug(`[DownloadHandler TrackId: ${a.id}] No transcodings array or empty in track.media.`),null;m.logDebug(`[DownloadHandler TrackId: ${a.id}] Raw transcodings:`,JSON.stringify(a.media.transcodings,null,2));const t=a.media.transcodings.filter(r=>(r.format?.protocol==="progressive"||r.format?.protocol==="hls")&&(r.format?.mime_type?.startsWith("audio/mpeg")||r.format?.mime_type?.startsWith("audio/mp4"))&&!r.snipped).map(r=>({protocol:r.format.protocol,url:r.url,quality:r.quality}));if(t.length<1)return m.logWarn("[DownloadHandler] No transcodings streams could be determined for Track "+a.id),null;let e=t.sort((r,s)=>r.quality==="hq"&&s.quality==="sq"?-1:r.quality==="sq"&&s.quality==="hq"?1:r.protocol==="progressive"&&s.protocol==="hls"?-1:r.protocol==="hls"&&s.protocol==="progressive"?1:0);return $("download-hq-version")||(e=e.filter(r=>r.quality!=="hq")),e.some(r=>r.quality==="hq")&&m.logInfo("[DownloadHandler] Including high quality streams for Track "+a.id),e}async function rt(a,t,e,r,s){if(!rr(a))throw m.logError("[DownloadHandler] Track does not satisfy constraints needed to be downloadable",a),new B("Track does not satisfy constraints needed to be downloadable",a.id);const n=[];if($("download-original-version")&&a.downloadable&&a.has_downloads_left){const i=await se.getOriginalDownloadUrl(a.id);if(i){const u={url:i,hls:!1,extension:void 0};n.push(u)}}const o=sr(a);if(o&&n.push(...o),n.length<1){const i=`[DownloadHandler] No download details could be determined for track: "${a.title}"`;throw new B(i,a.id)}for(const i of n){let u=null,d=!1,f=null,p;try{if(ar(i))if(m.logDebug(`[DownloadHandler TrackId: ${a.id}] Getting stream details for transcoding`,i),u=await se.getStreamDetails(i.url),u)d=u.hls,f=u.url,p=u.extension;else{m.logWarn(`[DownloadHandler TrackId: ${a.id}] Failed to get stream details for transcoding option (url: ${i.url}), trying next...`);continue}else u=i,f=u.url,d=u.hls,p=u.extension,m.logDebug(`[DownloadHandler TrackId: ${a.id}] Using direct download detail (original file?)`,{url:f,hls:d,extension:p});if(!f){m.logWarn(`[DownloadHandler TrackId: ${a.id}] No stream URL resolved, trying next...`,{downloadDetail:i});continue}let w=f,y=d;const F={trackId:a.id,duration:a.duration,uploadDate:new Date(a.display_date),streamUrl:w,fileExtension:p,title:a.title,username:a.user.username,userPermalink:a.user.permalink,artworkUrl:a.artwork_url,avatarUrl:a.user.avatar_url,trackNumber:t,albumName:e,playlistName:r,hls:y,wasOriginallyHls:d};m.logDebug(`[DownloadHandler TrackId: ${a.id}] Calling handleDownload with data`,{downloadData:F});const l=await nr(F,s);return m.logInfo(`[DownloadHandler TrackId: ${a.id}] handleDownload returned browserDownloadId: ${l.browserDownloadId} for stream: ${w} and filename: ${l.finalFilenameForM3U}. ExtInfTitle: ${l.extInfDisplayTitle}`),s(101,l.browserDownloadId),l}catch(w){const y=w instanceof Error?w.message:String(w);m.logWarn(`[DownloadHandler TrackId: ${a.id}] Download attempt failed for option. Error: ${y}`,{downloadDetail:i,streamUrl:f})}}throw m.logError(`[DownloadHandler TrackId: ${a.id}] All download attempts failed after trying ${n.length} options.`),s(102),new B("No version of this track could be downloaded",a.id)}async function nr(a,t){m.logDebug(`[handleDownload ENTRY] Processing TrackId: ${a.trackId}. History check comes later.`);let e=a.username,r=a.title,s,n=a.artworkUrl,o,i,u,d,f,p,w,y,F;try{try{if(m.logInfo(`Initiating metadata processing for ${a.trackId} with payload`,{payload:a}),$("normalize-track")){const c=new U(a.title,a.username,a.userPermalink);let g=c.getArtists();$("include-producers")||(g=g.filter(E=>E.type!==Ae.Producer)),e=g.map(E=>E.name).join(", "),r=c.getTitle();const b=g.filter(E=>E.type===Ae.Remixer);if(b.length>0){const E=b.map(M=>M.name).join(" & "),T=De[b[0].remixType||De.Remix].toString();r+=` (${E} ${T})`}}e||(e="Unknown"),r||(r="Unknown"),s=te(`${e} - ${r}`)}catch(c){m.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during metadata processing:`,c);const g=c instanceof Error?c.message:String(c);throw new B(`Metadata processing failed for track ${a.trackId}: ${g}`,a.trackId)}u=!$("download-without-prompt"),d=$("default-download-location"),f=$("skipExistingFiles");try{const c=a.fileExtension||"mp3";if(F=s+"."+c,!u&&d)if(a.playlistName){const g=te(a.playlistName);F=d+"/"+g+"/"+F}else F=d+"/"+F;if(f){let g="";if(d)if(a.playlistName){const P=te(a.playlistName);g=d+"/"+P+"/"}else g=d+"/";const b=`track-${a.trackId}`,E=await Be("track-download-history")||{};if(m.logDebug(`[History Check] shouldSkipExisting=${f}, trackIdKey=${b}, history exists=${!!E}`),Object.keys(E).length>0&&m.logDebug(`[History Check] History has ${Object.keys(E).length} entries`),E&&E[b]){const P=E[b];m.logInfo(`Skipping download for TrackId: ${a.trackId}. Previously downloaded as: ${P.filename} at ${new Date(P.timestamp).toLocaleString()}`),t(101);const C=Math.floor(Math.random()*1e6)+1e3;return m.logInfo(`Using fake download ID ${C} for skipped track ${a.trackId}`),{browserDownloadId:C,finalFilenameForM3U:s+"."+(a.fileExtension||"mp3"),extInfDisplayTitle:`${e} - ${r}`}}const T={filename:`${g}${s}.${a.fileExtension||"mp3"}`};m.logDebug(`[History Check] Searching downloads with exactQuery: ${JSON.stringify(T)}`);const M=await we(T);m.logDebug(`[History Check] exactMatches found: ${M.length}`);const J=g.replace(/[-/^$*+?.()|[\]{}]/g,"\\$&"),Z=s.replace(/[-/^$*+?.()|[\]{}]/g,"\\$&"),ge={filenameRegex:`^${J}${Z}\\..+$`};m.logDebug(`[History Check] Searching downloads with regexQuery: ${JSON.stringify(ge)}`);const oe=M.length===0?await we(ge):[];m.logDebug(`[History Check] regexMatches found: ${oe.length}`);const ee={filenameRegex:`${Z}\\..+$`};m.logDebug(`[History Check] Searching downloads with titleArtistQuery: ${JSON.stringify(ee)}`);const v=M.length===0&&oe.length===0?await we(ee):[];m.logDebug(`[History Check] titleArtistMatches found: ${v.length}`);const _=[...M,...oe,...v].filter(P=>P.state==="complete");if(_.length>0){m.logInfo(`Skipping download for TrackId: ${a.trackId}. File already exists in download history: ${_[0].filename}`),_.length>0&&_.slice(0,3).forEach((C,it)=>{m.logDebug(`[History Check] Match ${it}: filename=${C.filename}, state=${C.state}`)}),E[b]={filename:_[0].filename,timestamp:Date.now()},await L("track-download-history",E),t(101);const P=Math.floor(Math.random()*1e6)+1e3;return m.logInfo(`Using fake download ID ${P} for already downloaded track ${a.trackId}`),{browserDownloadId:P,finalFilenameForM3U:s+"."+(a.fileExtension||"mp3"),extInfDisplayTitle:`${e} - ${r}`}}else m.logDebug(`No matching downloads found for TrackId: ${a.trackId} with filename base "${s}"`)}else m.logDebug("[History Check] Skip existing files check is disabled")}catch(c){throw m.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during filename/skip logic:`,c),new B(`Filename/skip logic failed for track ${a.trackId}: ${c.message}`,a.trackId)}try{n||(m.logInfo(`No Artwork URL in data. Fallback to User Avatar (TrackId: ${a.trackId})`),n=a.avatarUrl)}catch(c){m.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Error checking/falling back artwork URL: ${c.message}. Will attempt with current value.`)}m.logInfo(`Starting download of '${s}' (TrackId: ${a.trackId})...`);let l;try{if(a.hls){m.logInfo(`[TrackId: ${a.trackId}] Starting HLS segment fetching from: ${a.streamUrl}`);const[c,g]=await se.downloadStream(a.streamUrl,v=>{v!==void 0&&t(v*.1)});if(i=g,!c)throw new Error("HLS playlist download failed or returned empty buffer.");const b=new TextDecoder().decode(c),E=new tr;E.push(b),E.end();let T=null;if(E.manifest?.segments?.length>0){const v=E.manifest.segments.find(_=>_.map?.uri);if(v?.map?.uri){let _=v.map.uri;try{_.startsWith("http://")||_.startsWith("https://")||(_=new URL(_,a.streamUrl).href)}catch{if(!(_.startsWith("http://")||_.startsWith("https://")))throw new Error(`Failed to resolve relative HLS init segment URI: ${_}`)}const[P]=await se.downloadStream(_,C=>{C!==void 0&&t(5+C*.05)});if(!P)throw new Error(`Failed to download HLS init segment: ${_}`);T=P}}let M=[];if(E.manifest?.segments?.length>0&&(M=E.manifest.segments.map(v=>{try{return new URL(v.uri,a.streamUrl).href}catch{if(v.uri.startsWith("http://")||v.uri.startsWith("https://"))return v.uri;throw new Error(`Failed to resolve relative HLS segment URI: ${v.uri}`)}})),M.length===0&&!T)throw new Error("HLS playlist contains no media segments or init segment.");const J=[],Z=M.length,ge=T?10:5,oe=T?80:85;for(let v=0;v<Z;v++){const[_]=await se.downloadStream(M[v],C=>{C!==void 0&&t(ge+(v+C/100)/Z*oe)});if(!_)throw new Error(`Failed to download HLS segment: ${M[v]}`);J.push(_);const P=$("hls-rate-limit-delay-ms")??0;P>0&&v<Z-1&&await new Promise(C=>setTimeout(C,P))}const ee=[];T&&ee.push(T),ee.push(...J),o=Le(ee),a.hls=!1}else[o,i]=await se.downloadStream(a.streamUrl,t);if(!o)throw new B("Stream buffer is undefined after download attempts",a.trackId);if(l=o.slice(0),m.logDebug(`[DownloadHandler TrackId: ${a.trackId}] Initial streamBuffer byteLength: ${o?.byteLength}, originalStreamBuffer byteLength: ${l?.byteLength}`),a.wasOriginallyHls&&a.fileExtension&&/^[a-f0-9]{4}$/i.test(a.fileExtension)&&a.streamUrl.includes("/aac")?(m.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Correcting likely bogus HLS AAC extension '${a.fileExtension}' to 'm4a'.`),a.fileExtension="m4a"):a.wasOriginallyHls&&a.fileExtension&&a.fileExtension.toLowerCase()==="m3u8"&&(m.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Correcting HLS extension from 'm3u8' to 'm4a' (assuming AAC).`),a.fileExtension="m4a"),!a.fileExtension&&i){p=i.get("content-type");let c="mp3";p==="audio/mp4"?c="m4a":(p==="audio/x-wav"||p==="audio/wav")&&(c="wav"),a.fileExtension=c}else a.fileExtension||(a.fileExtension="mp3");if($("ffmpeg-remux-hls-mp4")&&(a.fileExtension==="m4a"||a.fileExtension==="mp4")){t(85);const c=g=>{const b=85+Math.floor(g*.13);t(b)};try{m.logInfo(`[DownloadHandler TrackId: ${a.trackId}] Sending remux task to FFmpegManager. Original streamBuffer byteLength before remux: ${l?.byteLength}`),o=await Nt(a.trackId.toString(),l,a.fileExtension||"mp4",c),(a.fileExtension==="m4a"||a.fileExtension==="mp4")&&(p="audio/mp4"),t(99),m.logInfo(`[DownloadHandler TrackId: ${a.trackId}] Remux task completed by FFmpegManager.`)}catch(g){m.logError(`[FFMPEG_MANAGER] Error during remux via manager. Proceeding with original. TrackId: ${a.trackId}`,g),o=l.slice(0),m.logDebug(`[DownloadHandler TrackId: ${a.trackId}] FFmpeg failed. Fallen back to originalStreamBuffer. ByteLength: ${o?.byteLength}`)}}else m.logDebug(`[DownloadHandler TrackId: ${a.trackId}] FFmpeg remux skipped (disabled or not applicable filetype).`)}catch(c){throw m.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during download/FFmpeg stage:`,c),new B(`Download/FFmpeg failed for track ${a.trackId}: ${c.message}`,a.trackId)}let D;try{const c=$("set-metadata");if(m.logDebug(`[Metadata Check Before If] TrackId: ${a.trackId}, setMetadata config: ${c}, streamBuffer exists: ${!!o}`),c&&o){let g;const b=o.slice(0);if(a.fileExtension==="mp3"?g=new Ht(b):(a.fileExtension==="m4a"||a.fileExtension==="mp4")&&(g=new S(b)),g){if(r&&g.setTitle(r),e&&g.setArtists([e]),a.albumName?g.setAlbum(a.albumName):a.playlistName&&g.setAlbum(a.playlistName),a.uploadDate){const T=a.uploadDate.getFullYear();isNaN(T)||g.setYear(T)}if(a.trackNumber&&g.setTrackNumber(a.trackNumber),a.trackId?g.setSoundCloudTrackId(a.trackId.toString()):m.logWarn(`[Metadata] TrackId is missing in data, cannot set SoundCloudTrackID for tagging. Track Title: ${a.title}`),n)try{const T=n.replace("-large.jpg","-t500x500.jpg"),M=await fetch(T);if(!M.ok)throw new Error(`Artwork fetch failed: ${M.statusText}`);const J=await M.arrayBuffer();g.setArtwork(J)}catch(T){m.logWarn(`[Artwork] Failed to fetch/set artwork for tagging TrackId: ${a.trackId}`,T)}const E=await g.getBuffer();m.logDebug(`[Metadata] TagWriter result for TrackId ${a.trackId} (ext: ${a.fileExtension}): applied=${E.tagsApplied}, message='${E.message||"none"}'`),E?.buffer?.byteLength>0?D=E.buffer:(m.logWarn("[Metadata] TagWriter returned invalid buffer. Using untagged buffer."),D=o.slice(0))}else m.logWarn(`[TrackId: ${a.trackId}] No TagWriter for ext '${a.fileExtension}'. Using untagged buffer.`),D=o.slice(0)}else m.logInfo(`[TrackId: ${a.trackId}] Metadata disabled or no streamBuffer. Using untagged.`),D=o?.slice(0)}catch(c){m.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during metadata tagging:`,c),D=o?.slice(0)}let R;try{R=D?.byteLength>0?D:o?.byteLength>0?o.slice(0):l?.byteLength>0?l.slice(0):(()=>{throw new B(`All buffers invalid for ${a.trackId}`,a.trackId)})(),R.byteLength<100&&m.logWarn(`Final buffer small: ${R.byteLength} bytes.`),m.logDebug(`[DownloadHandler TrackId: ${a.trackId}] Final bufferToSave byteLength before Blob creation: ${R?.byteLength}`);const c={};p?c.type=p:a.fileExtension==="mp3"?c.type="audio/mpeg":a.fileExtension==="m4a"||a.fileExtension==="mp4"?c.type="audio/mp4":a.fileExtension==="wav"&&(c.type="audio/wav");const g=new Blob([R],c);m.logInfo(`Creating URL for download (TrackId: ${a.trackId}). Service worker context: ${gt()}`),y=await Oe(g)}catch(c){throw m.logError(`[DownloadHandler TrackId: ${a.trackId}] Error preparing final buffer or Blob/DataURL:`,c),new B(`Failed to prepare buffer/DataURL for track ${a.trackId}: ${c.message}`,a.trackId)}if(w=s+"."+(a.fileExtension||"mp3"),!u&&d){const c=d.endsWith("/")?d.slice(0,-1):d,g=a.playlistName?`/${te(a.playlistName)}`:"",b=w.split("/").pop()||w;w=`${c}${g}/${b}`}try{m.logInfo(`Downloading track as '${w}' (TrackId: ${a.trackId}). SaveAs: ${u}`);const c=y;if(!c)throw new Error("Data URL for download is undefined.");const g=await Pe(c,w,u);if(m.logInfo(`Successfully initiated browser download for '${s}' (TrackId: ${a.trackId}) with browserDownloadId: ${g}`),f){const b=`track-${a.trackId}`,E=await Be("track-download-history")||{};E[b]={filename:w,timestamp:Date.now()},await L("track-download-history",E)}return{browserDownloadId:g,finalFilenameForM3U:s+"."+(a.fileExtension||"mp3"),extInfDisplayTitle:`${e} - ${r}`}}catch(c){m.logError(`[DownloadHandler TrackId: ${a.trackId}] Download save stage error:`,c);const g=c instanceof Error?c.message:String(c);throw new B(`Save failed for track ${a.trackId}: ${g}`,a.trackId)}}catch(l){throw m.logError(`[DownloadHandler TrackId: ${a.trackId}] Uncaught error in handleDownload`,l),l instanceof B?l:new B(`Unknown error during download: ${l?.message||l}`,a.trackId)}}async function or(a,t,e,r="audio/x-mpegurl"){m.logInfo(`[SaveTextFile] Attempting to save text content as filename: '${t}'. SaveAs: ${e}`);try{const s=new Blob([a],{type:r+";charset=utf-8"});m.logDebug(`[SaveTextFile] Created Blob with size: ${s.size} and type: ${s.type}`);const n=await Oe(s);if(!n)throw new Error("Failed to create URL from blob for text file download.");m.logDebug(`[SaveTextFile] Created object URL: ${n?n.substring(0,100)+"...":"undefined"}`);const o=await Pe(n,t,e);return m.logInfo(`[SaveTextFile] Successfully initiated browser download for '${t}' with browserDownloadId: ${o}`),o}catch(s){throw m.logError(`[SaveTextFile] Error during text file download for '${t}':`,s),s instanceof Error?new Error(`SaveTextFile failed for '${t}': ${s.message}`):new Error(`SaveTextFile failed for '${t}' with an unknown error.`)}}const K=x.create("Semaphore",X.Debug);class Fe{count;maxCount;waiting=[];constructor(t){if(t<=0)throw new Error("Semaphore count must be a positive integer.");this.count=t,this.maxCount=t}async acquire(){return K.logDebug(`Acquire attempt: current count ${this.count}, waiting queue ${this.waiting.length}`),this.count>0?(this.count--,K.logDebug(`Acquired immediately. New count ${this.count}`),Promise.resolve()):new Promise(t=>{this.waiting.push(t),K.logDebug(`Queued. New queue length ${this.waiting.length}`)})}release(){if(this.waiting.length>0){const t=this.waiting.shift();t?(K.logDebug(`Releasing permit to a waiting task. Queue length now ${this.waiting.length}`),t()):(this.count++,K.logWarn("[Semaphore] Shift from waiting queue returned undefined, but queue was not empty. Incrementing count."))}else this.count++,K.logDebug(`Permit released to pool. New count ${this.count}`);this.count>this.maxCount&&(K.logWarn(`Semaphore count (${this.count}) exceeded maxCount (${this.maxCount}) after release. Correcting.`),this.count=this.maxCount)}async withLock(t){await this.acquire();try{return await t()}finally{this.release()}}getAvailablePermits(){return this.count}getQueueLength(){return this.waiting.length}}const le=new Xe,h=x.create("Background",X.Debug),ir=dt();let lr=!1;const gr=()=>lr,O=[];let _e=!1;const me="persistentDownloadQueue_v1";async function H(){try{const a=JSON.parse(JSON.stringify(O));await chrome.storage.local.set({[me]:a}),h.logDebug("[Queue Persistence] Queue state saved.")}catch(a){h.logError("[Queue Persistence] Failed to save queue state:",a)}}async function dr(){try{const a=(await chrome.storage.local.get(me))[me];if(Array.isArray(a)){h.logInfo(`[Queue Persistence] Loading ${a.length} items from storage (key: ${me}).`);const t=[];let e=0;for(const r of a)if(r&&typeof r.id=="string"&&typeof r.type=="string"&&typeof r.status=="string"&&typeof r.url=="string"&&typeof r.addedAt=="number"&&r.originalMessage!==void 0){const s=r;s.status==="processing"&&(s.status="pending",s.progress=0,e++),t.push(s)}else h.logWarn("[Queue Persistence] Discarding invalid item from saved queue:",r);O.splice(0,O.length,...t),h.logInfo(`[Queue Persistence] Queue initialized. ${e} items reset from processing to pending.`),Q(),ne()}else h.logInfo("[Queue Persistence] No saved queue found or invalid format.")}catch(a){const t="[Queue Persistence] Failed to load queue state";if(a instanceof Error){const e=a.message||"[No message property]",r=a.stack||"[No stack trace]";h.logError(`${t}: ${e}
Stack: ${r}`)}else a?h.logError(`${t}. Caught non-Error object: ${String(a)}`):(h.logError(`${t}. An undefined or null error was caught.`),console.error("[Queue Persistence] Raw undefined/null error value that was caught by loadAndInitializeQueue:",a))}}const Q=()=>{h.logDebug("[Queue Broadcast] Sending queue update."),chrome?.runtime?.sendMessage?chrome.runtime.sendMessage({type:"QUEUE_UPDATED_BROADCAST",queuePayload:O},a=>{if(chrome.runtime.lastError){const t=chrome.runtime.lastError.message?.toLowerCase()||"";!t.includes("message port closed")&&!t.includes("receiving end does not exist")&&h.logWarn("[Queue Broadcast] Error sending queue update:",chrome.runtime.lastError.message)}}):h.logWarn("[Queue Broadcast] chrome.runtime.sendMessage not available?")},cr=async a=>{h.logInfo(`[QueueProcessor _executeDownloadTask] Starting task for ID: ${a.id}, Type: ${a.type}, URL: ${a.url}`),a.status="processing",await H(),a.originalMessage?.track?.title&&(a.title=a.originalMessage.track.title),a.originalMessage?.track?.artwork_url?a.artworkUrl=a.originalMessage.track.artwork_url:a.originalMessage?.set?.title?a.title=a.originalMessage.set.title:a.originalMessage?.set?.artwork_url&&(a.artworkUrl=a.originalMessage.set.artwork_url),Q(),a.tabId&&W(a.tabId,a.id,0,void 0,"Resuming");const t=(e,r)=>{e!==void 0&&(a.progress=e,a.tabId&&W(a.tabId,a.id,e,void 0,r?void 0:"Resuming",r))};try{if(a.type==="DOWNLOAD"){const e=a.originalMessage.url;if(!e)throw new Error("Missing URL in original message for DOWNLOAD item");h.logInfo(`[QueueProcessor _executeDownloadTask] Resolving track URL: ${e} for item ${a.id}`);const r=await le.resolveUrl(e);if(!r||r.kind!=="track")throw new Error(`Failed to resolve URL to a valid track: ${e}`);a.title=r.title,a.artworkUrl=r.artwork_url,Q(),h.logInfo(`[QueueProcessor _executeDownloadTask] Track resolved: ${r.title}. Starting download for item ${a.id}`);const s=await rt(r,void 0,void 0,void 0,t);a.status="completed",await H(),h.logInfo(`[QueueProcessor _executeDownloadTask] DOWNLOAD complete for item ${a.id}: ${r.title}`)}else if(a.type==="DOWNLOAD_SET"){const e=a.originalMessage.url;if(!e)throw new Error("Missing URL in original message for DOWNLOAD_SET item");h.logInfo(`[QueueProcessor _executeDownloadTask] Resolving set URL: ${e} for item ${a.id}`);const r=await le.resolveUrl(e);if(!r||!r.tracks||r.tracks.length===0)throw new Error(`Failed to resolve URL to a valid playlist or playlist is empty: ${e}`);a.title=r.title;const s=r.tracks.map(l=>l.id);if(s.length===0){h.logWarn(`[Queue Set ${a.id}] Playlist resolved but contains no track IDs?`),a.status="completed";return}h.logInfo(`[QueueProcessor _executeDownloadTask] Set resolved: ${r.title}. Fetching full details for ${s.length} tracks for item ${a.id}`);const n=fr(s,50),o=[];for(const l of n){const D=await le.getTracks(l);o.push(...Object.values(D))}h.logInfo(`[QueueProcessor _executeDownloadTask] Fetched full details for ${o.length} tracks.`),!a.artworkUrl&&o.length>0&&(a.artworkUrl=o[0].artwork_url),Q();let i=0,u=!1,d;const f=[],p=()=>{if(o.length===0)return 0;const l=i/o.length*100;return Math.min(l,100)},w=$("concurrentSetDownloads")??!1?Me():1,y=new Fe(w);h.logInfo(`[Queue Set ${a.id}] Processing ${o.length} tracks. Concurrency: ${w}`);const F=o.map(async(l,D)=>{gr(),await y.acquire();try{if(a.status==="error"&&$("stopSetDownloadOnError")){h.logInfo(`[Queue Set ${a.id}] Set download marked as error and stopOnError is true. Skipping remaining tracks.`);return}const R=D+1,c=(b,E)=>{i=Math.max(i,D+(b!==void 0&&b>=101?1:0));const T=p();a.progress=T,a.tabId&&W(a.tabId,a.id,T,void 0,E?void 0:"Resuming",E)};h.logInfo(`[Queue Set ${a.id}] Starting download for track ${R}/${o.length}: ${l.title}`);const g=await rt(l,R,r.title,r.title,c);if(g&&g.finalFilenameForM3U){const b=`#EXTINF:${l.duration?Math.round(l.duration/1e3):0},${g.extInfDisplayTitle}`;f.push(b),h.logInfo(`[M3U Set ${a.id}] Pushing to M3U file path entry: '${g.finalFilenameForM3U}' (Original title for EXTINF: '${g.extInfDisplayTitle}')`),f.push(g.finalFilenameForM3U),h.logDebug(`[M3U Set ${a.id}] Added to M3U: ${g.finalFilenameForM3U}`)}h.logInfo(`[Queue Set ${a.id}] Completed download for track ${R}/${o.length}: ${l.title}`)}catch(R){u=!0,d=R.message||"Unknown error downloading a track in the set.",h.logError(`[Queue Set ${a.id}] Error downloading track ${l.title}:`,R),$("stopSetDownloadOnError")&&(a.status="error",a.error=`Failed on track: ${l.title}. ${d}`)}finally{y.release(),a.progress=p(),Q()}});if(await Promise.all(F),h.logInfo(`[Queue Set ${a.id}] All track download promises resolved/rejected. Attempting to save queue state next.`),await H(),h.logInfo(`[Queue Set ${a.id}] Queue state saved after processing all tracks. EncounteredError: ${u}`),u)a.status="error",a.error=a.error||`One or more tracks failed to download within the set. Last error: ${d||"None recorded"}`,await H(),h.logWarn(`[Queue Set ${a.id}] DOWNLOAD_SET completed with errors. Last individual error logged was: ${d||"None recorded"}`),a.tabId&&W(a.tabId,a.id,a.progress,a.error);else if(a.status="completed",a.progress=101,await H(),h.logInfo(`[Queue Set ${a.id}] DOWNLOAD_SET completed successfully.`),a.tabId&&W(a.tabId,a.id,101),h.logDebug(`[M3U Set ${a.id}] Checking M3U conditions: entries=${f.length}, createM3uConfig=${$("createM3uPlaylistFile")}`),f.length>0&&$("createM3uPlaylistFile")){h.logInfo(`[M3U Set ${a.id}] Generating M3U file for set: ${r.title}`);const l=`#EXTM3U\r
`+f.join(`\r
`),D=te(r.title)+".m3u",R=$("default-download-location");let c=D;if(R){const g=te(r.title);c=`${R.replace(/\/$/,"")}/${g}/${D}`,h.logDebug(`[M3U Set ${a.id}] M3U save path with location & playlist folder: ${c}`)}else h.logInfo(`[M3U Set ${a.id}] No default download location. M3U will be saved to browser default with name: ${D}. Relative paths might not work as expected.`);try{const g=!$("download-without-prompt");h.logInfo(`[M3U Set ${a.id}] Saving M3U file: ${c}. SaveAs dialog: ${g}`),await or(l,c,g,"audio/x-mpegurl"),h.logInfo(`[M3U Set ${a.id}] Successfully initiated M3U file download for: ${r.title}`)}catch(g){h.logError(`[M3U Set ${a.id}] Failed to save M3U file for set ${r.title}:`,g)}}else $("createM3uPlaylistFile")&&h.logWarn(`[M3U Set ${a.id}] No track entries collected for M3U, or M3U creation disabled. Skipping M3U for set: ${r.title}`)}else a.type==="DOWNLOAD_SET_RANGE"?(h.logWarn(`[QueueProcessor _executeDownloadTask] DOWNLOAD_SET_RANGE for ${a.id} not yet implemented in queue processor.`),a.status="error",a.error="Set range downloads via queue not yet implemented.",await H(),a.tabId&&W(a.tabId,a.id,void 0,a.error)):(h.logError(`[QueueProcessor _executeDownloadTask] Unknown item type: ${a.type} for item ID: ${a.id}`),a.status="error",a.error="Unknown download type",await H(),a.tabId&&W(a.tabId,a.id,void 0,a.error))}catch(e){h.logError(`[QueueProcessor _executeDownloadTask] Error processing item ${a.id}:`,e),a.status="error",a.error=e.message||"Unknown error during processing",await H(),a.tabId&&W(a.tabId,a.id,void 0,a.error,void 0)}finally{Q()}},ur=async()=>{if(_e)return;_e=!0;const a=O.findIndex(t=>t.status==="pending");if(a!==-1){const t=O[a];await cr(t);const e=O.findIndex(r=>r.id===t.id);e!==-1&&(O[e].status==="completed"||O[e].status==="error")&&(h.logInfo(`[QueueProcessor] Removing finalized item ${O[e].id} (Status: ${O[e].status}) from queue.`),O.splice(e,1),await H(),Q())}_e=!1,O.some(t=>t.status==="pending")&&ne()},ne=()=>{setTimeout(()=>{h.logInfo("[QueueProcessor trigger] Checking queue..."),ur()},0)},Me=()=>Math.max(1,Math.min(Number($("maxConcurrentTrackDownloads"))||3,10));new Fe(Me()),h.logInfo(`Download track semaphore initialized with concurrency: ${Me()}`),Ee("maxConcurrentTrackDownloads",a=>{const t=Math.max(1,Math.min(Number(a)||3,10));h.logInfo(`Updating download track semaphore concurrency to: ${t}`),new Fe(t)});const pe={};async function at(a){await ht(a)}async function st(a){await mt(a)}h.logInfo("Starting with version: "+ir.version),ct($t),h.logInfo("Initial message listener registered."),Ue(!0).then(async()=>{h.logInfo("Initial configuration loaded."),await dr(),h.logInfo("Setting initial DNR rules.");const a=$("oauth-token");await at(a);const t=$("client-id");await st(t),a&&await ot(a),Lt()});function W(a,t,e,r,s,n){if(!t||typeof t!="string"||t.trim()===""){h.logError(`Attempted to send download progress with invalid downloadId: ${JSON.stringify(t)}`);const u=new Error().stack;if(h.logError(`Call stack for invalid downloadId: ${u}`),e===101||e===102){h.logWarn(`Attempting to send COMPLETION message (${e}) even with missing downloadId`);const d={downloadId:"undefined_completion",progress:e,error:typeof r=="string"?r:r instanceof Error?r.message:"",status:s,completionWithoutId:!0,timestamp:Date.now(),browserDownloadId:n};de(a,d).catch(f=>{h.logError(`Failed to send fallback completion message: ${f}`)})}return}let o="";r instanceof Error?o=r.message:typeof r=="string"&&(o=r),e===101||e===102?(h.logInfo(`Sending COMPLETION message for download ${t} to tab ${a}, progress=${e}`),delete pe[t]):e===100?pe[t]||(h.logInfo(`Sending FINISHING message for download ${t} to tab ${a}`),pe[t]=!0):e!==void 0&&e>=0&&delete pe[t];const i={downloadId:t,progress:e,error:o,status:s,timestamp:Date.now(),browserDownloadId:n};e===101||e===102?(h.logInfo(`Sending SINGLE COMPLETION message for download ${t} to tab ${a}, progress=${e} (BrowserDownloadId: ${n||"N/A"})`),de(a,i).catch(u=>{h.logWarn(`Failed to send completion message to tab ${a}:`,u)})):de(a,i).catch(u=>{h.logWarn(`Failed to send progress/status message to tab ${a}:`,u)})}function fr(a,t){const e=[];for(let r=0;r<a.length;r+=t){const s=a.slice(r,r+t);e.push(s)}return e}const nt=new RegExp("OAuth (.+)"),hr=new RegExp("/me/followings/(\\d+)");ut(a=>{if(Ne()){const r=$("oauth-token");if(a.requestHeaders){for(let s=0;s<a.requestHeaders.length;s++)if(a.requestHeaders[s].name.toLowerCase()==="authorization"){const n=a.requestHeaders[s].value,o=nt.exec(n);o&&o.length>=2&&o[1]!==r&&(h.logInfo("Sniffed and storing OAuth token from request header (all envs)."),L("oauth-token",o[1]));break}}return{}}let t=!1;const e=$("oauth-token");if(a.requestHeaders){for(let r=0;r<a.requestHeaders.length;r++)if(a.requestHeaders[r].name.toLowerCase()==="authorization"){t=!0;const s=a.requestHeaders[r].value,n=nt.exec(s);n&&n.length>=2&&n[1]!==e&&(h.logInfo("Sniffed and storing OAuth token (Firefox/non-DNR)."),L("oauth-token",n[1]));break}if(!t&&e)return a.requestHeaders.push({name:"Authorization",value:"OAuth "+e}),{requestHeaders:a.requestHeaders}}return{}},["*://api-v2.soundcloud.com/*"],["blocking","requestHeaders"]),ft(a=>{const t=new URL(a.url);if(t.pathname==="/connect/session"&&$("oauth-token")===null)h.logInfo("User logged in - clearing potentially stale token."),L("oauth-token",void 0);else if(t.pathname==="/sign-out")h.logInfo("User logged out"),L("oauth-token",null),L("user-id",null),L("followed-artists",[]);else if(t.pathname.startsWith("/me/followings/")){const e=hr.exec(t.pathname);if(e&&e.length===2){const r=+e[1];if(r){let s=$("followed-artists")||[];a.method==="POST"?s.includes(r)||s.push(r):a.method==="DELETE"&&(s=s.filter(n=>n!==r)),L("followed-artists",s)}}}else{const e=t.searchParams.get("client_id");if(e){const r=$("client-id");e!==r&&(h.logInfo(`Found new client_id: ${e}. Storing it.`),L("client-id",e))}else if(!Ne()){const r=$("client-id");if(r)return h.logDebug(`Adding ClientId to ${a.url} via redirect (Firefox/non-DNR)`),t.searchParams.append("client_id",r),{redirectUrl:t.toString()}}}return{}},["*://api-v2.soundcloud.com/*","*://api-auth.soundcloud.com/*"],["blocking"]);const ot=async a=>{if(!a){L("user-id",null),h.logInfo("OAuth token cleared, user ID cleared.");return}const t=await le.getCurrentUser();if(!t){h.logError("Failed to fetch currently logged in user (after token change/init)");return}L("user-id",t.id),h.logInfo("Logged in as",t.username);const e=await le.getFollowedArtistIds(t.id);if(!e){h.logError("Failed to fetch ids of followed artists");return}L("followed-artists",e)};Ee("oauth-token",async a=>{await at(a),await ot(a)}),Ee("client-id",async a=>{h.logInfo(`client-id config changed to: ${a}. Updating DNR rule.`),await st(a)});
