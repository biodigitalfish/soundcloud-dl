import{L as x,a as X}from"./logger-scdl-C1suKzoJ.js";import{s as le,g as at,a as pe,i as st,c as nt,d as it,b as ot,o as lt,e as gt,f as ct,h as dt,j as ut,u as Re}from"./compatibilityStubs-scdl-DBF9jRnU.js";import{c as Se,l as ve,a as ft,g as v,s as L,X as Fe,b as _e,d as ht,e as ge,f as Oe,r as Ee}from"./config-scdl-CB4onbqr.js";class ce extends Error{constructor(t){super(t),this.name="RateLimitError"}}class Pe{baseUrl="https://api-v2.soundcloud.com";logger;globalBackoffUntil=null;globalBackoffDurationMs=61*1e3;constructor(){this.logger=x.create("SoundCloudApi")}async retryWithBackoff(t,e=3,r=2e3,s){if(this.globalBackoffUntil&&Date.now()<this.globalBackoffUntil){const d=this.globalBackoffUntil-Date.now();this.logger.logWarn(`[Global Backoff] Active. Waiting for ${Math.ceil(d/1e3)}s before proceeding with ${s||"operation"}.`),await new Promise(g=>setTimeout(g,d)),this.logger.logInfo(`[Global Backoff] Wait completed for ${s||"operation"}. Optimistically clearing global trigger.`),this.globalBackoffUntil=null}let n=0,i=r;for(;n<=e;)try{if(n>0&&this.globalBackoffUntil&&Date.now()<this.globalBackoffUntil){const g=this.globalBackoffUntil-Date.now();this.logger.logWarn(`[Global Backoff] Re-activated during retries. Waiting for ${Math.ceil(g/1e3)}s for ${s||"operation"}.`),await new Promise(f=>setTimeout(f,g)),this.logger.logInfo(`[Global Backoff] Secondary wait completed for ${s||"operation"}. Optimistically clearing global trigger.`),this.globalBackoffUntil=null}this.logger.logDebug(`[Retry] Attempt ${n+1}/${e+1} for ${s||"operation"}`);const d=await t();return this.globalBackoffUntil!==null&&(this.logger.logInfo(`[${s||"operation"}] Succeeded. Clearing active global backoff trigger.`),this.globalBackoffUntil=null),d}catch(d){if(d instanceof ce)if(n<e)n++,this.logger.logWarn(`[Retry] Rate limit hit for ${s||"operation"}. Retrying in ${i/1e3}s... (Attempt ${n+1}/${e+1})`),await new Promise(g=>setTimeout(g,i)),i=Math.min(i*2,3e4);else throw this.logger.logError(`[Retry] Failed for ${s||"operation"} after ${n+1} attempts due to persistent rate limit. Activating global backoff.`),this.globalBackoffUntil=Date.now()+this.globalBackoffDurationMs,this.logger.logWarn(`[Global Backoff] Activated for ${this.globalBackoffDurationMs/1e3}s due to persistent rate limiting on ${s||"operation"}.`),d;else throw this.logger.logError(`[Retry] Failed for ${s||"operation"} with non-retryable or unexpected error after ${n+1} attempts:`,d.message||d),d}const o=`[Retry] Exhausted retries for ${s||"operation"} without explicit success or failure handling.`;throw this.logger.logError(o),new Error(o)}resolveUrl(t){const e=`${this.baseUrl}/resolve?url=${t}`;return this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`resolveUrl: ${t}`)}getCurrentUser(){const t=`${this.baseUrl}/me`;return this.retryWithBackoff(()=>this._fetchJsonInternal(t),3,2e3,"getCurrentUser")}async getFollowedArtistIds(t){const e=`${this.baseUrl}/users/${t}/followings/ids`,r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getFollowedArtistIds: ${t}`);return!r||!r.collection?null:r.collection}async getTracks(t){const e=`${this.baseUrl}/tracks?ids=${t.join(",")}`;this.logger.logInfo("Fetching tracks with Ids",{trackIds:t});const r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getTracks: ${t.length} IDs`);return t.reduce((s,n,i)=>(s[n]=r[i],s),{})}async getStreamDetails(t){const e=await this.retryWithBackoff(()=>this._fetchJsonInternal(t),3,2e3,`getStreamDetails: ${t}`);if(!e||!e.url)return this.logger.logError("Invalid stream response",e),null;let r,s=!1;const n=/(?:(\w{3,4})\/playlist)?\.(\w{3,4})(?:$|\?)/.exec(e.url);return n.length>=2&&(n[2]==="m3u8"?(r=n[1],s=!0):r=n[2]),{url:e.url,extension:r,hls:s}}async getOriginalDownloadUrl(t){const e=`${this.baseUrl}/tracks/${t}/download`;this.logger.logInfo("Getting original download URL for track with Id",t);try{const r=await this.retryWithBackoff(()=>this._fetchJsonInternal(e),3,2e3,`getOriginalDownloadUrl: ${t}`);return!r||!r.redirectUri?(this.logger.logError("Invalid original file response",r),null):r.redirectUri}catch(r){return this.logger.logError(`Failed to get original download URL for track ${t} after retries`,r),null}}async downloadArtwork(t){const[e]=await this.retryWithBackoff(()=>this._fetchArrayBufferInternal(t),3,2e3,`downloadArtwork: ${t}`);return e}downloadStream(t,e){return this.retryWithBackoff(()=>this._fetchArrayBufferInternal(t,e),3,1e3,`downloadStream: ${t}`)}async _fetchArrayBufferInternal(t,e){try{const r=await fetch(t);if(!r.ok){if(r.status===404)return this.logger.logDebug(`[fetchArrayBuffer] Resource not found (404) for ${t}`),[null,r.headers];if(r.status===429)throw this.logger.logWarn(`[fetchArrayBuffer] Rate limited (429) while fetching ${t}.`),new ce(`Rate limited (status 429) on ${t}`);const E=`[fetchArrayBuffer] HTTP error for ${t} - Status: ${r.status} ${r.statusText}`;throw new Error(E)}if(!r.body)throw this.logger.logError(`Response for ${t} has no body, despite response.ok being true.`),new Error(`Response for ${t} has no body.`);const s=r.headers.get("Content-Length"),n=s?parseInt(s,10):0;let i=0;const o=[],d=r.body.getReader();for(e&&n>0&&e(0);;){const{done:E,value:y}=await d.read();if(E)break;o.push(y),i+=y.byteLength,e&&n>0&&e(Math.round(i/n*100))}e&&e(100);const g=new ArrayBuffer(i),f=new Uint8Array(g);let m=0;for(const E of o)f.set(E,m),m+=E.byteLength;return i===0&&r.status===200&&this.logger.logWarn(`[fetchArrayBuffer] Fetched ${t} (Status: ${r.status}) but received an empty (0 bytes) buffer.`),[g,r.headers]}catch(r){throw this.logger.logError(`[fetchArrayBuffer] Generic error for ${t}:`,r),r instanceof ce?r:new Error(`Failed to fetch array buffer from ${t}: ${r instanceof Error?r.message:String(r)}`)}}async _fetchJsonInternal(t,e="GET",r){const s={Accept:"application/json"};e!=="GET"&&e!=="HEAD"&&(s["Content-Type"]="application/json");let n;try{this.logger.logDebug(`[API Fetch] Attempting ${e} to ${t}`),n=await fetch(t,{method:e,headers:s,body:r?JSON.stringify(r):void 0})}catch(i){throw this.logger.logError(`[API Fetch] Network error for ${e} ${t}: ${i.message}`,i),new Error(`Network error: ${i.message}`)}if(n.ok){const i=await n.text();if(!i&&(n.status===204||n.status===202))return this.logger.logDebug(`[API Fetch] Successful ${e} to ${t} with status ${n.status} (No Content).`),null;if(!i)return this.logger.logWarn(`[API Fetch] Successful ${e} to ${t} with status ${n.status} but received an empty response body.`),null;try{return JSON.parse(i)}catch(o){throw this.logger.logError(`[API Fetch] Successful ${e} to ${t} (status ${n.status}) but failed to parse JSON response: ${o.message}. Response text: "${i.substring(0,100)}"`),new Error(`JSON parsing error: ${o.message}`)}}else if(n.status===429){const i=`Rate limited (429) while fetching ${e} ${t}.`;throw this.logger.logWarn(i),new ce(i)}else{const i=await n.text().catch(()=>`Failed to read error response body for status ${n.status}`),o=`HTTP error ${n.status} ${n.statusText} for ${e} ${t}. Response: ${i.substring(0,200)}`;throw this.logger.logError(o),new Error(o)}}}const H=8,ne=16,Ne=H+ne;class Me{_metadataPath=["moov","udta","meta","ilst"];_buffer;_bufferView;_atoms=[];_loggedErrors=new Set;_hasValidStructure=!1;_logger;get hasValidMp4Structure(){return this._hasValidStructure}_logError(t){this._loggedErrors.has(t)||(this._logger.logDebug(`MP4 metadata: ${t}`),this._loggedErrors.add(t))}constructor(t){this._buffer=t,this._bufferView=new DataView(t),this._logger=x.create("MP4TagWriterInternals",X.Debug)}parse(){if(!this._buffer)throw new Error("Buffer can not be null");if(this._atoms.length>0)throw new Error("Buffer already parsed");this._logger.logDebug("Starting MP4 parse...");let t=0,e,r=[];for(;;){if(e=this._readAtom(t),!e||e.length<1||t>=this._buffer.byteLength){t<this._buffer.byteLength?this._logger.logDebug(`Parsing stopped: _readAtom returned invalid atom or zero length at offset ${t}.`):this._logger.logDebug(`Parsing stopped: Reached end of buffer at offset ${t}.`);break}if(r.push({name:e.name||"undefined",length:e.length,offset:e.offset}),this._atoms.push(e),t=e.offset+e.length,t<=e.offset){this._logger.logError(`Parsing stopped: Invalid offset progression. Current offset ${e.offset}, next offset calculated as ${t}.`);break}}if(this._logger.logDebug(`Finished MP4 parse. Found ${this._atoms.length} top-level atoms.`),this._logger.logDebug(`Top-level atoms summary: ${JSON.stringify(r)}`),this._atoms.length<1){this._logError("Buffer could not be parsed - no valid top-level atoms found."),this._hasValidStructure=!1;return}const s=this._atoms.find(n=>n.name?.toLowerCase()==="moov");this._hasValidStructure=!!s,this._hasValidStructure?this._logger.logDebug("File structure check passed: Found top-level 'moov' atom (case-insensitive check)."):this._logError("File structure check failed: Did not find a top-level 'moov' atom (checked case-insensitively).")}setDuration(t){try{if(!this._hasValidStructure){this._logError("Cannot set duration - file doesn't have a valid MP4 structure");return}const e=this._findAtom(this._atoms,["moov","mvhd"]);if(!e)throw new Error("'mvhd' atom could not be found");this._bufferView.setUint32(e.offset+H+16,t)}catch(e){this._logError(`Failed to set duration: ${e.message}`)}}addMetadataAtom(t,e){try{if(!this._hasValidStructure){this._logError(`Cannot add ${t} metadata - file doesn't have a valid MP4 structure`);return}if(t.length>4||t.length<1)throw new Error(`Unsupported atom name: '${t}'`);let r;if(e instanceof ArrayBuffer)r=e;else if(typeof e=="string")r=this._getBufferFromString(e);else if(typeof e=="number")r=new ArrayBuffer(4),new DataView(r).setUint32(0,e);else throw new Error(`Unsupported data: '${e}'`);const s={name:t,length:Ne+r.byteLength,data:r};this._insertAtom(s,this._metadataPath)}catch(r){this._logError(`Failed to add metadata atom '${t}': ${r.message}`)}}getBuffer(){const t=[];let e=0;for(const r of this._atoms){if(!r.children){const i=this._buffer.slice(r.offset,r.offset+r.length);t.push(i),e++;continue}r.length=H;const s=[{parent:r,offset:e,childIndex:0}];let n=0;for(;;){const{parent:i,offset:o,childIndex:d}=s[n];if(d>=i.children.length){n--,s.pop();let f=H;i.name==="meta"?(i.length+=4,f+=4):i.name==="stsd"&&(i.length+=8,f+=8),this._bufferView.setUint32(i.offset,i.length);const m=this._buffer.slice(i.offset,i.offset+f);if(t.splice(o,0,m),n<0)break;const E=s[n].parent;E.length+=i.length,s[n].childIndex++;continue}const g=i.children[d];if(g.children){g.length=H,s.push({parent:g,offset:e,childIndex:0}),n++;continue}else if(g.data){const f=this._getHeaderBufferFromAtom(g);t.push(f),t.push(g.data)}else{const f=this._buffer.slice(g.offset,g.offset+g.length);t.push(f)}e++,i.length+=g.length,s[n].childIndex++}}return this._bufferView=null,this._buffer=null,this._atoms=[],Se(t)}_insertAtom(t,e){try{if(this._logger.logDebug(`Attempting to insert atom '${t.name}' at path '${e.join(" > ")}'.`),!e||e[e.length-1]!=="ilst"){this._logError(`Cannot insert tag atom '${t.name}': Path does not end in 'ilst'.`);return}const r=this._createMetadataPath();if(!r){this._logError(`Cannot insert atom '${t.name}': Failed to find or create parent 'ilst' atom.`);return}r.children===void 0&&(r.children=this._readChildAtoms(r),this._logger.logDebug(`Loaded children for '${r.name}' in _insertAtom.`));const s=r.children.findIndex(i=>i.name===t.name);s!==-1&&(this._logger.logDebug(`Replacing existing atom '${t.name}' in '${r.name}'.`),r.children.splice(s,1));let n=r.offset+this._getAtomHeaderLength(r);if(r.children.length>0){const i=r.children[r.children.length-1];n=i.offset+i.length}t.offset=n,r.children.push(t),this._logger.logDebug(`Successfully prepared atom '${t.name}' for insertion into '${r.name}'.`)}catch(r){this._logError(`Error during _insertAtom for '${t.name}': ${r.message}`)}}_findAtom(t,e){if(!e||e.length<1)throw new Error("Path can not be empty");const r=[...e],s=r.shift();this._logger.logDebug(`_findAtom: Searching for '${s}' in ${t.length} atoms. Remaining path: [${r.join(",")}]`);const n=t.find(i=>i.name===s);return n?(this._logger.logDebug(`_findAtom: Found '${n.name}' (length: ${n.length}, offset: ${n.offset})`),r.length<1?(this._logger.logDebug(`_findAtom: Path complete. Returning '${n.name}'.`),n.children===void 0&&(this._logger.logDebug(`_findAtom: Reading children for final element '${n.name}' before returning.`),n.children=this._readChildAtoms(n)),n):(n.children===void 0&&(this._logger.logDebug(`_findAtom: Reading children for '${n.name}' to continue traversal.`),n.children=this._readChildAtoms(n)),!n.children||n.children.length<1?(this._logger.logDebug(`_findAtom: '${n.name}' has no children to continue search for [${r.join(",")}]`),null):this._findAtom(n.children,r))):(this._logger.logDebug(`_findAtom: '${s}' not found.`),null)}_readChildAtoms(t){const e=[];this._logger.logDebug(`_readChildAtoms: Reading children for parent '${t.name}' (length: ${t.length}, offset: ${t.offset})`);const r=t.offset+t.length;let s=t.offset+H;t.name==="meta"?s+=4:t.name==="stsd"?s+=8:t.name==="ilst"?this._logger.logDebug(`_readChildAtoms: Parent is '${t.name}', standard child offset: ${s}`):t.name&&(t.name==="\xA9nam"||t.name==="\xA9ART"||t.name==="\xA9alb"||t.name==="\xA9day"||t.name==="trkn"||t.name==="scid"||t.name==="covr"||t.name==="\xA9too")&&this._logger.logDebug(`_readChildAtoms: Parent is item atom '${t.name}', standard child offset: ${s}`);let n=0;for(;;){if(s>=r){this._logger.logDebug(`_readChildAtoms: Reached end of parent '${t.name}' at offset ${s}. Found ${n} children.`);break}const i=this._readAtom(s);if(n++,this._logger.logDebug(`_readChildAtoms: For parent '${t.name}', read potential child ${n}: '${i.name||"?"}' (length: ${i.length}, offset: ${i.offset})`),!i||i.length<1){this._logger.logWarn(`_readChildAtoms: Invalid child atom or zero length for parent '${t.name}' at offset ${s}. Stopping child read.`);break}if(i.offset+i.length>r){this._logger.logWarn(`_readChildAtoms: Child atom '${i.name}' (offset ${i.offset}, length ${i.length}) exceeds parent '${t.name}' (ends at ${r}). Stopping.`);break}if(e.push(i),s=i.offset+i.length,s<=i.offset){this._logger.logError(`_readChildAtoms: Invalid offset progression for parent '${t.name}'. Child offset ${i.offset}, next offset ${s}. Stopping.`);break}}return this._logger.logDebug(`_readChildAtoms: Finished reading for parent '${t.name}'. Total children found: ${e.length}`),e}_readAtom(t){const e=t,r=t+H,s=this._buffer.slice(e,r);if(s.byteLength<H)return{length:s.byteLength,offset:t};const n=new DataView(s);let i=n.getUint32(0,!1),o="";for(let d=0;d<4;d++)o+=String.fromCharCode(n.getUint8(4+d));return{name:o,length:i,offset:t}}_getHeaderBufferFromAtom(t){if(!t||t.length<1||!t.name||!t.data)throw new Error("Can not compute header buffer for this atom");const e=new ArrayBuffer(Ne),r=new DataView(e);r.setUint32(0,t.length);const s=this._getCharCodes(t.name);for(let i=0;i<s.length;i++)r.setUint8(4+i,s[i]);r.setUint32(8,ne+t.data.byteLength);const n=this._getCharCodes("data");for(let i=0;i<n.length;i++)r.setUint8(12+i,n[i]);return r.setUint32(16,this._getFlags(t.name)),e}_getBufferFromString(t){const e=new ArrayBuffer(t.length),r=new DataView(e),s=this._getCharCodes(t);for(let n=0;n<s.length;n++)r.setUint8(n,s[n]);return e}_getCharCodes(t){const e=[];for(let r=0;r<t.length;r++)e.push(t.charCodeAt(r));return e}_getFlags(t){switch(t){case"covr":return 13;case"trkn":case"disk":return 0;case"tmpo":case"cpil":case"rtng":return 21;default:return 1}}_createMetadataPath(){try{this._logger.logDebug("Attempting to ensure metadata path moov > udta > meta > ilst exists.");const t=this._findAtom(this._atoms,["moov"]);if(!t)return this._logError("Cannot create metadata path: Required 'moov' atom not found."),null;t.children===void 0&&(t.children=this._readChildAtoms(t));let e=t;const r=["udta","meta","ilst"];for(const s of r){let n=this._findAtom(e.children,[s]);if(n)this._logger.logDebug(`Found existing '${s}' atom.`),n.children===void 0&&(n.children=this._readChildAtoms(n));else{this._logger.logDebug(`Creating missing '${s}' atom.`);let i=e.offset+this._getAtomHeaderLength(e);if(e.children.length>0){const d=e.children[e.children.length-1];i=d.offset+d.length}const o=this._getAtomHeaderLength({name:s});n={name:s,length:o,offset:i,children:[]},e.children.push(n),this._logger.logDebug(`Created '${s}' atom.`)}e=n}return this._logger.logDebug("Metadata path creation/verification successful. Returning 'ilst' atom."),e}catch(t){return this._logError(`Failed during _createMetadataPath: ${t.message}`),null}}_getAtomHeaderLength(t){let e=H;return t.name==="meta"?e+=4:t.name==="stsd"&&(e+=8),e}findAndReadTextAtomData(t){try{const e=this._findAtom(this._atoms,t);if(e&&e.children&&e.children.length>0){const r=e.children.find(s=>s.name==="data");if(r){const s=r.offset+ne,n=r.length-ne;if(n>0&&this._buffer&&s+n<=this._buffer.byteLength){const i=this._buffer.slice(s,s+n);return new TextDecoder().decode(i)}else return this._logError(`Invalid data length or buffer bounds for atom at path ${t.join(" > ")}. Data atom length: ${r.length}, Header: ${ne}`),null}else return this._logError(`No 'data' child atom found for atom at path ${t.join(" > ")}`),null}else this._logError(`Target atom not found or has no children at path ${t.join(" > ")}`);return null}catch(e){return this._logError(`Error finding or reading text atom at path ${t.join(" > ")}: ${e.message}`),null}}}class k{_originalBuffer;_mp4;_hasValidMp4=!1;static _loggedErrors=new Set;static _logger=x.create("MP4TagWriter",X.Debug);static _logError(t){k._loggedErrors.has(t)||(k._logger.logDebug(`MP4 metadata: ${t}`),k._loggedErrors.add(t))}constructor(t){try{this._originalBuffer=t.slice(0),k._logger.logDebug(`Creating Mp4TagWriter with buffer of size: ${this._originalBuffer.byteLength}`);try{this._mp4=new Me(this._originalBuffer),this._mp4.parse(),this._hasValidMp4=this._mp4.hasValidMp4Structure,this._hasValidMp4?k._logger.logDebug("MP4 structure validation passed. TagWriter ready for use."):k._logError("MP4 structure validation failed. Tags will not be applied but original audio will still be saved.")}catch(e){this._hasValidMp4=!1,k._logError(`Failed to initialize MP4 parser: ${e.message}`)}}catch(e){k._logError(`Mp4TagWriter constructor error: ${e.message}`),this._originalBuffer=new ArrayBuffer(0),this._hasValidMp4=!1}}setTitle(t){try{if(!t)throw new Error("Invalid value for title");this._mp4.addMetadataAtom("\xA9nam",t)}catch(e){k._logError(`Failed to set title: ${e.message}`)}}setArtists(t){try{if(!t||t.length<1)throw new Error("Invalid value for artists");this._mp4.addMetadataAtom("\xA9ART",t.join(", "))}catch(e){k._logError(`Failed to set artists: ${e.message}`)}}setAlbum(t){try{if(!t)throw new Error("Invalid value for album");this._mp4.addMetadataAtom("\xA9alb",t)}catch(e){k._logError(`Failed to set album: ${e.message}`)}}setComment(t){try{if(!t)throw new Error("Invalid value for comment");this._mp4.addMetadataAtom("\xA9cmt",t)}catch(e){k._logError(`Failed to set comment: ${e.message}`)}}setTrackNumber(t){try{if(t<1||t>32767)throw new Error("Invalid value for trackNumber");this._mp4.addMetadataAtom("trkn",t)}catch(e){k._logError(`Failed to set track number: ${e.message}`)}}setYear(t){try{if(t<1)throw new Error("Invalid value for year");this._mp4.addMetadataAtom("\xA9day",t.toString())}catch(e){k._logError(`Failed to set year: ${e.message}`)}}setGrouping(t){try{if(!t)throw new Error("Invalid value for grouping");this._mp4.addMetadataAtom("\xA9grp",t)}catch(e){k._logError(`Failed to set grouping: ${e.message}`)}}setArtwork(t){try{if(!t||t.byteLength<1)throw new Error("Invalid value for artworkBuffer");this._mp4.addMetadataAtom("covr",t)}catch(e){k._logError(`Failed to set artwork: ${e.message}`)}}setSoundCloudTrackId(t){if(!this._hasValidMp4){k._logError("Cannot set SoundCloud Track ID - MP4 structure is invalid or not parsed.");return}if(!t){k._logError("Invalid value for SoundCloud Track ID");return}k._logger.logDebug(`[Mp4TagWriter] Attempting to set SoundCloudTrackID (scid): ${t}`),this._mp4.addMetadataAtom("scid",t)}setDuration(t){try{if(t<1)throw new Error("Invalid value for duration");this._mp4.setDuration(t)}catch(e){k._logError(`Failed to set duration: ${e.message}`)}}getBuffer(){try{if(!this._originalBuffer||this._originalBuffer.byteLength===0)throw new Error("Original buffer is missing or empty");if(!this._mp4||!this._hasValidMp4)return k._logError("MP4 structure check failed. Returning original buffer without applying tags."),Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:"Invalid MP4 structure for tagging."});let t;try{if(t=this._mp4.getBuffer(),!t||t.byteLength===0)throw new Error("Processed buffer is empty or null");t=t.slice(0)}catch(s){return k._logError(`Failed to get processed buffer: ${s.message}`),Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:`Failed to process MP4 buffer: ${s.message}`})}let e=!0,r;return t.byteLength!==this._originalBuffer.byteLength&&(e=!0,r=`Successfully applied tags (original: ${this._originalBuffer.byteLength}, new: ${t.byteLength})`),Promise.resolve({buffer:t,tagsApplied:e,message:r})}catch(t){const e=`Failed to get processed buffer: ${t.message}. Using original buffer as fallback.`;k._logError(e);try{return Promise.resolve({buffer:this._originalBuffer.slice(0),tagsApplied:!1,message:e})}catch(r){return k._logError(`CRITICAL: Failed to create copy of original buffer: ${r.message}`),Promise.resolve({buffer:new ArrayBuffer(0),tagsApplied:!1,message:`CRITICAL ERROR: ${e} + ${r.message}`})}}}}const mt="DOWNLOAD_SET",pt="DOWNLOAD",Et="DOWNLOAD_SET_RANGE",wt="PAUSE_DOWNLOAD",bt="RESUME_DOWNLOAD",we="GET_QUEUE_DATA",de="GET_EXTENSION_CONFIG",Le={},A=x.create("MessageHandler",X.Debug);async function yt(a,t){let e={};try{e=JSON.parse(JSON.stringify(a))}catch{e={errorParsingMessage:!0,rawMessage:String(a)}}A.logDebug("[MessageHandler DEBUG] Received message:",e);const r=[de,we,"EXTRACT_SCID_FROM_M4A","RESTORE_HISTORY_FROM_IDS"];(!a||a.downloadId===void 0&&a.type!==void 0&&!r.includes(a.type))&&A.logError(`CRITICAL: MessageHandler received message with type ${a.type} that requires a downloadId, but it was missing!`,e);const s=t.tab?.id,{downloadId:n,url:i,type:o}=a,d=[de,we];if(!s&&o&&!d.includes(o))return A.logWarn(`Message type ${o} received without a valid tab ID and is not allowed.`,{sender:t,message:a}),{error:`No valid tab ID found for message type ${o}`};if(o===de){A.logDebug(`[MessageHandler] Received GET_EXTENSION_CONFIG request from tab ${s}`);try{const g=await ve(!1),f={};for(const m of ft)g[m].secret||(f[m]={value:g[m].value});return A.logDebug("[MessageHandler] Sending non-secret configuration to content script:",f),Promise.resolve(f)}catch(g){return A.logError("[MessageHandler] Error loading or preparing configuration for content script:",g),Promise.reject({error:"Failed to retrieve extension configuration."})}}if(o&&!d.includes(o)&&!s)return A.logError(`CRITICAL: Message type ${o} requires a tabId, but it was missing after initial checks.`,{sender:t,message:a}),{error:`Missing tab ID for message type ${o}`};if(o===pt||o===mt||o===Et){if(!s)return A.logError(`CRITICAL: Download operation ${o} missing tabId.`),{error:"Download operations require a tabId."};A.logInfo(`[MessageHandler] Queuing request: ${o} for URL: ${i} with ID: ${n}`);const g={id:n,type:o,url:i,originalMessage:a,status:"pending",tabId:s,addedAt:Date.now()};P.push(g),await G(),A.logDebug(`[MessageHandler] Item added to queue and saved. Current queue size: ${P.length}`,g),z();const f={success:!0,message:`${o} request added to queue.`,originalDownloadId:n};return le(s,f).then(()=>A.logInfo(`[MessageHandler TX Ack] Queued ACK for ${n} sent to tab ${s}.`)).catch(m=>A.logError(`[MessageHandler TX Ack] Queued ACK for ${n} FAILED to send to tab ${s}:`,m)),me(),Promise.resolve(f)}else if(o==="EXTRACT_SCID_FROM_M4A"){if(!a.payload||!a.payload.buffer||!a.payload.filename)return A.logError("[MessageHandler] Invalid payload for EXTRACT_SCID_FROM_M4A:",a.payload),Promise.reject({error:"Invalid payload for SCID extraction."});const{filename:g,buffer:f}=a.payload;A.logInfo(`[MessageHandler] EXTRACT_SCID_FROM_M4A: Received buffer for ${g} (size: ${f.byteLength})`);try{const m=new Me(f);if(m.parse(),!m.hasValidMp4Structure)return A.logWarn(`[MessageHandler] EXTRACT_SCID_FROM_M4A: File ${g} does not have a valid MP4 structure.`),Promise.resolve({error:`File ${g} is not a valid MP4.`});const E=["moov","udta","meta","ilst","scid"],y=m.findAndReadTextAtomData(E);return y?(A.logInfo(`[MessageHandler] EXTRACT_SCID_FROM_M4A: Extracted SCID '${y}' from ${g}`),Promise.resolve({trackId:y})):(A.logWarn(`[MessageHandler] EXTRACT_SCID_FROM_M4A: SCID atom not found or no data in ${g}`),Promise.resolve({error:`SCID not found in ${g}`}))}catch(m){return A.logError(`[MessageHandler] EXTRACT_SCID_FROM_M4A: Error parsing ${g}:`,m),Promise.resolve({error:`Error parsing MP4 file ${g}: ${m.message||m}`})}}else if(o==="RESTORE_HISTORY_FROM_IDS"){if(!a.payload||!Array.isArray(a.payload.trackIds))return A.logError("[MessageHandler] Invalid payload for RESTORE_HISTORY_FROM_IDS:",a.payload),Promise.reject({error:"Invalid payload for history restoration."});const{trackIds:g}=a.payload;if(A.logInfo(`[MessageHandler] RESTORE_HISTORY_FROM_IDS: Received ${g.length} track IDs to restore.`),g.length===0)return Promise.resolve({message:"No track IDs provided to restore."});try{const f=await v("track-download-history")||{};let m=0;return g.forEach(E=>{if(typeof E=="string"&&E.trim()!==""){const y=`track-${E}`;f[y]?A.logDebug(`[MessageHandler] RESTORE_HISTORY_FROM_IDS: Track ${E} already in history, skipping.`):(f[y]={filename:`Restored: TrackID ${E}`,timestamp:Date.now()},m++)}}),await L("track-download-history",f),A.logInfo(`[MessageHandler] RESTORE_HISTORY_FROM_IDS: Successfully restored ${m} new tracks to history.`),Promise.resolve({message:`Successfully restored ${m} new tracks out of ${g.length} to download history.`})}catch(f){return A.logError("[MessageHandler] RESTORE_HISTORY_FROM_IDS: Error accessing storage or processing IDs:",f),Promise.resolve({error:`Error restoring history: ${f.message||f}`})}}else if(o===wt){if(!s)return{error:"Pause ops require tabId"};const g=a;return A.logInfo(`Received pause request for download: ${g.downloadId}`),Le[g.downloadId]=!0,q(s,g.downloadId,void 0,void 0,"Paused"),{success:!0,action:"paused",downloadId:g.downloadId}}else if(o===bt){if(!s)return{error:"Resume ops require tabId"};const g=a;A.logInfo(`Received resume request for download: ${g.downloadId}`),delete Le[g.downloadId];const f=P.find(m=>m.id===g.downloadId);return f&&f.status==="pending"?A.logInfo(`Resume for pending item ${f.id}. Will be picked by processor.`):f&&f.status==="processing"&&A.logInfo(`Resume for actively processing item ${f.id}. Processor will handle.`),me(),q(s,g.downloadId,void 0,void 0,"Resuming"),{success:!0,action:"resumed",downloadId:g.downloadId}}else{if(o===we)return A.logInfo("[MessageHandler] Received GET_QUEUE_DATA request (likely from popup)."),Promise.resolve(P);if(o!==de)return A.logWarn(`[MessageHandler] Unknown message type received: ${o}`,a),Promise.reject({error:`Unknown message type: ${o}`})}}var $;(function(a){a.LOAD="LOAD",a.EXEC="EXEC",a.FFPROBE="FFPROBE",a.WRITE_FILE="WRITE_FILE",a.READ_FILE="READ_FILE",a.DELETE_FILE="DELETE_FILE",a.RENAME="RENAME",a.CREATE_DIR="CREATE_DIR",a.LIST_DIR="LIST_DIR",a.DELETE_DIR="DELETE_DIR",a.ERROR="ERROR",a.DOWNLOAD="DOWNLOAD",a.PROGRESS="PROGRESS",a.LOG="LOG",a.MOUNT="MOUNT",a.UNMOUNT="UNMOUNT"})($||($={}));const Tt=(()=>{let a=0;return()=>a++})(),It=new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),At=new Error("called FFmpeg.terminate()");class $t{#t=null;#a={};#r={};#s=[];#n=[];loaded=!1;#i=()=>{this.#t&&(this.#t.onmessage=({data:{id:t,type:e,data:r}})=>{switch(e){case $.LOAD:this.loaded=!0,this.#a[t](r);break;case $.MOUNT:case $.UNMOUNT:case $.EXEC:case $.FFPROBE:case $.WRITE_FILE:case $.READ_FILE:case $.DELETE_FILE:case $.RENAME:case $.CREATE_DIR:case $.LIST_DIR:case $.DELETE_DIR:this.#a[t](r);break;case $.LOG:this.#s.forEach(s=>s(r));break;case $.PROGRESS:this.#n.forEach(s=>s(r));break;case $.ERROR:this.#r[t](r);break}delete this.#a[t],delete this.#r[t]})};#e=({type:t,data:e},r=[],s)=>this.#t?new Promise((n,i)=>{const o=Tt();this.#t&&this.#t.postMessage({id:o,type:t,data:e},r),this.#a[o]=n,this.#r[o]=i,s?.addEventListener("abort",()=>{i(new DOMException(`Message # ${o} was aborted`,"AbortError"))},{once:!0})}):Promise.reject(It);on(t,e){t==="log"?this.#s.push(e):t==="progress"&&this.#n.push(e)}off(t,e){t==="log"?this.#s=this.#s.filter(r=>r!==e):t==="progress"&&(this.#n=this.#n.filter(r=>r!==e))}load=({classWorkerURL:t,...e}={},{signal:r}={})=>(this.#t||(this.#t=t?new Worker(new URL(t,import.meta.url),{type:"module"}):new Worker(new URL("/assets/worker-BAOIWoxA.js",import.meta.url),{type:"module"}),this.#i()),this.#e({type:$.LOAD,data:e},void 0,r));exec=(t,e=-1,{signal:r}={})=>this.#e({type:$.EXEC,data:{args:t,timeout:e}},void 0,r);ffprobe=(t,e=-1,{signal:r}={})=>this.#e({type:$.FFPROBE,data:{args:t,timeout:e}},void 0,r);terminate=()=>{const t=Object.keys(this.#r);for(const e of t)this.#r[e](At),delete this.#r[e],delete this.#a[e];this.#t&&(this.#t.terminate(),this.#t=null,this.loaded=!1)};writeFile=(t,e,{signal:r}={})=>{const s=[];return e instanceof Uint8Array&&s.push(e.buffer),this.#e({type:$.WRITE_FILE,data:{path:t,data:e}},s,r)};mount=(t,e,r)=>{const s=[];return this.#e({type:$.MOUNT,data:{fsType:t,options:e,mountPoint:r}},s)};unmount=t=>{const e=[];return this.#e({type:$.UNMOUNT,data:{mountPoint:t}},e)};readFile=(t,e="binary",{signal:r}={})=>this.#e({type:$.READ_FILE,data:{path:t,encoding:e}},void 0,r);deleteFile=(t,{signal:e}={})=>this.#e({type:$.DELETE_FILE,data:{path:t}},void 0,e);rename=(t,e,{signal:r}={})=>this.#e({type:$.RENAME,data:{oldPath:t,newPath:e}},void 0,r);createDir=(t,{signal:e}={})=>this.#e({type:$.CREATE_DIR,data:{path:t}},void 0,e);listDir=(t,{signal:e}={})=>this.#e({type:$.LIST_DIR,data:{path:t}},void 0,e);deleteDir=(t,{signal:e}={})=>this.#e({type:$.DELETE_DIR,data:{path:t}},void 0,e)}var Ue;(function(a){a.MEMFS="MEMFS",a.NODEFS="NODEFS",a.NODERAWFS="NODERAWFS",a.IDBFS="IDBFS",a.WORKERFS="WORKERFS",a.PROXYFS="PROXYFS"})(Ue||(Ue={}));const Dt=new Error("failed to get response body reader"),kt=new Error("failed to complete download"),Rt="Content-Length",St=async(a,t)=>{const e=await fetch(a);let r;try{const s=parseInt(e.headers.get(Rt)||"-1"),n=e.body?.getReader();if(!n)throw Dt;const i=[];let o=0;for(;;){const{done:f,value:m}=await n.read(),E=m?m.length:0;if(f){if(s!=-1&&s!==o)throw kt;t&&t({url:a,total:s,received:o,delta:E,done:f});break}i.push(m),o+=E,t&&t({url:a,total:s,received:o,delta:E,done:f})}const d=new Uint8Array(o);let g=0;for(const f of i)d.set(f,g),g+=f.length;r=d.buffer}catch(s){console.log("failed to send download progress event: ",s),r=await e.arrayBuffer()}return r},be=async(a,t,e=!1,r)=>{const s=e?await St(a,r):await(await fetch(a)).arrayBuffer(),n=new Blob([s],{type:t});return URL.createObjectURL(n)},vt=x.create("FFmpegInstance",X.Debug);async function Ce(a){const t=a?x.create(`FFmpegInstance:${a}`,X.Debug):vt,e=new $t;e.on("log",({message:r})=>{r.startsWith("frame=")||t.logDebug(`[FFMPEG_WASM_LOG] ${r}`)}),t.logInfo("[FFMPEG_WASM] Initializing new FFmpeg.wasm instance from local files (using toBlobURL strategy)...");try{const r=at("ffmpeg-core/");if(!r)return t.logError("[FFMPEG_WASM] Failed to get base URL for FFmpeg core files."),null;const s=r+"ffmpeg-core.js",n=r+"ffmpeg-core.wasm",i=r+"worker.js";t.logInfo(`[FFMPEG_WASM] Base URL for Blob: ${r}`),t.logInfo("[FFMPEG_WASM] Attempting to create Blob URLs for core files (including worker)...");const o=await be(s,"text/javascript"),d=await be(n,"application/wasm"),g=await be(i,"text/javascript");return t.logInfo("[FFMPEG_WASM] Blob URLs created. Loading FFmpeg instance with worker..."),await e.load({coreURL:o,wasmURL:d,workerURL:g}),t.logInfo("[FFMPEG_WASM] FFmpeg.wasm instance loaded successfully via Blob URLs (worker enabled)."),e}catch(r){return t.logError("[FFMPEG_WASM] Failed to load FFmpeg.wasm instance via Blob URLs",r),null}}const D=x.create("FFmpegManager",X.Debug),Ft=Math.max(1,Math.min(Number(v("maxConcurrentTrackDownloads"))||2,10)),ue=Ft;D.logInfo(`FFmpegManager initialized with MAX_CONCURRENT_OPERATIONS: ${ue}`);const W=[],fe=[];let Q=!1,Y=null;async function xe(){return Q?Promise.resolve():Y||(D.logInfo(`Initializing FFmpeg instance pool with size: ${ue}`),Y=(async()=>{try{const a=[];for(let e=0;e<ue;e++)a.push(Ce(e));const t=await Promise.all(a);for(let e=0;e<t.length;e++){const r=t[e];r?W.push({id:e,instance:r,isAvailable:!0,isCompromised:!1}):D.logError(`Failed to load FFmpeg instance ${e} for the pool.`)}if(W.length===0&&ue>0)throw new Error("No FFmpeg instances could be initialized for the pool.");Q=!0,D.logInfo(`FFmpeg instance pool initialized with ${W.length} instances.`)}catch(a){throw D.logError("Failed to initialize FFmpeg pool",a),Q=!1,Y=null,a}})(),Y)}async function _t(a,t){const{instance:e,id:r}=a,{taskId:s,inputBuffer:n,fileExtension:i,progressCallback:o,resolve:d,reject:g}=t,f=`input_${s}_${r}.${i||"mp4"}`,m=`output_remuxed_${s}_${r}.${i||"mp4"}`;D.logInfo(`[FFmpegManager] Instance ${r} starting remux for task ${s}: ${f} -> ${m}`);let E;try{let y;try{D.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Attempting inputBuffer.slice(0). Input buffer byteLength: ${n?.byteLength}`);const R=n.slice(0);D.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Successfully sliced buffer. Slice byteLength: ${R?.byteLength}. Attempting new Uint8Array().`),y=new Uint8Array(R),D.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Created Uint8Array with byteLength: ${y?.byteLength}. About to call instance.writeFile with ${f}.`)}catch(R){throw D.logError(`[FFmpegManager] Instance ${r}, Task ${s}: ERROR during buffer slice or Uint8Array creation:`,R),R}await e.writeFile(f,y),D.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: Successfully called instance.writeFile with ${f}.`);const I=["-loglevel","debug","-i",f,"-c","copy",m];if(D.logDebug(`[FFmpegManager] Instance ${r}, Task ${s}: FFmpeg exec arguments:`,I),o){let R=-1;E=({progress:F})=>{const u=Math.round(F*100);u>R&&u<=100&&(o(u),R=u)},e.on("progress",E)}await e.exec(I);const l=await e.readFile(m);if(typeof l=="string")throw new Error("FFmpeg remux output was a string, expected Uint8Array");D.logInfo(`[FFmpegManager] Instance ${r} finished remux for task ${s}`),d(l.buffer.slice(0))}catch(y){D.logError(`[FFmpegManager] Instance ${r} FAILED remux for task ${s}`,y),a.isCompromised=!0,g(y)}finally{E&&typeof e.off=="function"&&e.off("progress",E);try{await e.deleteFile(f),await e.deleteFile(m)}catch(y){D.logWarn(`[FFmpegManager] Instance ${r} failed to cleanup files for task ${s}`,y),a.isCompromised=!0}}}function Be(){if(!Q||fe.length===0)return;const a=W.find(e=>e.isAvailable);if(!a){D.logDebug("No FFmpeg instance available right now, queue length: "+fe.length);return}const t=fe.shift();t&&(a.isAvailable=!1,D.logDebug(`Assigning task ${t.taskId} to FFmpeg instance ${a.id}`),_t(a,t).finally(async()=>{if(a.isCompromised){D.logWarn(`[FFmpegManager] Instance ${a.id} is compromised. Terminating and attempting to replace.`);try{await a.instance.terminate(),D.logInfo(`[FFmpegManager] Terminated compromised instance ${a.id}.`)}catch(s){D.logError(`[FFmpegManager] Error terminating compromised instance ${a.id}:`,s)}const e=W.findIndex(s=>s.id===a.id);e>-1&&W.splice(e,1),D.logInfo(`[FFmpegManager] Attempting to create new FFmpeg instance to replace ${a.id}.`);const r=await Ce(a.id);r?(W.push({id:a.id,instance:r,isAvailable:!0,isCompromised:!1}),D.logInfo(`[FFmpegManager] Successfully replaced instance ${a.id}. Pool size: ${W.length}`)):D.logError(`[FFmpegManager] Failed to create new FFmpeg instance to replace ${a.id}. Pool size will be reduced.`)}else a.isAvailable=!0,D.logDebug(`FFmpeg instance ${a.id} is now available.`);Be()}))}async function Ot(a,t,e,r){return!Q&&!Y&&xe().catch(s=>{D.logError("FFmpeg Pool Initialization failed lazily, subsequent requests might fail.",s)}),Y&&await Y,!Q||W.length===0?Promise.reject(new Error("FFmpegManager: Pool not initialized or no instances available after init attempt.")):new Promise((s,n)=>{D.logDebug(`Task ${a} added to FFmpeg remux queue.`),fe.push({taskId:a,inputBuffer:t,fileExtension:e,progressCallback:r,resolve:s,reject:n}),Be()})}function Pt(){!Q&&!Y&&xe().catch(a=>{D.logError("Pre-initialization of FFmpeg Pool failed.",a)})}function Xe(a){return String(a).split("").map(t=>t.charCodeAt(0))}function ee(a){return new Uint8Array(Xe(a))}function j(a){const t=new ArrayBuffer(2*a.length),e=new Uint8Array(t);return new Uint16Array(t).set(Xe(a)),e}function He(a){return[a>>>24&255,a>>>16&255,a>>>8&255,a&255]}function We(a){return 11+a}function Nt(a,t,e,r){return 11+t+1+1+(r?2+2*(e+1):e+1)+a}function Mt(a){let t=0;return a.forEach(e=>{t+=2+2*e[0].length+2+2+2*e[1].length+2}),11+t}function Lt(a,t){const e=2*t;let r=0;return a.forEach(s=>{r+=2+2*s[0].length+2+4}),18+e+2+r}class Ut{_setIntegerFrame(t,e){const r=parseInt(e,10);this.frames.push({name:t,value:r,size:We(r.toString().length)})}_setStringFrame(t,e){const r=e.toString();let s=13+2*r.length;t==="TDAT"&&(s=We(r.length)),this.frames.push({name:t,value:r,size:s})}_setPictureFrame(t,e,r,s){const n=function(o){if(!o||!o.length)return null;if(o[0]===255&&o[1]===216&&o[2]===255)return"image/jpeg";if(o[0]===137&&o[1]===80&&o[2]===78&&o[3]===71)return"image/png";if(o[0]===71&&o[1]===73&&o[2]===70)return"image/gif";if(o[8]===87&&o[9]===69&&o[10]===66&&o[11]===80)return"image/webp";const d=o[0]===73&&o[1]===73&&o[2]===42&&o[3]===0,g=o[0]===77&&o[1]===77&&o[2]===0&&o[3]===42;return d||g?"image/tiff":o[0]===66&&o[1]===77?"image/bmp":o[0]===0&&o[1]===0&&o[2]===1&&o[3]===0?"image/x-icon":null}(new Uint8Array(e)),i=r.toString();if(!n)throw new Error("Unknown picture MIME type");r||(s=!1),this.frames.push({name:"APIC",value:e,pictureType:t,mimeType:n,useUnicodeEncoding:s,description:i,size:Nt(e.byteLength,n.length,i.length,s)})}_setLyricsFrame(t,e,r){const s=t.split("").map(g=>g.charCodeAt(0)),n=e.toString(),i=r.toString();var o,d;this.frames.push({name:"USLT",value:i,language:s,description:n,size:(o=n.length,d=i.length,16+2*o+2+2+2*d)})}_setCommentFrame(t,e,r){const s=t.split("").map(g=>g.charCodeAt(0)),n=e.toString(),i=r.toString();var o,d;this.frames.push({name:"COMM",value:i,language:s,description:n,size:(o=n.length,d=i.length,16+2*o+2+2+2*d)})}_setPrivateFrame(t,e){const r=t.toString();var s,n;this.frames.push({name:"PRIV",value:e,id:r,size:(s=r.length,n=e.byteLength,10+s+1+n)})}_setUserStringFrame(t,e){const r=t.toString(),s=e.toString();var n,i;this.frames.push({name:"TXXX",description:r,value:s,size:(n=r.length,i=s.length,13+2*n+2+2+2*i)})}_setUrlLinkFrame(t,e){const r=e.toString();var s;this.frames.push({name:t,value:r,size:(s=r.length,10+s)})}_setPairedTextFrame(t,e){this.frames.push({name:t,value:e,size:Mt(e)})}_setSynchronisedLyricsFrame(t,e,r,s,n){const i=n.toString(),o=s.split("").map(d=>d.charCodeAt(0));this.frames.push({name:"SYLT",value:e,language:o,description:i,type:t,timestampFormat:r,size:Lt(e,i.length)})}constructor(t){if(!t||typeof t!="object"||!("byteLength"in t))throw new Error("First argument should be an instance of ArrayBuffer or Buffer");this.arrayBuffer=t,this.padding=4096,this.frames=[],this.url=""}setFrame(t,e){switch(t){case"TPE1":case"TCOM":case"TCON":{if(!Array.isArray(e))throw new Error(`${t} frame value should be an array of strings`);const r=t==="TCON"?";":"/",s=e.join(r);this._setStringFrame(t,s);break}case"TLAN":case"TIT1":case"TIT2":case"TIT3":case"TALB":case"TPE2":case"TPE3":case"TPE4":case"TRCK":case"TPOS":case"TMED":case"TPUB":case"TCOP":case"TKEY":case"TEXT":case"TDAT":case"TCMP":case"TSRC":this._setStringFrame(t,e);break;case"TBPM":case"TLEN":case"TYER":this._setIntegerFrame(t,e);break;case"USLT":if(e.language=e.language||"eng",typeof e!="object"||!("description"in e)||!("lyrics"in e))throw new Error("USLT frame value should be an object with keys description and lyrics");if(e.language&&!e.language.match(/[a-z]{3}/i))throw new Error("Language must be coded following the ISO 639-2 standards");this._setLyricsFrame(e.language,e.description,e.lyrics);break;case"APIC":if(typeof e!="object"||!("type"in e)||!("data"in e)||!("description"in e))throw new Error("APIC frame value should be an object with keys type, data and description");if(e.type<0||e.type>20)throw new Error("Incorrect APIC frame picture type");this._setPictureFrame(e.type,e.data,e.description,!!e.useUnicodeEncoding);break;case"TXXX":if(typeof e!="object"||!("description"in e)||!("value"in e))throw new Error("TXXX frame value should be an object with keys description and value");this._setUserStringFrame(e.description,e.value);break;case"WCOM":case"WCOP":case"WOAF":case"WOAR":case"WOAS":case"WORS":case"WPAY":case"WPUB":this._setUrlLinkFrame(t,e);break;case"COMM":if(e.language=e.language||"eng",typeof e!="object"||!("description"in e)||!("text"in e))throw new Error("COMM frame value should be an object with keys description and text");if(e.language&&!e.language.match(/[a-z]{3}/i))throw new Error("Language must be coded following the ISO 639-2 standards");this._setCommentFrame(e.language,e.description,e.text);break;case"PRIV":if(typeof e!="object"||!("id"in e)||!("data"in e))throw new Error("PRIV frame value should be an object with keys id and data");this._setPrivateFrame(e.id,e.data);break;case"IPLS":if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Error("IPLS frame value should be an array of pairs");this._setPairedTextFrame(t,e);break;case"SYLT":if(typeof e!="object"||!("type"in e)||!("text"in e)||!("timestampFormat"in e))throw new Error("SYLT frame value should be an object with keys type, text and timestampFormat");if(!Array.isArray(e.text)||!Array.isArray(e.text[0]))throw new Error("SYLT frame text value should be an array of pairs");if(e.type<0||e.type>6)throw new Error("Incorrect SYLT frame content type");if(e.timestampFormat<1||e.timestampFormat>2)throw new Error("Incorrect SYLT frame time stamp format");e.language=e.language||"eng",e.description=e.description||"",this._setSynchronisedLyricsFrame(e.type,e.text,e.timestampFormat,e.language,e.description);break;default:throw new Error(`Unsupported frame ${t}`)}return this}removeTag(){if(this.arrayBuffer.byteLength<10)return;const t=new Uint8Array(this.arrayBuffer),e=t[3],r=((s=[t[6],t[7],t[8],t[9]])[0]<<21)+(s[1]<<14)+(s[2]<<7)+s[3]+10;var s,n;(n=t)[0]!==73||n[1]!==68||n[2]!==51||e<2||e>4||(this.arrayBuffer=new Uint8Array(t.subarray(r)).buffer)}addTag(){this.removeTag();const t=[255,254],e=10+this.frames.reduce((o,d)=>o+d.size,0)+this.padding,r=new ArrayBuffer(this.arrayBuffer.byteLength+e),s=new Uint8Array(r);let n=0,i=[];return i=[73,68,51,3],s.set(i,n),n+=i.length,n++,n++,i=function(o){return[o>>>21&127,o>>>14&127,o>>>7&127,o&127]}(e-10),s.set(i,n),n+=i.length,this.frames.forEach(o=>{switch(i=ee(o.name),s.set(i,n),n+=i.length,i=He(o.size-10),s.set(i,n),n+=i.length,n+=2,o.name){case"WCOM":case"WCOP":case"WOAF":case"WOAR":case"WOAS":case"WORS":case"WPAY":case"WPUB":i=ee(o.value),s.set(i,n),n+=i.length;break;case"TPE1":case"TCOM":case"TCON":case"TLAN":case"TIT1":case"TIT2":case"TIT3":case"TALB":case"TPE2":case"TPE3":case"TPE4":case"TRCK":case"TPOS":case"TKEY":case"TMED":case"TPUB":case"TCOP":case"TEXT":case"TSRC":i=[1].concat(t),s.set(i,n),n+=i.length,i=j(o.value),s.set(i,n),n+=i.length;break;case"TXXX":case"USLT":case"COMM":i=[1],o.name!=="USLT"&&o.name!=="COMM"||(i=i.concat(o.language)),i=i.concat(t),s.set(i,n),n+=i.length,i=j(o.description),s.set(i,n),n+=i.length,i=[0,0].concat(t),s.set(i,n),n+=i.length,i=j(o.value),s.set(i,n),n+=i.length;break;case"TBPM":case"TLEN":case"TDAT":case"TYER":n++,i=ee(o.value),s.set(i,n),n+=i.length;break;case"PRIV":i=ee(o.id),s.set(i,n),n+=i.length,n++,s.set(new Uint8Array(o.value),n),n+=o.value.byteLength;break;case"APIC":i=[o.useUnicodeEncoding?1:0],s.set(i,n),n+=i.length,i=ee(o.mimeType),s.set(i,n),n+=i.length,i=[0,o.pictureType],s.set(i,n),n+=i.length,o.useUnicodeEncoding?(i=[].concat(t),s.set(i,n),n+=i.length,i=j(o.description),s.set(i,n),n+=i.length,n+=2):(i=ee(o.description),s.set(i,n),n+=i.length,n++),s.set(new Uint8Array(o.value),n),n+=o.value.byteLength;break;case"IPLS":i=[1],s.set(i,n),n+=i.length,o.value.forEach(d=>{i=[].concat(t),s.set(i,n),n+=i.length,i=j(d[0].toString()),s.set(i,n),n+=i.length,i=[0,0].concat(t),s.set(i,n),n+=i.length,i=j(d[1].toString()),s.set(i,n),n+=i.length,i=[0,0],s.set(i,n),n+=i.length});break;case"SYLT":i=[1].concat(o.language).concat(o.timestampFormat).concat(o.type),s.set(i,n),n+=i.length,i=[].concat(t),s.set(i,n),n+=i.length,i=j(o.description),s.set(i,n),n+=i.length,n+=2,o.value.forEach(d=>{i=[].concat(t),s.set(i,n),n+=i.length,i=j(d[0].toString()),s.set(i,n),n+=i.length,i=[0,0],s.set(i,n),n+=i.length,i=He(d[1]),s.set(i,n),n+=i.length})}}),n+=this.padding,s.set(new Uint8Array(this.arrayBuffer),n),this.arrayBuffer=r,r}getBlob(){return new Blob([this.arrayBuffer],{type:"audio/mpeg"})}getURL(){return this.url||(this.url=URL.createObjectURL(this.getBlob())),this.url}revokeURL(){URL.revokeObjectURL(this.url)}}const Ct=x.create("Mp3TagWriter");class xt{writer;constructor(t){this.writer=new Ut(t)}setTitle(t){if(!t)throw new Error("Invalid value for title");this.writer.setFrame("TIT2",t)}setArtists(t){if(!t||t.length<1)throw new Error("Invalid value for artists");this.writer.setFrame("TPE1",t)}setAlbum(t){if(!t)throw new Error("Invalid value for album");this.writer.setFrame("TALB",t)}setComment(t){if(!t)throw new Error("Invalid value for comment");this.writer.setFrame("COMM",{text:t,description:""})}setTrackNumber(t){if(t<1||t>32767)throw new Error("Invalid value for trackNumber");this.writer.setFrame("TRCK",t.toString())}setYear(t){if(t<1)throw new Error("Invalud value for year");this.writer.setFrame("TYER",t)}setGrouping(t){if(!t)throw new Error("Invalid value for grouping");this.writer.setFrame("TIT1",t)}setArtwork(t){if(!t||t.byteLength<1)throw new Error("Invalid value for artworkBuffer");this.writer.setFrame("APIC",{type:3,data:t,description:""})}setSoundCloudTrackId(t){if(!t)throw new Error("Invalid value for SoundCloud Track ID");Ct.logDebug(`Attempting to set SoundCloudTrackID: ${t}`),this.writer.setFrame("TXXX",{description:"SoundCloudTrackID",value:t})}getBuffer(){return this.writer.addTag(),this.writer.getBlob().arrayBuffer().then(t=>({buffer:t,tagsApplied:!0}))}}function Bt(a){if(typeof a!="string")throw new TypeError("Expected a string");return a.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}var ye=(a=>(a[a.Main=0]="Main",a[a.Feature=1]="Feature",a[a.Remixer=2]="Remixer",a[a.Producer=3]="Producer",a))(ye||{}),Te=(a=>(a[a.Remix=0]="Remix",a[a.Flip=1]="Flip",a[a.Bootleg=2]="Bootleg",a[a.Mashup=3]="Mashup",a[a.Edit=4]="Edit",a))(Te||{});function Xt(a){switch(a.toLowerCase().trim()){case"flip":return 1;case"bootleg":return 2;case"mashup":return 3;case"edit":return 4;case"remix":default:return 0}}function Ht(a,t){return a.map((e,r)=>({data:e,index:r})).sort((e,r)=>e.data[t]<r.data[t]?-1:e.data[t]>r.data[t]?1:e.index-r.index).map(e=>e.data)}class U{constructor(t,e,r){this.title=t,this.username=e,this.userPermalink=r}static titleSeparators=["-","\u2013","\u2014","~"];static featureSeparators=["featuring","feat.","feat","ft."," ft ","w/"," w /"," w ","+"];static combiningFeatureSeparators=[...U.featureSeparators,", "," & "," x "];static remixIndicators=["remix","flip","bootleg","mashup","edit"];static producerIndicators=["prod. by ","prod by ","prod. ","p. ","prod "];static promotions=["free download","video in description","video in desc","vid in desc","Original Mix"];getArtists(){const t=this.preprocessTitle(this.title);let e=[];const r=this.splitByTitleSeparators(t,!0);e=e.concat(r.artistNames.map((g,f)=>({name:g,type:f===0?0:1})));const s=this.splitByProducer(r.title,!0);e=e.concat(s.artistNames.map(g=>({name:g,type:3})));const n=this.splitByRemix(s.title,!0);e=e.concat(n.artists);const i=this.splitByUnsafeProducers(n.title,!0);e=e.concat(i.artistNames.map(g=>({name:g,type:3})));const o=this.splitByFeatures(n.title,!0);if(e=e.concat(o.artistNames.map(g=>({name:g,type:1}))),!e.some(g=>g.type===0)){const g={name:this.sanitizeArtistName(this.username)||this.userPermalink,type:0};g.name&&(e.length>0?e=[g,...e]:e.push(g))}e=e.map(g=>this.removeTwitterHandle(g));const d=[];for(const g of e)d.some(f=>f.name==g.name)||d.push(g);return Ht(d,"type")}getTitle(){let t=this.preprocessTitle(this.title);return t=this.splitByTitleSeparators(t,!1).title,t=this.splitByProducer(t,!1).title,t=this.splitByRemix(t,!1).title,t=this.splitByFeatures(t,!1).title,t=this.splitByUnsafeProducers(t,!1).title,this.sanitizeTitle(t)}removeTwitterHandle(t){t.name=t.name.replace(/^[@]+/,"");const e=/^([^(]+)\s?\(\s?@.+\)?$/.exec(t.name);return e&&e.length>1&&(t.name=e[1].trimEnd()),t}splitByTitleSeparators(t,e){let r=[];if(this.includes(t,U.titleSeparators)){const s=this.escapeRegexArray(U.titleSeparators),n=new RegExp(`^((.+)\\s[${s}]\\s)(.+)$`).exec(t);if(n&&n.length>0){const[i,o,d]=n;e&&(r=this.getArtistNames(d)),t=t.replace(o,"")}}return{artistNames:r,title:t}}splitByFeatures(t,e){let r=[];if(this.includes(t,U.featureSeparators)){const s=this.escapeRegexArray(U.featureSeparators).join("|"),n=new RegExp(`(?:${s})([^\\[\\]\\(\\)]+)`,"i").exec(t);if(n&&n.length>0){const[i,o]=n;e&&(r=this.getArtistNames(o)),t=t.replace(i,"")}}return{artistNames:r,title:t}}splitByProducer(t,e){let r=[];if(this.includes(t,U.producerIndicators)){const s=this.escapeRegexArray(U.producerIndicators).join("|"),n=new RegExp(`(?:${s})([^\\[\\]\\(\\)]+)`,"i").exec(t);if(n&&n.length>0){const[i,o]=n;e&&(r=this.getArtistNames(o)),t=t.replace(i,"")}}return{artistNames:r,title:t}}splitByUnsafeProducers(t,e){let r=[];const s=this.escapeRegexArray(U.featureSeparators).join("|"),n=new RegExp(`[\\(\\[](?!${s})(.+)[\\)\\]]`,"i").exec(t);if(n&&n.length>0){const[i,o]=n;e&&(r=this.getArtistNames(o)),t=t.replace(i,"")}return{artistNames:r,title:t}}splitByRemix(t,e){let r=[];if(this.includes(t,U.remixIndicators)){const s=this.escapeRegexArray(U.remixIndicators).join("|"),n=new RegExp(`[\\[\\(](.+)(${s})[\\]\\)]`,"i").exec(t);if(n&&n.length>0){const[i,o,d]=n;if(e){const g=this.getArtistNames(o),f=Xt(d);r=g.map(m=>({name:m,type:2,remixType:f}))}t=t.replace(i,"")}}return{artists:r,title:t}}getArtistNames(t){const e=this.escapeRegexArray(U.combiningFeatureSeparators).join("|"),r=new RegExp(`(.+)\\s?(${e})\\s?(.+)`,"i"),s=[];for(;;){const n=r.exec(t);if(!n){s.push(this.sanitizeArtistName(t));break}s.push(this.sanitizeArtistName(n[3])),t=n[1]}return s.reverse()}preprocessTitle(t){t=t.replace(/\+([+]+)/g,"+");const e=U.promotions.join("|"),r=new RegExp(`[\\[\\(]?\\s*(${e})\\s*[\\]\\)]?`,"i");return t.replace(r,"")}sanitizeArtistName(t){return this.removeNonAsciiCharacters(t).trim()}sanitizeTitle(t){let e=this.removeNonAsciiCharacters(t);return e=e.replace("()","").replace("[]",""),e.trim()}removeNonAsciiCharacters(t){return Fe.replace(t,Fe("[^\\p{L}\\p{N}\\p{Zs}\0-\x7F]","g"),"")}includes(t,e){const r=t.toLowerCase();return e.some(s=>r.includes(s))}escapeRegexArray(t){return t.map(e=>Bt(e))}}var Ie=function(){function a(){this.listeners={}}var t=a.prototype;return t.on=function(e,r){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(r)},t.off=function(e,r){if(!this.listeners[e])return!1;var s=this.listeners[e].indexOf(r);return this.listeners[e]=this.listeners[e].slice(0),this.listeners[e].splice(s,1),s>-1},t.trigger=function(e){var r=this.listeners[e];if(r)if(arguments.length===2)for(var s=r.length,n=0;n<s;++n)r[n].call(this,arguments[1]);else for(var i=Array.prototype.slice.call(arguments,1),o=r.length,d=0;d<o;++d)r[d].apply(this,i)},t.dispose=function(){this.listeners={}},t.pipe=function(e){this.on("data",function(r){e.push(r)})},a}();function te(){return te=Object.assign?Object.assign.bind():function(a){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var r in e)({}).hasOwnProperty.call(e,r)&&(a[r]=e[r])}return a},te.apply(null,arguments)}var Ae,Ge;function Wt(){if(Ge)return Ae;Ge=1;var a;return typeof window<"u"?a=window:typeof _e<"u"?a=_e:typeof self<"u"?a=self:a={},Ae=a,Ae}var Gt=Wt();const qe=ht(Gt);var qt=function(a){return qe.atob?qe.atob(a):Buffer.from(a,"base64").toString("binary")};function Yt(a){for(var t=qt(a),e=new Uint8Array(t.length),r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */class jt extends Ie{constructor(){super(),this.buffer=""}push(t){let e;for(this.buffer+=t,e=this.buffer.indexOf(`
`);e>-1;e=this.buffer.indexOf(`
`))this.trigger("data",this.buffer.substring(0,e)),this.buffer=this.buffer.substring(e+1)}}const Vt="	",$e=function(a){const t=/([0-9.]*)?@?([0-9.]*)?/.exec(a||""),e={};return t[1]&&(e.length=parseInt(t[1],10)),t[2]&&(e.offset=parseInt(t[2],10)),e},Qt=function(){const a='(?:[^=]*)=(?:"[^"]*"|[^,]*)';return new RegExp("(?:^|,)("+a+")")},M=function(a){const t={};if(!a)return t;const e=a.split(Qt());let r=e.length,s;for(;r--;)e[r]!==""&&(s=/([^=]*)=(.*)/.exec(e[r]).slice(1),s[0]=s[0].replace(/^\s+|\s+$/g,""),s[1]=s[1].replace(/^\s+|\s+$/g,""),s[1]=s[1].replace(/^['"](.*)['"]$/g,"$1"),t[s[0]]=s[1]);return t},Ye=a=>{const t=a.split("x"),e={};return t[0]&&(e.width=parseInt(t[0],10)),t[1]&&(e.height=parseInt(t[1],10)),e};class zt extends Ie{constructor(){super(),this.customParsers=[],this.tagMappers=[]}push(t){let e,r;if(t=t.trim(),t.length!==0){if(t[0]!=="#"){this.trigger("data",{type:"uri",uri:t});return}this.tagMappers.reduce((s,n)=>{const i=n(t);return i===t?s:s.concat([i])},[t]).forEach(s=>{for(let n=0;n<this.customParsers.length;n++)if(this.customParsers[n].call(this,s))return;if(s.indexOf("#EXT")!==0){this.trigger("data",{type:"comment",text:s.slice(1)});return}if(s=s.replace("\r",""),e=/^#EXTM3U/.exec(s),e){this.trigger("data",{type:"tag",tagType:"m3u"});return}if(e=/^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(s),e){r={type:"tag",tagType:"inf"},e[1]&&(r.duration=parseFloat(e[1])),e[2]&&(r.title=e[2]),this.trigger("data",r);return}if(e=/^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"targetduration"},e[1]&&(r.duration=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-VERSION:([0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"version"},e[1]&&(r.version=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"media-sequence"},e[1]&&(r.number=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(s),e){r={type:"tag",tagType:"discontinuity-sequence"},e[1]&&(r.number=parseInt(e[1],10)),this.trigger("data",r);return}if(e=/^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(s),e){r={type:"tag",tagType:"playlist-type"},e[1]&&(r.playlistType=e[1]),this.trigger("data",r);return}if(e=/^#EXT-X-BYTERANGE:(.*)?$/.exec(s),e){r=te($e(e[1]),{type:"tag",tagType:"byterange"}),this.trigger("data",r);return}if(e=/^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(s),e){r={type:"tag",tagType:"allow-cache"},e[1]&&(r.allowed=!/NO/.test(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-MAP:(.*)$/.exec(s),e){if(r={type:"tag",tagType:"map"},e[1]){const n=M(e[1]);n.URI&&(r.uri=n.URI),n.BYTERANGE&&(r.byterange=$e(n.BYTERANGE))}this.trigger("data",r);return}if(e=/^#EXT-X-STREAM-INF:(.*)$/.exec(s),e){r={type:"tag",tagType:"stream-inf"},e[1]&&(r.attributes=M(e[1]),r.attributes.RESOLUTION&&(r.attributes.RESOLUTION=Ye(r.attributes.RESOLUTION)),r.attributes.BANDWIDTH&&(r.attributes.BANDWIDTH=parseInt(r.attributes.BANDWIDTH,10)),r.attributes["FRAME-RATE"]&&(r.attributes["FRAME-RATE"]=parseFloat(r.attributes["FRAME-RATE"])),r.attributes["PROGRAM-ID"]&&(r.attributes["PROGRAM-ID"]=parseInt(r.attributes["PROGRAM-ID"],10))),this.trigger("data",r);return}if(e=/^#EXT-X-MEDIA:(.*)$/.exec(s),e){r={type:"tag",tagType:"media"},e[1]&&(r.attributes=M(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-ENDLIST/.exec(s),e){this.trigger("data",{type:"tag",tagType:"endlist"});return}if(e=/^#EXT-X-DISCONTINUITY/.exec(s),e){this.trigger("data",{type:"tag",tagType:"discontinuity"});return}if(e=/^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(s),e){r={type:"tag",tagType:"program-date-time"},e[1]&&(r.dateTimeString=e[1],r.dateTimeObject=new Date(e[1])),this.trigger("data",r);return}if(e=/^#EXT-X-KEY:(.*)$/.exec(s),e){r={type:"tag",tagType:"key"},e[1]&&(r.attributes=M(e[1]),r.attributes.IV&&(r.attributes.IV.substring(0,2).toLowerCase()==="0x"&&(r.attributes.IV=r.attributes.IV.substring(2)),r.attributes.IV=r.attributes.IV.match(/.{8}/g),r.attributes.IV[0]=parseInt(r.attributes.IV[0],16),r.attributes.IV[1]=parseInt(r.attributes.IV[1],16),r.attributes.IV[2]=parseInt(r.attributes.IV[2],16),r.attributes.IV[3]=parseInt(r.attributes.IV[3],16),r.attributes.IV=new Uint32Array(r.attributes.IV))),this.trigger("data",r);return}if(e=/^#EXT-X-START:(.*)$/.exec(s),e){r={type:"tag",tagType:"start"},e[1]&&(r.attributes=M(e[1]),r.attributes["TIME-OFFSET"]=parseFloat(r.attributes["TIME-OFFSET"]),r.attributes.PRECISE=/YES/.test(r.attributes.PRECISE)),this.trigger("data",r);return}if(e=/^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(s),e){r={type:"tag",tagType:"cue-out-cont"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-CUE-OUT:(.*)?$/.exec(s),e){r={type:"tag",tagType:"cue-out"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-CUE-IN:?(.*)?$/.exec(s),e){r={type:"tag",tagType:"cue-in"},e[1]?r.data=e[1]:r.data="",this.trigger("data",r);return}if(e=/^#EXT-X-SKIP:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"skip"},r.attributes=M(e[1]),r.attributes.hasOwnProperty("SKIPPED-SEGMENTS")&&(r.attributes["SKIPPED-SEGMENTS"]=parseInt(r.attributes["SKIPPED-SEGMENTS"],10)),r.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")&&(r.attributes["RECENTLY-REMOVED-DATERANGES"]=r.attributes["RECENTLY-REMOVED-DATERANGES"].split(Vt)),this.trigger("data",r);return}if(e=/^#EXT-X-PART:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"part"},r.attributes=M(e[1]),["DURATION"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),["INDEPENDENT","GAP"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=/YES/.test(r.attributes[n]))}),r.attributes.hasOwnProperty("BYTERANGE")&&(r.attributes.byterange=$e(r.attributes.BYTERANGE)),this.trigger("data",r);return}if(e=/^#EXT-X-SERVER-CONTROL:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"server-control"},r.attributes=M(e[1]),["CAN-SKIP-UNTIL","PART-HOLD-BACK","HOLD-BACK"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),["CAN-SKIP-DATERANGES","CAN-BLOCK-RELOAD"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=/YES/.test(r.attributes[n]))}),this.trigger("data",r);return}if(e=/^#EXT-X-PART-INF:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"part-inf"},r.attributes=M(e[1]),["PART-TARGET"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseFloat(r.attributes[n]))}),this.trigger("data",r);return}if(e=/^#EXT-X-PRELOAD-HINT:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"preload-hint"},r.attributes=M(e[1]),["BYTERANGE-START","BYTERANGE-LENGTH"].forEach(function(n){if(r.attributes.hasOwnProperty(n)){r.attributes[n]=parseInt(r.attributes[n],10);const i=n==="BYTERANGE-LENGTH"?"length":"offset";r.attributes.byterange=r.attributes.byterange||{},r.attributes.byterange[i]=r.attributes[n],delete r.attributes[n]}}),this.trigger("data",r);return}if(e=/^#EXT-X-RENDITION-REPORT:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"rendition-report"},r.attributes=M(e[1]),["LAST-MSN","LAST-PART"].forEach(function(n){r.attributes.hasOwnProperty(n)&&(r.attributes[n]=parseInt(r.attributes[n],10))}),this.trigger("data",r);return}if(e=/^#EXT-X-DATERANGE:(.*)$/.exec(s),e&&e[1]){r={type:"tag",tagType:"daterange"},r.attributes=M(e[1]),["ID","CLASS"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=String(r.attributes[i]))}),["START-DATE","END-DATE"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=new Date(r.attributes[i]))}),["DURATION","PLANNED-DURATION"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=parseFloat(r.attributes[i]))}),["END-ON-NEXT"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=/YES/i.test(r.attributes[i]))}),["SCTE35-CMD"," SCTE35-OUT","SCTE35-IN"].forEach(function(i){r.attributes.hasOwnProperty(i)&&(r.attributes[i]=r.attributes[i].toString(16))});const n=/^X-([A-Z]+-)+[A-Z]+$/;for(const i in r.attributes){if(!n.test(i))continue;const o=/[0-9A-Fa-f]{6}/g.test(r.attributes[i]),d=/^\d+(\.\d+)?$/.test(r.attributes[i]);r.attributes[i]=o?r.attributes[i].toString(16):d?parseFloat(r.attributes[i]):String(r.attributes[i])}this.trigger("data",r);return}if(e=/^#EXT-X-INDEPENDENT-SEGMENTS/.exec(s),e){this.trigger("data",{type:"tag",tagType:"independent-segments"});return}if(e=/^#EXT-X-I-FRAMES-ONLY/.exec(s),e){this.trigger("data",{type:"tag",tagType:"i-frames-only"});return}if(e=/^#EXT-X-CONTENT-STEERING:(.*)$/.exec(s),e){r={type:"tag",tagType:"content-steering"},r.attributes=M(e[1]),this.trigger("data",r);return}if(e=/^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(s),e){r={type:"tag",tagType:"i-frame-playlist"},r.attributes=M(e[1]),r.attributes.URI&&(r.uri=r.attributes.URI),r.attributes.BANDWIDTH&&(r.attributes.BANDWIDTH=parseInt(r.attributes.BANDWIDTH,10)),r.attributes.RESOLUTION&&(r.attributes.RESOLUTION=Ye(r.attributes.RESOLUTION)),r.attributes["AVERAGE-BANDWIDTH"]&&(r.attributes["AVERAGE-BANDWIDTH"]=parseInt(r.attributes["AVERAGE-BANDWIDTH"],10)),r.attributes["FRAME-RATE"]&&(r.attributes["FRAME-RATE"]=parseFloat(r.attributes["FRAME-RATE"])),this.trigger("data",r);return}if(e=/^#EXT-X-DEFINE:(.*)$/.exec(s),e){r={type:"tag",tagType:"define"},r.attributes=M(e[1]),this.trigger("data",r);return}this.trigger("data",{type:"tag",data:s.slice(4)})})}}addParser({expression:t,customType:e,dataParser:r,segment:s}){typeof r!="function"&&(r=n=>n),this.customParsers.push(n=>{if(t.exec(n))return this.trigger("data",{type:"custom",data:r(n),customType:e,segment:s}),!0})}addTagMapper({expression:t,map:e}){const r=s=>t.test(s)?e(s):s;this.tagMappers.push(r)}}const Kt=a=>a.toLowerCase().replace(/-(\w)/g,t=>t[1].toUpperCase()),V=function(a){const t={};return Object.keys(a).forEach(function(e){t[Kt(e)]=a[e]}),t},De=function(a){const{serverControl:t,targetDuration:e,partTargetDuration:r}=a;if(!t)return;const s="#EXT-X-SERVER-CONTROL",n="holdBack",i="partHoldBack",o=e&&e*3,d=r&&r*2;e&&!t.hasOwnProperty(n)&&(t[n]=o,this.trigger("info",{message:`${s} defaulting HOLD-BACK to targetDuration * 3 (${o}).`})),o&&t[n]<o&&(this.trigger("warn",{message:`${s} clamping HOLD-BACK (${t[n]}) to targetDuration * 3 (${o})`}),t[n]=o),r&&!t.hasOwnProperty(i)&&(t[i]=r*3,this.trigger("info",{message:`${s} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${t[i]}).`})),r&&t[i]<d&&(this.trigger("warn",{message:`${s} clamping PART-HOLD-BACK (${t[i]}) to partTargetDuration * 2 (${d}).`}),t[i]=d)};class Jt extends Ie{constructor(t={}){super(),this.lineStream=new jt,this.parseStream=new zt,this.lineStream.pipe(this.parseStream),this.mainDefinitions=t.mainDefinitions||{},this.params=new URL(t.uri,"https://a.com").searchParams,this.lastProgramDateTime=null;const e=this,r=[];let s={},n,i,o=!1;const d=function(){},g={AUDIO:{},VIDEO:{},"CLOSED-CAPTIONS":{},SUBTITLES:{}},f="urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";let m=0;this.manifest={allowCache:!0,discontinuityStarts:[],dateRanges:[],iFramePlaylists:[],segments:[]};let E=0,y=0;const I={};this.on("end",()=>{s.uri||!s.parts&&!s.preloadHints||(!s.map&&n&&(s.map=n),!s.key&&i&&(s.key=i),!s.timeline&&typeof m=="number"&&(s.timeline=m),this.manifest.preloadSegment=s)}),this.parseStream.on("data",function(l){let R,F;if(e.manifest.definitions){for(const u in e.manifest.definitions)if(l.uri&&(l.uri=l.uri.replace(`{$${u}}`,e.manifest.definitions[u])),l.attributes)for(const c in l.attributes)typeof l.attributes[c]=="string"&&(l.attributes[c]=l.attributes[c].replace(`{$${u}}`,e.manifest.definitions[u]))}({tag(){({version(){l.version&&(this.manifest.version=l.version)},"allow-cache"(){this.manifest.allowCache=l.allowed,"allowed"in l||(this.trigger("info",{message:"defaulting allowCache to YES"}),this.manifest.allowCache=!0)},byterange(){const u={};"length"in l&&(s.byterange=u,u.length=l.length,"offset"in l||(l.offset=E)),"offset"in l&&(s.byterange=u,u.offset=l.offset),E=u.offset+u.length},endlist(){this.manifest.endList=!0},inf(){"mediaSequence"in this.manifest||(this.manifest.mediaSequence=0,this.trigger("info",{message:"defaulting media sequence to zero"})),"discontinuitySequence"in this.manifest||(this.manifest.discontinuitySequence=0,this.trigger("info",{message:"defaulting discontinuity sequence to zero"})),l.title&&(s.title=l.title),l.duration>0&&(s.duration=l.duration),l.duration===0&&(s.duration=.01,this.trigger("info",{message:"updating zero segment duration to a small value"})),this.manifest.segments=r},key(){if(!l.attributes){this.trigger("warn",{message:"ignoring key declaration without attribute list"});return}if(l.attributes.METHOD==="NONE"){i=null;return}if(!l.attributes.URI){this.trigger("warn",{message:"ignoring key declaration without URI"});return}if(l.attributes.KEYFORMAT==="com.apple.streamingkeydelivery"){this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.apple.fps.1_0"]={attributes:l.attributes};return}if(l.attributes.KEYFORMAT==="com.microsoft.playready"){this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.microsoft.playready"]={uri:l.attributes.URI};return}if(l.attributes.KEYFORMAT===f){if(["SAMPLE-AES","SAMPLE-AES-CTR","SAMPLE-AES-CENC"].indexOf(l.attributes.METHOD)===-1){this.trigger("warn",{message:"invalid key method provided for Widevine"});return}if(l.attributes.METHOD==="SAMPLE-AES-CENC"&&this.trigger("warn",{message:"SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"}),l.attributes.URI.substring(0,23)!=="data:text/plain;base64,"){this.trigger("warn",{message:"invalid key URI provided for Widevine"});return}if(!(l.attributes.KEYID&&l.attributes.KEYID.substring(0,2)==="0x")){this.trigger("warn",{message:"invalid key ID provided for Widevine"});return}this.manifest.contentProtection=this.manifest.contentProtection||{},this.manifest.contentProtection["com.widevine.alpha"]={attributes:{schemeIdUri:l.attributes.KEYFORMAT,keyId:l.attributes.KEYID.substring(2)},pssh:Yt(l.attributes.URI.split(",")[1])};return}l.attributes.METHOD||this.trigger("warn",{message:"defaulting key method to AES-128"}),i={method:l.attributes.METHOD||"AES-128",uri:l.attributes.URI},typeof l.attributes.IV<"u"&&(i.iv=l.attributes.IV)},"media-sequence"(){if(!isFinite(l.number)){this.trigger("warn",{message:"ignoring invalid media sequence: "+l.number});return}this.manifest.mediaSequence=l.number},"discontinuity-sequence"(){if(!isFinite(l.number)){this.trigger("warn",{message:"ignoring invalid discontinuity sequence: "+l.number});return}this.manifest.discontinuitySequence=l.number,m=l.number},"playlist-type"(){if(!/VOD|EVENT/.test(l.playlistType)){this.trigger("warn",{message:"ignoring unknown playlist type: "+l.playlist});return}this.manifest.playlistType=l.playlistType},map(){n={},l.uri&&(n.uri=l.uri),l.byterange&&(n.byterange=l.byterange),i&&(n.key=i)},"stream-inf"(){if(this.manifest.playlists=r,this.manifest.mediaGroups=this.manifest.mediaGroups||g,!l.attributes){this.trigger("warn",{message:"ignoring empty stream-inf attributes"});return}s.attributes||(s.attributes={}),te(s.attributes,l.attributes)},media(){if(this.manifest.mediaGroups=this.manifest.mediaGroups||g,!(l.attributes&&l.attributes.TYPE&&l.attributes["GROUP-ID"]&&l.attributes.NAME)){this.trigger("warn",{message:"ignoring incomplete or missing media group"});return}const u=this.manifest.mediaGroups[l.attributes.TYPE];u[l.attributes["GROUP-ID"]]=u[l.attributes["GROUP-ID"]]||{},R=u[l.attributes["GROUP-ID"]],F={default:/yes/i.test(l.attributes.DEFAULT)},F.default?F.autoselect=!0:F.autoselect=/yes/i.test(l.attributes.AUTOSELECT),l.attributes.LANGUAGE&&(F.language=l.attributes.LANGUAGE),l.attributes.URI&&(F.uri=l.attributes.URI),l.attributes["INSTREAM-ID"]&&(F.instreamId=l.attributes["INSTREAM-ID"]),l.attributes.CHARACTERISTICS&&(F.characteristics=l.attributes.CHARACTERISTICS),l.attributes.FORCED&&(F.forced=/yes/i.test(l.attributes.FORCED)),R[l.attributes.NAME]=F},discontinuity(){m+=1,s.discontinuity=!0,this.manifest.discontinuityStarts.push(r.length)},"program-date-time"(){typeof this.manifest.dateTimeString>"u"&&(this.manifest.dateTimeString=l.dateTimeString,this.manifest.dateTimeObject=l.dateTimeObject),s.dateTimeString=l.dateTimeString,s.dateTimeObject=l.dateTimeObject;const{lastProgramDateTime:u}=this;this.lastProgramDateTime=new Date(l.dateTimeString).getTime(),u===null&&this.manifest.segments.reduceRight((c,b)=>(b.programDateTime=c-b.duration*1e3,b.programDateTime),this.lastProgramDateTime)},targetduration(){if(!isFinite(l.duration)||l.duration<0){this.trigger("warn",{message:"ignoring invalid target duration: "+l.duration});return}this.manifest.targetDuration=l.duration,De.call(this,this.manifest)},start(){if(!l.attributes||isNaN(l.attributes["TIME-OFFSET"])){this.trigger("warn",{message:"ignoring start declaration without appropriate attribute list"});return}this.manifest.start={timeOffset:l.attributes["TIME-OFFSET"],precise:l.attributes.PRECISE}},"cue-out"(){s.cueOut=l.data},"cue-out-cont"(){s.cueOutCont=l.data},"cue-in"(){s.cueIn=l.data},skip(){this.manifest.skip=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-SKIP",l.attributes,["SKIPPED-SEGMENTS"])},part(){o=!0;const u=this.manifest.segments.length,c=V(l.attributes);s.parts=s.parts||[],s.parts.push(c),c.byterange&&(c.byterange.hasOwnProperty("offset")||(c.byterange.offset=y),y=c.byterange.offset+c.byterange.length);const b=s.parts.length-1;this.warnOnMissingAttributes_(`#EXT-X-PART #${b} for segment #${u}`,l.attributes,["URI","DURATION"]),this.manifest.renditionReports&&this.manifest.renditionReports.forEach((w,T)=>{w.hasOwnProperty("lastPart")||this.trigger("warn",{message:`#EXT-X-RENDITION-REPORT #${T} lacks required attribute(s): LAST-PART`})})},"server-control"(){const u=this.manifest.serverControl=V(l.attributes);u.hasOwnProperty("canBlockReload")||(u.canBlockReload=!1,this.trigger("info",{message:"#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"})),De.call(this,this.manifest),u.canSkipDateranges&&!u.hasOwnProperty("canSkipUntil")&&this.trigger("warn",{message:"#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"})},"preload-hint"(){const u=this.manifest.segments.length,c=V(l.attributes),b=c.type&&c.type==="PART";s.preloadHints=s.preloadHints||[],s.preloadHints.push(c),c.byterange&&(c.byterange.hasOwnProperty("offset")||(c.byterange.offset=b?y:0,b&&(y=c.byterange.offset+c.byterange.length)));const w=s.preloadHints.length-1;if(this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${w} for segment #${u}`,l.attributes,["TYPE","URI"]),!!c.type)for(let T=0;T<s.preloadHints.length-1;T++){const O=s.preloadHints[T];O.type&&O.type===c.type&&this.trigger("warn",{message:`#EXT-X-PRELOAD-HINT #${w} for segment #${u} has the same TYPE ${c.type} as preload hint #${T}`})}},"rendition-report"(){const u=V(l.attributes);this.manifest.renditionReports=this.manifest.renditionReports||[],this.manifest.renditionReports.push(u);const c=this.manifest.renditionReports.length-1,b=["LAST-MSN","URI"];o&&b.push("LAST-PART"),this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${c}`,l.attributes,b)},"part-inf"(){this.manifest.partInf=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-PART-INF",l.attributes,["PART-TARGET"]),this.manifest.partInf.partTarget&&(this.manifest.partTargetDuration=this.manifest.partInf.partTarget),De.call(this,this.manifest)},daterange(){this.manifest.dateRanges.push(V(l.attributes));const u=this.manifest.dateRanges.length-1;this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${u}`,l.attributes,["ID","START-DATE"]);const c=this.manifest.dateRanges[u];c.endDate&&c.startDate&&new Date(c.endDate)<new Date(c.startDate)&&this.trigger("warn",{message:"EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"}),c.duration&&c.duration<0&&this.trigger("warn",{message:"EXT-X-DATERANGE DURATION must not be negative"}),c.plannedDuration&&c.plannedDuration<0&&this.trigger("warn",{message:"EXT-X-DATERANGE PLANNED-DURATION must not be negative"});const b=!!c.endOnNext;if(b&&!c.class&&this.trigger("warn",{message:"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"}),b&&(c.duration||c.endDate)&&this.trigger("warn",{message:"EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"}),c.duration&&c.endDate){const w=c.startDate.getTime()+c.duration*1e3;this.manifest.dateRanges[u].endDate=new Date(w)}if(!I[c.id])I[c.id]=c;else{for(const T in I[c.id])if(c[T]&&JSON.stringify(I[c.id][T])!==JSON.stringify(c[T])){this.trigger("warn",{message:"EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"});break}const w=this.manifest.dateRanges.findIndex(T=>T.id===c.id);this.manifest.dateRanges[w]=te(this.manifest.dateRanges[w],c),I[c.id]=te(I[c.id],c),this.manifest.dateRanges.pop()}},"independent-segments"(){this.manifest.independentSegments=!0},"i-frames-only"(){this.manifest.iFramesOnly=!0,this.requiredCompatibilityversion(this.manifest.version,4)},"content-steering"(){this.manifest.contentSteering=V(l.attributes),this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING",l.attributes,["SERVER-URI"])},define(){this.manifest.definitions=this.manifest.definitions||{};const u=(c,b)=>{if(c in this.manifest.definitions){this.trigger("error",{message:`EXT-X-DEFINE: Duplicate name ${c}`});return}this.manifest.definitions[c]=b};if("QUERYPARAM"in l.attributes){if("NAME"in l.attributes||"IMPORT"in l.attributes){this.trigger("error",{message:"EXT-X-DEFINE: Invalid attributes"});return}const c=this.params.get(l.attributes.QUERYPARAM);if(!c){this.trigger("error",{message:`EXT-X-DEFINE: No query param ${l.attributes.QUERYPARAM}`});return}u(l.attributes.QUERYPARAM,decodeURIComponent(c));return}if("NAME"in l.attributes){if("IMPORT"in l.attributes){this.trigger("error",{message:"EXT-X-DEFINE: Invalid attributes"});return}if(!("VALUE"in l.attributes)||typeof l.attributes.VALUE!="string"){this.trigger("error",{message:`EXT-X-DEFINE: No value for ${l.attributes.NAME}`});return}u(l.attributes.NAME,l.attributes.VALUE);return}if("IMPORT"in l.attributes){if(!this.mainDefinitions[l.attributes.IMPORT]){this.trigger("error",{message:`EXT-X-DEFINE: No value ${l.attributes.IMPORT} to import, or IMPORT used on main playlist`});return}u(l.attributes.IMPORT,this.mainDefinitions[l.attributes.IMPORT]);return}this.trigger("error",{message:"EXT-X-DEFINE: No attribute"})},"i-frame-playlist"(){this.manifest.iFramePlaylists.push({attributes:l.attributes,uri:l.uri,timeline:m}),this.warnOnMissingAttributes_("#EXT-X-I-FRAME-STREAM-INF",l.attributes,["BANDWIDTH","URI"])}}[l.tagType]||d).call(e)},uri(){s.uri=l.uri,r.push(s),this.manifest.targetDuration&&!("duration"in s)&&(this.trigger("warn",{message:"defaulting segment duration to the target duration"}),s.duration=this.manifest.targetDuration),i&&(s.key=i),s.timeline=m,n&&(s.map=n),y=0,this.lastProgramDateTime!==null&&(s.programDateTime=this.lastProgramDateTime,this.lastProgramDateTime+=s.duration*1e3),s={}},comment(){},custom(){l.segment?(s.custom=s.custom||{},s.custom[l.customType]=l.data):(this.manifest.custom=this.manifest.custom||{},this.manifest.custom[l.customType]=l.data)}})[l.type].call(e)})}requiredCompatibilityversion(t,e){(t<e||!t)&&this.trigger("warn",{message:`manifest must be at least version ${e}`})}warnOnMissingAttributes_(t,e,r){const s=[];r.forEach(function(n){e.hasOwnProperty(n)||s.push(n)}),s.length&&this.trigger("warn",{message:`${t} lacks required attribute(s): ${s.join(", ")}`})}push(t){this.lineStream.push(t)}end(){this.lineStream.push(`
`),this.manifest.dateRanges.length&&this.lastProgramDateTime===null&&this.trigger("warn",{message:"A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"}),this.lastProgramDateTime=null,this.trigger("end")}addParser(t){this.parseStream.addParser(t)}addTagMapper(t){this.parseStream.addTagMapper(t)}}console.log("DOWNLOAD_HANDLER.TS IS BEING LOADED AND PARSED");const je=x.create("DownloadHandler_EarlyTest",X.Debug);je.logError("DOWNLOAD_HANDLER.TS - EARLY ERROR LOG TEST"),je.logDebug("DOWNLOAD_HANDLER.TS - EARLY DEBUG LOG TEST");class B extends Error{constructor(t,e){super(`${t} (TrackId: ${e})`)}}const h=x.create("DownloadHandler",X.Debug),re=new Pe;function Zt(a){return a&&a.kind==="track"&&a.state==="finished"&&(a.streamable||a.downloadable)}function er(a){return typeof a=="object"&&a!==null&&"protocol"in a}function tr(a){if(a?.media?.transcodings?.length<1)return h.logDebug(`[DownloadHandler TrackId: ${a.id}] No transcodings array or empty in track.media.`),null;h.logDebug(`[DownloadHandler TrackId: ${a.id}] Raw transcodings:`,JSON.stringify(a.media.transcodings,null,2));const t=a.media.transcodings.filter(r=>(r.format?.protocol==="progressive"||r.format?.protocol==="hls")&&(r.format?.mime_type?.startsWith("audio/mpeg")||r.format?.mime_type?.startsWith("audio/mp4"))&&!r.snipped).map(r=>({protocol:r.format.protocol,url:r.url,quality:r.quality}));if(t.length<1)return h.logWarn("[DownloadHandler] No transcodings streams could be determined for Track "+a.id),null;let e=t.sort((r,s)=>r.quality==="hq"&&s.quality==="sq"?-1:r.quality==="sq"&&s.quality==="hq"?1:r.protocol==="progressive"&&s.protocol==="hls"?-1:r.protocol==="hls"&&s.protocol==="progressive"?1:0);return v("download-hq-version")||(e=e.filter(r=>r.quality!=="hq")),e.some(r=>r.quality==="hq")&&h.logInfo("[DownloadHandler] Including high quality streams for Track "+a.id),e}async function Ve(a,t,e,r,s){if(!Zt(a))throw h.logError("[DownloadHandler] Track does not satisfy constraints needed to be downloadable",a),new B("Track does not satisfy constraints needed to be downloadable",a.id);const n=[];if(v("download-original-version")&&a.downloadable&&a.has_downloads_left){const o=await re.getOriginalDownloadUrl(a.id);if(o){const d={url:o,hls:!1,extension:void 0};n.push(d)}}const i=tr(a);if(i&&n.push(...i),n.length<1){const o=`[DownloadHandler] No download details could be determined for track: "${a.title}"`;throw new B(o,a.id)}for(const o of n){let d=null,g=!1,f=null,m;try{if(er(o))if(h.logDebug(`[DownloadHandler TrackId: ${a.id}] Getting stream details for transcoding`,o),d=await re.getStreamDetails(o.url),d)g=d.hls,f=d.url,m=d.extension;else{h.logWarn(`[DownloadHandler TrackId: ${a.id}] Failed to get stream details for transcoding option (url: ${o.url}), trying next...`);continue}else d=o,f=d.url,g=d.hls,m=d.extension,h.logDebug(`[DownloadHandler TrackId: ${a.id}] Using direct download detail (original file?)`,{url:f,hls:g,extension:m});if(!f){h.logWarn(`[DownloadHandler TrackId: ${a.id}] No stream URL resolved, trying next...`,{downloadDetail:o});continue}let E=f,y=g;const I={trackId:a.id,duration:a.duration,uploadDate:new Date(a.display_date),streamUrl:E,fileExtension:m,title:a.title,username:a.user.username,userPermalink:a.user.permalink,artworkUrl:a.artwork_url,avatarUrl:a.user.avatar_url,trackNumber:t,albumName:e,playlistName:r,hls:y,wasOriginallyHls:g};h.logDebug(`[DownloadHandler TrackId: ${a.id}] Calling handleDownload with data`,{downloadData:I});const l=await rr(I,s);return h.logInfo(`[DownloadHandler TrackId: ${a.id}] handleDownload returned browserDownloadId: ${l} for stream: ${E}`),s(101,l),l}catch(E){h.logWarn(`[DownloadHandler TrackId: ${a.id}] Download attempt failed for option. Error: ${E?.message||E}`,{downloadDetail:o,streamUrl:f})}}throw h.logError(`[DownloadHandler TrackId: ${a.id}] All download attempts failed after trying ${n.length} options.`),s(102),new B("No version of this track could be downloaded",a.id)}async function rr(a,t){h.logDebug(`[handleDownload ENTRY] Processing TrackId: ${a.trackId}. History check comes later.`);let e=a.username,r=a.title,s,n=a.artworkUrl,i,o,d,g,f,m,E,y,I;try{try{if(h.logInfo(`Initiating metadata processing for ${a.trackId} with payload`,{payload:a}),v("normalize-track")){const u=new U(a.title,a.username,a.userPermalink);let c=u.getArtists();v("include-producers")||(c=c.filter(w=>w.type!==ye.Producer)),e=c.map(w=>w.name).join(", "),r=u.getTitle();const b=c.filter(w=>w.type===ye.Remixer);if(b.length>0){const w=b.map(O=>O.name).join(" & "),T=Te[b[0].remixType||Te.Remix].toString();r+=` (${w} ${T})`}}e||(e="Unknown"),r||(r="Unknown"),s=ge(`${e} - ${r}`)}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during metadata processing:`,u),new B(`Metadata processing failed for track ${a.trackId}: ${u.message}`,a.trackId)}d=!v("download-without-prompt"),g=v("default-download-location"),f=v("skipExistingFiles");try{const u=a.fileExtension||"mp3";if(I=s+"."+u,!d&&g)if(a.playlistName){const c=ge(a.playlistName);I=g+"/"+c+"/"+I}else I=g+"/"+I;if(f){let c="";if(g)if(a.playlistName){const N=ge(a.playlistName);c=g+"/"+N+"/"}else c=g+"/";const b=`track-${a.trackId}`,w=await Oe("track-download-history")||{};if(h.logDebug(`[History Check] shouldSkipExisting=${f}, trackIdKey=${b}, history exists=${!!w}`),Object.keys(w).length>0&&h.logDebug(`[History Check] History has ${Object.keys(w).length} entries`),w&&w[b]){const N=w[b];h.logInfo(`Skipping download for TrackId: ${a.trackId}. Previously downloaded as: ${N.filename} at ${new Date(N.timestamp).toLocaleString()}`),t(101);const C=Math.floor(Math.random()*1e6)+1e3;return h.logInfo(`Using fake download ID ${C} for skipped track ${a.trackId}`),C}const T={filename:`${c}${s}.${a.fileExtension||"mp3"}`};h.logDebug(`[History Check] Searching downloads with exactQuery: ${JSON.stringify(T)}`);const O=await pe(T);h.logDebug(`[History Check] exactMatches found: ${O.length}`);const K=c.replace(/[-/^$*+?.()|[\]{}]/g,"\\$&"),J=s.replace(/[-/^$*+?.()|[\]{}]/g,"\\$&"),oe={filenameRegex:`^${K}${J}\\..+$`};h.logDebug(`[History Check] Searching downloads with regexQuery: ${JSON.stringify(oe)}`);const se=O.length===0?await pe(oe):[];h.logDebug(`[History Check] regexMatches found: ${se.length}`);const Z={filenameRegex:`${J}\\..+$`};h.logDebug(`[History Check] Searching downloads with titleArtistQuery: ${JSON.stringify(Z)}`);const S=O.length===0&&se.length===0?await pe(Z):[];h.logDebug(`[History Check] titleArtistMatches found: ${S.length}`);const _=[...O,...se,...S].filter(N=>N.state==="complete");if(_.length>0){h.logInfo(`Skipping download for TrackId: ${a.trackId}. File already exists in download history: ${_[0].filename}`),_.length>0&&_.slice(0,3).forEach((C,rt)=>{h.logDebug(`[History Check] Match ${rt}: filename=${C.filename}, state=${C.state}`)}),w[b]={filename:_[0].filename,timestamp:Date.now()},await L("track-download-history",w),t(101);const N=Math.floor(Math.random()*1e6)+1e3;return h.logInfo(`Using fake download ID ${N} for already downloaded track ${a.trackId}`),N}else h.logDebug(`No matching downloads found for TrackId: ${a.trackId} with filename base "${s}"`)}else h.logDebug("[History Check] Skip existing files check is disabled")}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during filename/skip logic:`,u),new B(`Filename/skip logic failed for track ${a.trackId}: ${u.message}`,a.trackId)}try{n||(h.logInfo(`No Artwork URL in data. Fallback to User Avatar (TrackId: ${a.trackId})`),n=a.avatarUrl)}catch(u){h.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Error checking/falling back artwork URL: ${u.message}. Will attempt with current value.`)}h.logInfo(`Starting download of '${s}' (TrackId: ${a.trackId})...`);let l;try{if(a.hls){h.logInfo(`[TrackId: ${a.trackId}] Starting HLS segment fetching from: ${a.streamUrl}`);const[u,c]=await re.downloadStream(a.streamUrl,S=>{S!==void 0&&t(S*.1)});if(o=c,!u)throw new Error("HLS playlist download failed or returned empty buffer.");const b=new TextDecoder().decode(u),w=new Jt;w.push(b),w.end();let T=null;if(w.manifest?.segments?.length>0){const S=w.manifest.segments.find(_=>_.map?.uri);if(S?.map?.uri){let _=S.map.uri;try{_.startsWith("http://")||_.startsWith("https://")||(_=new URL(_,a.streamUrl).href)}catch{if(!(_.startsWith("http://")||_.startsWith("https://")))throw new Error(`Failed to resolve relative HLS init segment URI: ${_}`)}const[N]=await re.downloadStream(_,C=>{C!==void 0&&t(5+C*.05)});if(!N)throw new Error(`Failed to download HLS init segment: ${_}`);T=N}}let O=[];if(w.manifest?.segments?.length>0&&(O=w.manifest.segments.map(S=>{try{return new URL(S.uri,a.streamUrl).href}catch{if(S.uri.startsWith("http://")||S.uri.startsWith("https://"))return S.uri;throw new Error(`Failed to resolve relative HLS segment URI: ${S.uri}`)}})),O.length===0&&!T)throw new Error("HLS playlist contains no media segments or init segment.");const K=[],J=O.length,oe=T?10:5,se=T?80:85;for(let S=0;S<J;S++){const[_]=await re.downloadStream(O[S],C=>{C!==void 0&&t(oe+(S+C/100)/J*se)});if(!_)throw new Error(`Failed to download HLS segment: ${O[S]}`);K.push(_);const N=v("hls-rate-limit-delay-ms")??0;N>0&&S<J-1&&await new Promise(C=>setTimeout(C,N))}const Z=[];T&&Z.push(T),Z.push(...K),i=Se(Z),a.hls=!1}else[i,o]=await re.downloadStream(a.streamUrl,t);if(!i)throw new B("Stream buffer is undefined after download attempts",a.trackId);if(l=i.slice(0),h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] Initial streamBuffer byteLength: ${i?.byteLength}, originalStreamBuffer byteLength: ${l?.byteLength}`),a.wasOriginallyHls&&a.fileExtension&&/^[a-f0-9]{4}$/i.test(a.fileExtension)&&a.streamUrl.includes("/aac")?(h.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Correcting likely bogus HLS AAC extension '${a.fileExtension}' to 'm4a'.`),a.fileExtension="m4a"):a.wasOriginallyHls&&a.fileExtension&&a.fileExtension.toLowerCase()==="m3u8"&&(h.logWarn(`[DownloadHandler TrackId: ${a.trackId}] Correcting HLS extension from 'm3u8' to 'm4a' (assuming AAC).`),a.fileExtension="m4a"),!a.fileExtension&&o){m=o.get("content-type");let u="mp3";m==="audio/mp4"?u="m4a":(m==="audio/x-wav"||m==="audio/wav")&&(u="wav"),a.fileExtension=u}else a.fileExtension||(a.fileExtension="mp3");if(v("ffmpeg-remux-hls-mp4")&&(a.fileExtension==="m4a"||a.fileExtension==="mp4")){t(85);const u=c=>{const b=85+Math.floor(c*.13);t(b)};try{h.logInfo(`[DownloadHandler TrackId: ${a.trackId}] Sending remux task to FFmpegManager. Original streamBuffer byteLength before remux: ${l?.byteLength}`),i=await Ot(a.trackId.toString(),l,a.fileExtension||"mp4",u),(a.fileExtension==="m4a"||a.fileExtension==="mp4")&&(m="audio/mp4"),t(99),h.logInfo(`[DownloadHandler TrackId: ${a.trackId}] Remux task completed by FFmpegManager.`)}catch(c){h.logError(`[FFMPEG_MANAGER] Error during remux via manager. Proceeding with original. TrackId: ${a.trackId}`,c),i=l.slice(0),h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] FFmpeg failed. Fallen back to originalStreamBuffer. ByteLength: ${i?.byteLength}`)}}else h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] FFmpeg remux skipped (disabled or not applicable filetype).`)}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during download/FFmpeg stage:`,u),new B(`Download/FFmpeg failed for track ${a.trackId}: ${u.message}`,a.trackId)}let R;try{const u=v("set-metadata");if(h.logDebug(`[Metadata Check Before If] TrackId: ${a.trackId}, setMetadata config: ${u}, streamBuffer exists: ${!!i}`),u&&i){let c;const b=i.slice(0);if(a.fileExtension==="mp3"?c=new xt(b):(a.fileExtension==="m4a"||a.fileExtension==="mp4")&&(c=new k(b)),c){if(r&&c.setTitle(r),e&&c.setArtists([e]),a.albumName?c.setAlbum(a.albumName):a.playlistName&&c.setAlbum(a.playlistName),a.uploadDate){const T=a.uploadDate.getFullYear();isNaN(T)||c.setYear(T)}if(a.trackNumber&&c.setTrackNumber(a.trackNumber),a.trackId?c.setSoundCloudTrackId(a.trackId.toString()):h.logWarn(`[Metadata] TrackId is missing in data, cannot set SoundCloudTrackID for tagging. Track Title: ${a.title}`),n)try{const T=n.replace("-large.jpg","-t500x500.jpg"),O=await fetch(T);if(!O.ok)throw new Error(`Artwork fetch failed: ${O.statusText}`);const K=await O.arrayBuffer();c.setArtwork(K)}catch(T){h.logWarn(`[Artwork] Failed to fetch/set artwork for tagging TrackId: ${a.trackId}`,T)}const w=await c.getBuffer();h.logDebug(`[Metadata] TagWriter result for TrackId ${a.trackId} (ext: ${a.fileExtension}): applied=${w.tagsApplied}, message='${w.message||"none"}'`),w?.buffer?.byteLength>0?R=w.buffer:(h.logWarn("[Metadata] TagWriter returned invalid buffer. Using untagged buffer."),R=i.slice(0))}else h.logWarn(`[TrackId: ${a.trackId}] No TagWriter for ext '${a.fileExtension}'. Using untagged buffer.`),R=i.slice(0)}else h.logInfo(`[TrackId: ${a.trackId}] Metadata disabled or no streamBuffer. Using untagged.`),R=i?.slice(0)}catch(u){h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error during metadata tagging:`,u),R=i?.slice(0)}let F;try{F=R?.byteLength>0?R:i?.byteLength>0?i.slice(0):l?.byteLength>0?l.slice(0):(()=>{throw new B(`All buffers invalid for ${a.trackId}`,a.trackId)})(),F.byteLength<100&&h.logWarn(`Final buffer small: ${F.byteLength} bytes.`),h.logDebug(`[DownloadHandler TrackId: ${a.trackId}] Final bufferToSave byteLength before Blob creation: ${F?.byteLength}`);const u={};m?u.type=m:a.fileExtension==="mp3"?u.type="audio/mpeg":a.fileExtension==="m4a"||a.fileExtension==="mp4"?u.type="audio/mp4":a.fileExtension==="wav"&&(u.type="audio/wav");const c=new Blob([F],u);h.logInfo(`Creating URL for download (TrackId: ${a.trackId}). Service worker context: ${st()}`),y=await nt(c)}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Error preparing final buffer or Blob/DataURL:`,u),new B(`Failed to prepare buffer/DataURL for track ${a.trackId}: ${u.message}`,a.trackId)}if(E=s+"."+(a.fileExtension||"mp3"),!d&&g){const u=g.endsWith("/")?g.slice(0,-1):g,c=a.playlistName?`/${ge(a.playlistName)}`:"",b=E.split("/").pop()||E;E=`${u}${c}/${b}`}try{h.logInfo(`Downloading track as '${E}' (TrackId: ${a.trackId}). SaveAs: ${d}`);const u=y;if(!u)throw new Error("Data URL for download is undefined.");const c=await it(u,E,d);if(h.logInfo(`Successfully initiated browser download for '${s}' (TrackId: ${a.trackId}) with browserDownloadId: ${c}`),f){const b=`track-${a.trackId}`,w=await Oe("track-download-history")||{};w[b]={filename:E,timestamp:Date.now()},await L("track-download-history",w)}return c}catch(u){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Download save stage error:`,u),new B(`Save failed for track ${a.trackId}: ${u.message}`,a.trackId)}}catch(l){throw h.logError(`[DownloadHandler TrackId: ${a.trackId}] Uncaught error in handleDownload`,l),l instanceof B?l:new B(`Unknown error during download: ${l?.message||l}`,a.trackId)}}const ae=x.create("Semaphore",X.Debug);class Qe{tasks=[];count;maxCount;constructor(t){if(t<=0)throw new Error("Semaphore count must be a positive integer.");this.count=t,this.maxCount=t}async acquire(){return ae.logDebug(`Acquire attempt: current count ${this.count}, tasks in queue ${this.tasks.length}`),this.count>0?(this.count--,ae.logDebug(`Acquired immediately. New count ${this.count}`),Promise.resolve()):new Promise(t=>{this.tasks.push(t),ae.logDebug(`Queued. New queue length ${this.tasks.length}`)})}release(){if(this.count++,ae.logDebug(`Released. New count ${this.count}`),this.tasks.length>0){const t=this.tasks.shift();t&&(this.count--,ae.logDebug(`Processing queued task. New count ${this.count}, New queue length ${this.tasks.length}`),t())}this.count>this.maxCount&&(ae.logWarn(`Semaphore count (${this.count}) exceeded maxCount (${this.maxCount}) after release. This might indicate an issue.`),this.count=this.maxCount)}async withLock(t){await this.acquire();try{return await t()}finally{this.release()}}getAvailablePermits(){return this.count}getQueueLength(){return this.tasks.length}}const ie=new Pe,p=x.create("Background",X.Debug),ar=ot(),P=[];let ke=!1;const he="persistentDownloadQueue_v1";async function G(){try{const a=JSON.parse(JSON.stringify(P));await chrome.storage.local.set({[he]:a}),p.logDebug("[Queue Persistence] Queue state saved.")}catch(a){p.logError("[Queue Persistence] Failed to save queue state:",a)}}async function sr(){try{const a=(await chrome.storage.local.get(he))[he];if(Array.isArray(a)){p.logInfo(`[Queue Persistence] Loading ${a.length} items from storage (key: ${he}).`);const t=[];let e=0;for(const r of a)if(r&&typeof r.id=="string"&&typeof r.type=="string"&&typeof r.status=="string"&&typeof r.url=="string"&&typeof r.addedAt=="number"&&r.originalMessage!==void 0){const s=r;s.status==="processing"&&(s.status="pending",s.progress=0,e++),t.push(s)}else p.logWarn("[Queue Persistence] Discarding invalid item from saved queue:",r);P.splice(0,P.length,...t),p.logInfo(`[Queue Persistence] Queue initialized. ${e} items reset from processing to pending.`),z(),me()}else p.logInfo("[Queue Persistence] No saved queue found or invalid format.")}catch(a){const t="[Queue Persistence] Failed to load queue state";if(a instanceof Error){const e=a.message||"[No message property]",r=a.stack||"[No stack trace]";p.logError(`${t}: ${e}
Stack: ${r}`)}else a?p.logError(`${t}. Caught non-Error object: ${String(a)}`):(p.logError(`${t}. An undefined or null error was caught.`),console.error("[Queue Persistence] Raw undefined/null error value that was caught by loadAndInitializeQueue:",a))}}const z=()=>{p.logDebug("[Queue Broadcast] Sending queue update."),chrome?.runtime?.sendMessage?chrome.runtime.sendMessage({type:"QUEUE_UPDATED_BROADCAST",queuePayload:P},a=>{if(chrome.runtime.lastError){const t=chrome.runtime.lastError.message?.toLowerCase()||"";!t.includes("message port closed")&&!t.includes("receiving end does not exist")&&p.logWarn("[Queue Broadcast] Error sending queue update:",chrome.runtime.lastError.message)}}):p.logWarn("[Queue Broadcast] chrome.runtime.sendMessage not available?")},nr=async a=>{p.logInfo(`[QueueProcessor _executeDownloadTask] Starting task for ID: ${a.id}, Type: ${a.type}, URL: ${a.url}`),a.status="processing",await G(),a.originalMessage?.track?.title&&(a.title=a.originalMessage.track.title),a.originalMessage?.track?.artwork_url?a.artworkUrl=a.originalMessage.track.artwork_url:a.originalMessage?.set?.title?a.title=a.originalMessage.set.title:a.originalMessage?.set?.artwork_url&&(a.artworkUrl=a.originalMessage.set.artwork_url),z(),a.tabId&&q(a.tabId,a.id,0,void 0,"Resuming");const t=(e,r)=>{e!==void 0&&(a.progress=e,a.tabId&&q(a.tabId,a.id,e,void 0,r?void 0:"Resuming",r))};try{if(a.type==="DOWNLOAD"){const e=a.originalMessage.url;if(!e)throw new Error("Missing URL in original message for DOWNLOAD item");p.logInfo(`[QueueProcessor _executeDownloadTask] Resolving track URL: ${e} for item ${a.id}`);const r=await ie.resolveUrl(e);if(!r||r.kind!=="track")throw new Error(`Failed to resolve URL to a valid track: ${e}`);a.title=r.title,a.artworkUrl=r.artwork_url,z(),p.logInfo(`[QueueProcessor _executeDownloadTask] Track resolved: ${r.title}. Starting download for item ${a.id}`),await Ve(r,void 0,void 0,void 0,t),a.status="completed",await G(),p.logInfo(`[QueueProcessor _executeDownloadTask] DOWNLOAD complete for item ${a.id}: ${r.title}`)}else if(a.type==="DOWNLOAD_SET"){const e=a.originalMessage.url;if(!e)throw new Error("Missing URL in original message for DOWNLOAD_SET item");p.logInfo(`[QueueProcessor _executeDownloadTask] Resolving set URL: ${e} for item ${a.id}`);const r=await ie.resolveUrl(e);if(!r||!r.tracks||r.tracks.length===0)throw new Error(`Failed to resolve URL to a valid playlist or playlist is empty: ${e}`);a.title=r.title;const s=r.tracks.map(I=>I.id);if(s.length===0){p.logWarn(`[Queue Set ${a.id}] Playlist resolved but contains no track IDs?`),a.status="completed";return}p.logInfo(`[QueueProcessor _executeDownloadTask] Set resolved: ${r.title}. Fetching full details for ${s.length} tracks for item ${a.id}`);const n=or(s,50),i=[];for(const I of n){const l=await ie.getTracks(I);i.push(...Object.values(l))}p.logInfo(`[QueueProcessor _executeDownloadTask] Fetched full details for ${i.length} tracks.`),!a.artworkUrl&&i.length>0&&(a.artworkUrl=i[0].artwork_url),z();const o={};let d=!1,g=null;const f=()=>{const I=Object.values(o).reduce((l,R)=>l+R,0);return i.length>0?I/i.length:0};a.progress=0,t(0);const m=r.set_type==="album"||r.set_type==="ep"?r.title:void 0,E=r.set_type!=="album"&&r.set_type!=="ep"?r.title:void 0,y=[];for(let I=0;I<i.length;I++){const l=i[I],R=I+1,F=(u,c)=>{if(u!==void 0){o[l.id]=u;const b=f();t(b,c)}};y.push(Ke.withLock(()=>(p.logDebug(`[Queue Set ${a.id}] Starting download for track ${R}/${i.length}: ${l.title} (ID: ${l.id})`),Ve(l,R,m,E,F))).catch(u=>{p.logWarn(`[Queue Set ${a.id}] Failed to download track ${R}: ${l.title}`,u),d=!0,g=u?.message||String(u),o[l.id]=100;const c=f();t(c)}))}p.logInfo(`[Queue Set ${a.id}] Waiting for ${y.length} track downloads to complete...`),await Promise.all(y),p.logInfo(`[Queue Set ${a.id}] All track download attempts finished.`),d?(a.status="error",a.error="One or more tracks failed to download within the set.",await G(),p.logWarn(`[Queue Set ${a.id}] DOWNLOAD_SET completed with errors. Last individual error logged was: ${g||"None recorded"}`),a.tabId&&q(a.tabId,a.id,102,a.error)):(a.status="completed",a.progress=101,await G(),p.logInfo(`[Queue Set ${a.id}] DOWNLOAD_SET completed successfully.`),a.tabId&&q(a.tabId,a.id,101))}else a.type==="DOWNLOAD_SET_RANGE"?(p.logWarn(`[QueueProcessor _executeDownloadTask] DOWNLOAD_SET_RANGE for ${a.id} not yet implemented in queue processor.`),a.status="error",a.error="Set range downloads via queue not yet implemented.",await G(),a.tabId&&q(a.tabId,a.id,void 0,a.error)):(p.logError(`[QueueProcessor _executeDownloadTask] Unknown item type: ${a.type} for item ID: ${a.id}`),a.status="error",a.error="Unknown download type",await G(),a.tabId&&q(a.tabId,a.id,void 0,a.error))}catch(e){p.logError(`[QueueProcessor _executeDownloadTask] Error processing item ${a.id}:`,e),a.status="error",a.error=e.message||"Unknown error during processing",await G(),a.tabId&&q(a.tabId,a.id,void 0,a.error,void 0)}finally{z()}},ir=async()=>{if(ke)return;ke=!0;const a=P.findIndex(t=>t.status==="pending");if(a!==-1){const t=P[a];await nr(t);const e=P.findIndex(r=>r.id===t.id);e!==-1&&(P[e].status==="completed"||P[e].status==="error")&&(p.logInfo(`[QueueProcessor] Removing finalized item ${P[e].id} (Status: ${P[e].status}) from queue.`),P.splice(e,1),await G(),z())}ke=!1,P.some(t=>t.status==="pending")&&me()},me=()=>{setTimeout(()=>{p.logInfo("[QueueProcessor trigger] Checking queue..."),ir()},0)},ze=()=>Math.max(1,Math.min(Number(v("maxConcurrentTrackDownloads"))||3,10));let Ke=new Qe(ze());p.logInfo(`Download track semaphore initialized with concurrency: ${ze()}`),Ee("maxConcurrentTrackDownloads",a=>{const t=Math.max(1,Math.min(Number(a)||3,10));p.logInfo(`Updating download track semaphore concurrency to: ${t}`),Ke=new Qe(t)});async function Je(a){await dt(a)}async function Ze(a){await ut(a)}p.logInfo("Starting with version: "+ar.version),lt(yt),p.logInfo("Initial message listener registered."),ve(!0).then(async()=>{p.logInfo("Initial configuration loaded."),await sr(),p.logInfo("Setting initial DNR rules.");const a=v("oauth-token");await Je(a);const t=v("client-id");await Ze(t),a&&await tt(a),Pt()});function q(a,t,e,r,s,n){if(!t||typeof t!="string"||t.trim()===""){p.logError(`Attempted to send download progress with invalid downloadId: ${JSON.stringify(t)}`);const d=new Error().stack;if(p.logError(`Call stack for invalid downloadId: ${d}`),e===101||e===102){p.logWarn(`Attempting to send COMPLETION message (${e}) even with missing downloadId`);const g={downloadId:"undefined_completion",progress:e,error:typeof r=="string"?r:r instanceof Error?r.message:"",status:s,completionWithoutId:!0,timestamp:Date.now(),browserDownloadId:n};le(a,g).catch(f=>{p.logError(`Failed to send fallback completion message: ${f}`)})}return}let i="";r instanceof Error?i=r.message:typeof r=="string"&&(i=r),e===101||e===102?p.logInfo(`Sending COMPLETION message for download ${t} to tab ${a}, progress=${e}`):e===100&&p.logInfo(`Sending FINISHING message for download ${t} to tab ${a}`);const o={downloadId:t,progress:e,error:i,status:s,timestamp:Date.now(),browserDownloadId:n};e===101||e===102?(p.logInfo(`Sending SINGLE COMPLETION message for download ${t} to tab ${a}, progress=${e} (BrowserDownloadId: ${n||"N/A"})`),le(a,o).catch(d=>{p.logWarn(`Failed to send completion message to tab ${a}:`,d)})):le(a,o).catch(d=>{p.logWarn(`Failed to send progress/status message to tab ${a}:`,d)})}function or(a,t){const e=[];for(let r=0;r<a.length;r+=t){const s=a.slice(r,r+t);e.push(s)}return e}const et=new RegExp("OAuth (.+)"),lr=new RegExp("/me/followings/(\\d+)");gt(a=>{if(Re()){const r=v("oauth-token");if(a.requestHeaders){for(let s=0;s<a.requestHeaders.length;s++)if(a.requestHeaders[s].name.toLowerCase()==="authorization"){const n=a.requestHeaders[s].value,i=et.exec(n);i&&i.length>=2&&i[1]!==r&&(p.logInfo("Sniffed and storing OAuth token from request header (all envs)."),L("oauth-token",i[1]));break}}return{}}let t=!1;const e=v("oauth-token");if(a.requestHeaders){for(let r=0;r<a.requestHeaders.length;r++)if(a.requestHeaders[r].name.toLowerCase()==="authorization"){t=!0;const s=a.requestHeaders[r].value,n=et.exec(s);n&&n.length>=2&&n[1]!==e&&(p.logInfo("Sniffed and storing OAuth token (Firefox/non-DNR)."),L("oauth-token",n[1]));break}if(!t&&e)return a.requestHeaders.push({name:"Authorization",value:"OAuth "+e}),{requestHeaders:a.requestHeaders}}return{}},["*://api-v2.soundcloud.com/*"],["blocking","requestHeaders"]),ct(a=>{const t=new URL(a.url);if(t.pathname==="/connect/session"&&v("oauth-token")===null)p.logInfo("User logged in - clearing potentially stale token."),L("oauth-token",void 0);else if(t.pathname==="/sign-out")p.logInfo("User logged out"),L("oauth-token",null),L("user-id",null),L("followed-artists",[]);else if(t.pathname.startsWith("/me/followings/")){const e=lr.exec(t.pathname);if(e&&e.length===2){const r=+e[1];if(r){let s=v("followed-artists")||[];a.method==="POST"?s.includes(r)||s.push(r):a.method==="DELETE"&&(s=s.filter(n=>n!==r)),L("followed-artists",s)}}}else{const e=t.searchParams.get("client_id");if(e){const r=v("client-id");e!==r&&(p.logInfo(`Found new client_id: ${e}. Storing it.`),L("client-id",e))}else if(!Re()){const r=v("client-id");if(r)return p.logDebug(`Adding ClientId to ${a.url} via redirect (Firefox/non-DNR)`),t.searchParams.append("client_id",r),{redirectUrl:t.toString()}}}return{}},["*://api-v2.soundcloud.com/*","*://api-auth.soundcloud.com/*"],["blocking"]);const tt=async a=>{if(!a){L("user-id",null),p.logInfo("OAuth token cleared, user ID cleared.");return}const t=await ie.getCurrentUser();if(!t){p.logError("Failed to fetch currently logged in user (after token change/init)");return}L("user-id",t.id),p.logInfo("Logged in as",t.username);const e=await ie.getFollowedArtistIds(t.id);if(!e){p.logError("Failed to fetch ids of followed artists");return}L("followed-artists",e)};Ee("oauth-token",async a=>{await Je(a),await tt(a)}),Ee("client-id",async a=>{p.logInfo(`client-id config changed to: ${a}. Updating DNR rule.`),await Ze(a)});
