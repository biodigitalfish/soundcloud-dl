{"version":3,"file":"background.js","sources":["../../../src/api/soundcloudApi.ts","../../../node_modules/@ffmpeg/ffmpeg/dist/esm/const.js","../../../node_modules/@ffmpeg/ffmpeg/dist/esm/utils.js","../../../node_modules/@ffmpeg/ffmpeg/dist/esm/errors.js","../../../node_modules/@ffmpeg/ffmpeg/dist/esm/classes.js","../../../node_modules/@ffmpeg/ffmpeg/dist/esm/types.js","../../../node_modules/@ffmpeg/util/dist/esm/errors.js","../../../node_modules/@ffmpeg/util/dist/esm/const.js","../../../node_modules/@ffmpeg/util/dist/esm/index.js","../../../src/downloader/ffmpeg.ts","../../../src/downloader/ffmpegManager.ts","../../../node_modules/browser-id3-writer/dist/browser-id3-writer.mjs","../../../src/downloader/tagWriters/mp3TagWriter.ts","../../../src/downloader/tagWriters/mp4TagWriter.ts","../../../node_modules/escape-string-regexp/index.js","../../../src/downloader/metadataExtractor.ts","../../../node_modules/@videojs/vhs-utils/es/stream.js","../../../node_modules/@babel/runtime/helpers/esm/extends.js","../../../node_modules/global/window.js","../../../node_modules/@videojs/vhs-utils/es/decode-b64-to-uint8-array.js","../../../node_modules/m3u8-parser/dist/m3u8-parser.es.js","../../../src/downloader/downloadHandler.ts","../../../src/background/semaphore.ts","../../../src/background/messageHandler.ts","../../../src/background/background.ts"],"sourcesContent":["import { Logger } from \"../utils/logger\";\n\n// --- Define custom error for rate limiting ---\nclass RateLimitError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"RateLimitError\";\n  }\n}\n// ---------------------------------------------\n\ninterface MediaTranscodingFormat {\n  protocol: \"progressive\" | \"hls\";\n  mime_type: string;\n}\n\ninterface MediaTranscoding {\n  snipped: boolean;\n  quality: \"sq\" | \"hq\";\n  url: string;\n  format: MediaTranscodingFormat;\n}\n\ninterface Media {\n  transcodings: MediaTranscoding[];\n}\n\ninterface User {\n  id: number;\n  username: string;\n  avatar_url: string;\n  permalink: string;\n}\n\nexport interface Track {\n  id: number;\n  duration: number; // in ms\n  display_date: string;\n  kind: string;\n  state: string;\n  title: string;\n  artwork_url: string;\n  streamable: boolean;\n  downloadable: boolean;\n  has_downloads_left: boolean;\n  user: User;\n  media: Media;\n}\n\ninterface Stream {\n  url: string;\n}\n\nexport interface StreamDetails {\n  url: string;\n  extension?: string;\n  hls: boolean;\n}\n\ninterface OriginalDownload {\n  redirectUri: string;\n}\n\ntype KeyedTracks = { [key: number]: Track };\ntype ProgressReport = (progress: number) => void;\n\nexport class SoundCloudApi {\n  readonly baseUrl: string = \"https://api-v2.soundcloud.com\";\n  private logger: Logger;\n  private globalBackoffUntil: number | null = null;\n  private globalBackoffDurationMs: number = 61 * 1000; // 60 seconds\n\n  constructor() {\n    this.logger = Logger.create(\"SoundCloudApi\");\n  }\n\n  // --- Retry with backoff utility ---\n  private async retryWithBackoff<T>(\n    fn: () => Promise<T>,\n    retries: number = 30,\n    initialDelayMs: number = 2000, // 2 seconds\n    contextString?: string\n  ): Promise<T> {\n    // Check and wait for global backoff before starting any attempts\n    if (this.globalBackoffUntil && Date.now() < this.globalBackoffUntil) {\n      const waitTime = this.globalBackoffUntil - Date.now();\n      this.logger.logWarn(`[Global Backoff] Active. Waiting for ${waitTime / 1000}s before proceeding with ${contextString || \"operation\"}.`);\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n\n    let attempt = 0;\n    let delay = initialDelayMs;\n    while (attempt <= retries) {\n      try {\n        // Re-check global backoff before each attempt, in case it was set by another concurrent operation\n        if (this.globalBackoffUntil && Date.now() < this.globalBackoffUntil) {\n          const waitTime = this.globalBackoffUntil - Date.now();\n          this.logger.logWarn(`[Global Backoff] Active during retry attempt. Waiting for ${waitTime / 1000}s for ${contextString || \"operation\"}.`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n\n        this.logger.logDebug(`[Retry] Attempt ${attempt + 1}/${retries + 1} for ${contextString || \"operation\"}`);\n        return await fn();\n      } catch (error) {\n        if (error instanceof RateLimitError) {\n          if (attempt < retries) {\n            attempt++;\n            this.logger.logWarn(`[Retry] Rate limit hit for ${contextString || \"operation\"}. Retrying in ${delay / 1000}s... (Attempt ${attempt + 1}/${retries + 1})`);\n            await new Promise(resolve => setTimeout(resolve, delay));\n            delay *= 2; // Exponential backoff\n          } else {\n            // Local retries exhausted for a RateLimitError, activate global backoff\n            this.logger.logError(`[Retry] Failed for ${contextString || \"operation\"} after ${attempt + 1} attempts due to rate limit. Activating global backoff.`);\n            this.globalBackoffUntil = Date.now() + this.globalBackoffDurationMs;\n            this.logger.logWarn(`[Global Backoff] Activated for ${this.globalBackoffDurationMs / 1000}s due to persistent rate limiting on ${contextString || \"operation\"}.`);\n            throw error; // Re-throw the RateLimitError\n          }\n        } else {\n          this.logger.logError(`[Retry] Failed for ${contextString || \"operation\"} after ${attempt + 1} attempts or non-retryable error:`, error);\n          throw error; // Re-throw non-RateLimitError or if retries exhausted\n        }\n      }\n    }\n    // Should not be reached if logic is correct, but as a fallback:\n    const finalErrorMsg = `[Retry] Exhausted retries for ${contextString || \"operation\"} without success (this path should not be reached).`;\n    this.logger.logError(finalErrorMsg);\n    throw new Error(finalErrorMsg);\n  }\n  // --- End Retry with backoff utility ---\n\n  resolveUrl<T>(url: string) {\n    const reqUrl = `${this.baseUrl}/resolve?url=${url}`;\n    return this.retryWithBackoff(() => this._fetchJsonInternal<T>(reqUrl), 3, 2000, `resolveUrl: ${url}`);\n  }\n\n  getCurrentUser() {\n    const url = `${this.baseUrl}/me`;\n    return this.retryWithBackoff(() => this._fetchJsonInternal<User>(url), 3, 2000, \"getCurrentUser\");\n  }\n\n  async getFollowedArtistIds(userId: number): Promise<number[]> {\n    const url = `${this.baseUrl}/users/${userId}/followings/ids`;\n    const data = await this.retryWithBackoff(() => this._fetchJsonInternal<any>(url), 3, 2000, `getFollowedArtistIds: ${userId}`);\n    if (!data || !data.collection) return null;\n    return data.collection;\n  }\n\n  async getTracks(trackIds: number[]): Promise<KeyedTracks> {\n    const url = `${this.baseUrl}/tracks?ids=${trackIds.join(\",\")}`;\n    this.logger.logInfo(\"Fetching tracks with Ids\", { trackIds });\n    const tracks = await this.retryWithBackoff(() => this._fetchJsonInternal<Track[]>(url), 3, 2000, `getTracks: ${trackIds.length} IDs`);\n    return trackIds.reduce((acc, cur, index) => {\n      acc[cur] = tracks[index];\n      return acc;\n    }, {});\n  }\n\n  async getStreamDetails(url: string): Promise<StreamDetails> {\n    const stream = await this.retryWithBackoff(() => this._fetchJsonInternal<Stream>(url), 3, 2000, `getStreamDetails: ${url}`);\n    if (!stream || !stream.url) {\n      this.logger.logError(\"Invalid stream response\", stream);\n      return null;\n    }\n\n    let extension;\n    let hls = false;\n    const regexResult = /(?:(\\w{3,4})\\/playlist)?\\.(\\w{3,4})(?:$|\\?)/.exec(stream.url);\n\n    if (regexResult.length >= 2) {\n      if (regexResult[2] === \"m3u8\") {\n        extension = regexResult[1];\n        hls = true;\n      } else {\n        extension = regexResult[2];\n      }\n    }\n\n    return {\n      url: stream.url,\n      extension,\n      hls,\n    };\n  }\n\n  async getOriginalDownloadUrl(id: number): Promise<string | null> {\n    const url = `${this.baseUrl}/tracks/${id}/download`;\n    this.logger.logInfo(\"Getting original download URL for track with Id\", id);\n    try {\n      const downloadObj = await this.retryWithBackoff(() => this._fetchJsonInternal<OriginalDownload>(url), 3, 2000, `getOriginalDownloadUrl: ${id}`);\n      if (!downloadObj || !downloadObj.redirectUri) {\n        this.logger.logError(\"Invalid original file response\", downloadObj);\n        return null;\n      }\n      return downloadObj.redirectUri;\n    } catch (_error) {\n      this.logger.logError(`Failed to get original download URL for track ${id} after retries`, _error);\n      return null;\n    }\n  }\n\n  async downloadArtwork(artworkUrl: string) {\n    const [buffer] = await this.retryWithBackoff(() => this._fetchArrayBufferInternal(artworkUrl), 3, 2000, `downloadArtwork: ${artworkUrl}`);\n    return buffer;\n  }\n\n  downloadStream(streamUrl: string, reportProgress: ProgressReport) {\n    return this.retryWithBackoff(() => this._fetchArrayBufferInternal(streamUrl, reportProgress), 3, 1000, `downloadStream: ${streamUrl}`);\n  }\n\n  private async _fetchArrayBufferInternal(url: string, reportProgress?: ProgressReport): Promise<[ArrayBuffer | null, Headers | null]> {\n    try {\n      const response = await fetch(url);\n\n      if (!response.ok) {\n        if (response.status === 404) {\n          this.logger.logDebug(`[fetchArrayBuffer] Resource not found (404) for ${url}`);\n          return [null, response.headers]; // Return null buffer, but valid headers\n        }\n        if (response.status === 429) {\n          this.logger.logWarn(`[fetchArrayBuffer] Rate limited (429) while fetching ${url}.`);\n          throw new RateLimitError(`Rate limited (status 429) on ${url}`);\n        }\n        // For other non-OK statuses (5xx, 403, etc.)\n        const errorText = `[fetchArrayBuffer] HTTP error for ${url} - Status: ${response.status} ${response.statusText}`;\n        throw new Error(errorText);\n      }\n\n      if (!response.body) {\n        // This case should ideally not happen for a successful response, but good to guard.\n        this.logger.logError(`Response for ${url} has no body, despite response.ok being true.`);\n        throw new Error(`Response for ${url} has no body.`);\n      }\n\n      const contentLength = response.headers.get(\"Content-Length\");\n      const total = contentLength ? parseInt(contentLength, 10) : 0;\n      let loaded = 0;\n\n      const chunks: Uint8Array[] = [];\n      const reader = response.body.getReader();\n\n      if (reportProgress && total > 0) {\n        reportProgress(0); // Initial progress\n      }\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          break;\n        }\n        chunks.push(value); // value is Uint8Array\n        loaded += value.byteLength;\n        if (reportProgress && total > 0) {\n          reportProgress(Math.round((loaded / total) * 100));\n        }\n      }\n\n      if (reportProgress) {\n        // Ensure 100% is reported if all chunks are read, even if total was 0 or Content-Length was missing\n        reportProgress(100);\n      }\n\n      // Concatenate chunks into a single ArrayBuffer\n      const completeBuffer = new ArrayBuffer(loaded);\n      const view = new Uint8Array(completeBuffer);\n      let offset = 0;\n      for (const chunk of chunks) {\n        view.set(chunk, offset);\n        offset += chunk.byteLength;\n      }\n\n      // Check for genuinely empty buffer after successful download, which might be an issue.\n      if (loaded === 0 && response.status === 200) {\n        this.logger.logWarn(`[fetchArrayBuffer] Fetched ${url} (Status: ${response.status}) but received an empty (0 bytes) buffer.`);\n        // Decide if this should be an error or return [null, headers]\n        // For now, returning the empty buffer as it is technically what was received.\n      }\n\n      return [completeBuffer, response.headers];\n    } catch (error) {\n      this.logger.logError(`[fetchArrayBuffer] Generic error for ${url}:`, error);\n      // To keep original behavior of throwing specific RateLimitError or generic Error:\n      if (error instanceof RateLimitError) {\n        throw error;\n      }\n      // Ensure a generic error is thrown if it's not already one of our specific types or a standard Error\n      throw new Error(`Failed to fetch array buffer from ${url}: ${(error instanceof Error ? error.message : String(error))}`);\n    }\n  }\n\n  private async _fetchJsonInternal<T>(url: string) {\n    try {\n      const resp = await fetch(url);\n\n      if (!resp.ok) {\n        if (resp.status === 429) {\n          const errorMsg = `Rate limited while fetching from ${url}. Please wait and try again later.`;\n          this.logger.logWarn(errorMsg);\n          throw new RateLimitError(errorMsg);\n        } else {\n          const errorMsg = `HTTP error ${resp.status} while fetching from ${url}`;\n          this.logger.logError(errorMsg);\n          throw new Error(errorMsg);\n        }\n      }\n\n      const json = (await resp.json()) as T;\n\n      if (!json) return null;\n\n      return json;\n    } catch (error) {\n      this.logger.logError(\"Failed to fetch JSON from\", url);\n\n      return null;\n    }\n  }\n}\n","export const MIME_TYPE_JAVASCRIPT = \"text/javascript\";\nexport const MIME_TYPE_WASM = \"application/wasm\";\nexport const CORE_VERSION = \"0.12.9\";\nexport const CORE_URL = `https://unpkg.com/@ffmpeg/core@${CORE_VERSION}/dist/umd/ffmpeg-core.js`;\nexport var FFMessageType;\n(function (FFMessageType) {\n    FFMessageType[\"LOAD\"] = \"LOAD\";\n    FFMessageType[\"EXEC\"] = \"EXEC\";\n    FFMessageType[\"FFPROBE\"] = \"FFPROBE\";\n    FFMessageType[\"WRITE_FILE\"] = \"WRITE_FILE\";\n    FFMessageType[\"READ_FILE\"] = \"READ_FILE\";\n    FFMessageType[\"DELETE_FILE\"] = \"DELETE_FILE\";\n    FFMessageType[\"RENAME\"] = \"RENAME\";\n    FFMessageType[\"CREATE_DIR\"] = \"CREATE_DIR\";\n    FFMessageType[\"LIST_DIR\"] = \"LIST_DIR\";\n    FFMessageType[\"DELETE_DIR\"] = \"DELETE_DIR\";\n    FFMessageType[\"ERROR\"] = \"ERROR\";\n    FFMessageType[\"DOWNLOAD\"] = \"DOWNLOAD\";\n    FFMessageType[\"PROGRESS\"] = \"PROGRESS\";\n    FFMessageType[\"LOG\"] = \"LOG\";\n    FFMessageType[\"MOUNT\"] = \"MOUNT\";\n    FFMessageType[\"UNMOUNT\"] = \"UNMOUNT\";\n})(FFMessageType || (FFMessageType = {}));\n","/**\n * Generate an unique message ID.\n */\nexport const getMessageID = (() => {\n    let messageID = 0;\n    return () => messageID++;\n})();\n","export const ERROR_UNKNOWN_MESSAGE_TYPE = new Error(\"unknown message type\");\nexport const ERROR_NOT_LOADED = new Error(\"ffmpeg is not loaded, call `await ffmpeg.load()` first\");\nexport const ERROR_TERMINATED = new Error(\"called FFmpeg.terminate()\");\nexport const ERROR_IMPORT_FAILURE = new Error(\"failed to import ffmpeg-core.js\");\n","import { FFMessageType } from \"./const.js\";\nimport { getMessageID } from \"./utils.js\";\nimport { ERROR_TERMINATED, ERROR_NOT_LOADED } from \"./errors.js\";\n/**\n * Provides APIs to interact with ffmpeg web worker.\n *\n * @example\n * ```ts\n * const ffmpeg = new FFmpeg();\n * ```\n */\nexport class FFmpeg {\n    #worker = null;\n    /**\n     * #resolves and #rejects tracks Promise resolves and rejects to\n     * be called when we receive message from web worker.\n     */\n    #resolves = {};\n    #rejects = {};\n    #logEventCallbacks = [];\n    #progressEventCallbacks = [];\n    loaded = false;\n    /**\n     * register worker message event handlers.\n     */\n    #registerHandlers = () => {\n        if (this.#worker) {\n            this.#worker.onmessage = ({ data: { id, type, data }, }) => {\n                switch (type) {\n                    case FFMessageType.LOAD:\n                        this.loaded = true;\n                        this.#resolves[id](data);\n                        break;\n                    case FFMessageType.MOUNT:\n                    case FFMessageType.UNMOUNT:\n                    case FFMessageType.EXEC:\n                    case FFMessageType.FFPROBE:\n                    case FFMessageType.WRITE_FILE:\n                    case FFMessageType.READ_FILE:\n                    case FFMessageType.DELETE_FILE:\n                    case FFMessageType.RENAME:\n                    case FFMessageType.CREATE_DIR:\n                    case FFMessageType.LIST_DIR:\n                    case FFMessageType.DELETE_DIR:\n                        this.#resolves[id](data);\n                        break;\n                    case FFMessageType.LOG:\n                        this.#logEventCallbacks.forEach((f) => f(data));\n                        break;\n                    case FFMessageType.PROGRESS:\n                        this.#progressEventCallbacks.forEach((f) => f(data));\n                        break;\n                    case FFMessageType.ERROR:\n                        this.#rejects[id](data);\n                        break;\n                }\n                delete this.#resolves[id];\n                delete this.#rejects[id];\n            };\n        }\n    };\n    /**\n     * Generic function to send messages to web worker.\n     */\n    #send = ({ type, data }, trans = [], signal) => {\n        if (!this.#worker) {\n            return Promise.reject(ERROR_NOT_LOADED);\n        }\n        return new Promise((resolve, reject) => {\n            const id = getMessageID();\n            this.#worker && this.#worker.postMessage({ id, type, data }, trans);\n            this.#resolves[id] = resolve;\n            this.#rejects[id] = reject;\n            signal?.addEventListener(\"abort\", () => {\n                reject(new DOMException(`Message # ${id} was aborted`, \"AbortError\"));\n            }, { once: true });\n        });\n    };\n    on(event, callback) {\n        if (event === \"log\") {\n            this.#logEventCallbacks.push(callback);\n        }\n        else if (event === \"progress\") {\n            this.#progressEventCallbacks.push(callback);\n        }\n    }\n    off(event, callback) {\n        if (event === \"log\") {\n            this.#logEventCallbacks = this.#logEventCallbacks.filter((f) => f !== callback);\n        }\n        else if (event === \"progress\") {\n            this.#progressEventCallbacks = this.#progressEventCallbacks.filter((f) => f !== callback);\n        }\n    }\n    /**\n     * Loads ffmpeg-core inside web worker. It is required to call this method first\n     * as it initializes WebAssembly and other essential variables.\n     *\n     * @category FFmpeg\n     * @returns `true` if ffmpeg core is loaded for the first time.\n     */\n    load = ({ classWorkerURL, ...config } = {}, { signal } = {}) => {\n        if (!this.#worker) {\n            this.#worker = classWorkerURL ?\n                new Worker(new URL(classWorkerURL, import.meta.url), {\n                    type: \"module\",\n                }) :\n                // We need to duplicated the code here to enable webpack\n                // to bundle worekr.js here.\n                new Worker(new URL(\"./worker.js\", import.meta.url), {\n                    type: \"module\",\n                });\n            this.#registerHandlers();\n        }\n        return this.#send({\n            type: FFMessageType.LOAD,\n            data: config,\n        }, undefined, signal);\n    };\n    /**\n     * Execute ffmpeg command.\n     *\n     * @remarks\n     * To avoid common I/O issues, [\"-nostdin\", \"-y\"] are prepended to the args\n     * by default.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * await ffmpeg.writeFile(\"video.avi\", ...);\n     * // ffmpeg -i video.avi video.mp4\n     * await ffmpeg.exec([\"-i\", \"video.avi\", \"video.mp4\"]);\n     * const data = ffmpeg.readFile(\"video.mp4\");\n     * ```\n     *\n     * @returns `0` if no error, `!= 0` if timeout (1) or error.\n     * @category FFmpeg\n     */\n    exec = (\n    /** ffmpeg command line args */\n    args, \n    /**\n     * milliseconds to wait before stopping the command execution.\n     *\n     * @defaultValue -1\n     */\n    timeout = -1, { signal } = {}) => this.#send({\n        type: FFMessageType.EXEC,\n        data: { args, timeout },\n    }, undefined, signal);\n    /**\n     * Execute ffprobe command.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * await ffmpeg.writeFile(\"video.avi\", ...);\n     * // Getting duration of a video in seconds: ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 video.avi -o output.txt\n     * await ffmpeg.ffprobe([\"-v\", \"error\", \"-show_entries\", \"format=duration\", \"-of\", \"default=noprint_wrappers=1:nokey=1\", \"video.avi\", \"-o\", \"output.txt\"]);\n     * const data = ffmpeg.readFile(\"output.txt\");\n     * ```\n     *\n     * @returns `0` if no error, `!= 0` if timeout (1) or error.\n     * @category FFmpeg\n     */\n    ffprobe = (\n    /** ffprobe command line args */\n    args, \n    /**\n     * milliseconds to wait before stopping the command execution.\n     *\n     * @defaultValue -1\n     */\n    timeout = -1, { signal } = {}) => this.#send({\n        type: FFMessageType.FFPROBE,\n        data: { args, timeout },\n    }, undefined, signal);\n    /**\n     * Terminate all ongoing API calls and terminate web worker.\n     * `FFmpeg.load()` must be called again before calling any other APIs.\n     *\n     * @category FFmpeg\n     */\n    terminate = () => {\n        const ids = Object.keys(this.#rejects);\n        // rejects all incomplete Promises.\n        for (const id of ids) {\n            this.#rejects[id](ERROR_TERMINATED);\n            delete this.#rejects[id];\n            delete this.#resolves[id];\n        }\n        if (this.#worker) {\n            this.#worker.terminate();\n            this.#worker = null;\n            this.loaded = false;\n        }\n    };\n    /**\n     * Write data to ffmpeg.wasm.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * await ffmpeg.writeFile(\"video.avi\", await fetchFile(\"../video.avi\"));\n     * await ffmpeg.writeFile(\"text.txt\", \"hello world\");\n     * ```\n     *\n     * @category File System\n     */\n    writeFile = (path, data, { signal } = {}) => {\n        const trans = [];\n        if (data instanceof Uint8Array) {\n            trans.push(data.buffer);\n        }\n        return this.#send({\n            type: FFMessageType.WRITE_FILE,\n            data: { path, data },\n        }, trans, signal);\n    };\n    mount = (fsType, options, mountPoint) => {\n        const trans = [];\n        return this.#send({\n            type: FFMessageType.MOUNT,\n            data: { fsType, options, mountPoint },\n        }, trans);\n    };\n    unmount = (mountPoint) => {\n        const trans = [];\n        return this.#send({\n            type: FFMessageType.UNMOUNT,\n            data: { mountPoint },\n        }, trans);\n    };\n    /**\n     * Read data from ffmpeg.wasm.\n     *\n     * @example\n     * ```ts\n     * const ffmpeg = new FFmpeg();\n     * await ffmpeg.load();\n     * const data = await ffmpeg.readFile(\"video.mp4\");\n     * ```\n     *\n     * @category File System\n     */\n    readFile = (path, \n    /**\n     * File content encoding, supports two encodings:\n     * - utf8: read file as text file, return data in string type.\n     * - binary: read file as binary file, return data in Uint8Array type.\n     *\n     * @defaultValue binary\n     */\n    encoding = \"binary\", { signal } = {}) => this.#send({\n        type: FFMessageType.READ_FILE,\n        data: { path, encoding },\n    }, undefined, signal);\n    /**\n     * Delete a file.\n     *\n     * @category File System\n     */\n    deleteFile = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.DELETE_FILE,\n        data: { path },\n    }, undefined, signal);\n    /**\n     * Rename a file or directory.\n     *\n     * @category File System\n     */\n    rename = (oldPath, newPath, { signal } = {}) => this.#send({\n        type: FFMessageType.RENAME,\n        data: { oldPath, newPath },\n    }, undefined, signal);\n    /**\n     * Create a directory.\n     *\n     * @category File System\n     */\n    createDir = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.CREATE_DIR,\n        data: { path },\n    }, undefined, signal);\n    /**\n     * List directory contents.\n     *\n     * @category File System\n     */\n    listDir = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.LIST_DIR,\n        data: { path },\n    }, undefined, signal);\n    /**\n     * Delete an empty directory.\n     *\n     * @category File System\n     */\n    deleteDir = (path, { signal } = {}) => this.#send({\n        type: FFMessageType.DELETE_DIR,\n        data: { path },\n    }, undefined, signal);\n}\n","export var FFFSType;\n(function (FFFSType) {\n    FFFSType[\"MEMFS\"] = \"MEMFS\";\n    FFFSType[\"NODEFS\"] = \"NODEFS\";\n    FFFSType[\"NODERAWFS\"] = \"NODERAWFS\";\n    FFFSType[\"IDBFS\"] = \"IDBFS\";\n    FFFSType[\"WORKERFS\"] = \"WORKERFS\";\n    FFFSType[\"PROXYFS\"] = \"PROXYFS\";\n})(FFFSType || (FFFSType = {}));\n","export const ERROR_RESPONSE_BODY_READER = new Error(\"failed to get response body reader\");\nexport const ERROR_INCOMPLETED_DOWNLOAD = new Error(\"failed to complete download\");\n","export const HeaderContentLength = \"Content-Length\";\n","import { ERROR_RESPONSE_BODY_READER, ERROR_INCOMPLETED_DOWNLOAD, } from \"./errors.js\";\nimport { HeaderContentLength } from \"./const.js\";\nconst readFromBlobOrFile = (blob) => new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n        const { result } = fileReader;\n        if (result instanceof ArrayBuffer) {\n            resolve(new Uint8Array(result));\n        }\n        else {\n            resolve(new Uint8Array());\n        }\n    };\n    fileReader.onerror = (event) => {\n        reject(Error(`File could not be read! Code=${event?.target?.error?.code || -1}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n});\n/**\n * An util function to fetch data from url string, base64, URL, File or Blob format.\n *\n * Examples:\n * ```ts\n * // URL\n * await fetchFile(\"http://localhost:3000/video.mp4\");\n * // base64\n * await fetchFile(\"data:<type>;base64,wL2dvYWwgbW9yZ...\");\n * // URL\n * await fetchFile(new URL(\"video.mp4\", import.meta.url));\n * // File\n * fileInput.addEventListener('change', (e) => {\n *   await fetchFile(e.target.files[0]);\n * });\n * // Blob\n * const blob = new Blob(...);\n * await fetchFile(blob);\n * ```\n */\nexport const fetchFile = async (file) => {\n    let data;\n    if (typeof file === \"string\") {\n        /* From base64 format */\n        if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(file)) {\n            data = atob(file.split(\",\")[1])\n                .split(\"\")\n                .map((c) => c.charCodeAt(0));\n            /* From remote server/URL */\n        }\n        else {\n            data = await (await fetch(file)).arrayBuffer();\n        }\n    }\n    else if (file instanceof URL) {\n        data = await (await fetch(file)).arrayBuffer();\n    }\n    else if (file instanceof File || file instanceof Blob) {\n        data = await readFromBlobOrFile(file);\n    }\n    else {\n        return new Uint8Array();\n    }\n    return new Uint8Array(data);\n};\n/**\n * importScript dynamically import a script, useful when you\n * want to use different versions of ffmpeg.wasm based on environment.\n *\n * Example:\n *\n * ```ts\n * await importScript(\"http://localhost:3000/ffmpeg.js\");\n * ```\n */\nexport const importScript = async (url) => new Promise((resolve) => {\n    const script = document.createElement(\"script\");\n    const eventHandler = () => {\n        script.removeEventListener(\"load\", eventHandler);\n        resolve();\n    };\n    script.src = url;\n    script.type = \"text/javascript\";\n    script.addEventListener(\"load\", eventHandler);\n    document.getElementsByTagName(\"head\")[0].appendChild(script);\n});\n/**\n * Download content of a URL with progress.\n *\n * Progress only works when Content-Length is provided by the server.\n *\n */\nexport const downloadWithProgress = async (url, cb) => {\n    const resp = await fetch(url);\n    let buf;\n    try {\n        // Set total to -1 to indicate that there is not Content-Type Header.\n        const total = parseInt(resp.headers.get(HeaderContentLength) || \"-1\");\n        const reader = resp.body?.getReader();\n        if (!reader)\n            throw ERROR_RESPONSE_BODY_READER;\n        const chunks = [];\n        let received = 0;\n        for (;;) {\n            const { done, value } = await reader.read();\n            const delta = value ? value.length : 0;\n            if (done) {\n                if (total != -1 && total !== received)\n                    throw ERROR_INCOMPLETED_DOWNLOAD;\n                cb && cb({ url, total, received, delta, done });\n                break;\n            }\n            chunks.push(value);\n            received += delta;\n            cb && cb({ url, total, received, delta, done });\n        }\n        const data = new Uint8Array(received);\n        let position = 0;\n        for (const chunk of chunks) {\n            data.set(chunk, position);\n            position += chunk.length;\n        }\n        buf = data.buffer;\n    }\n    catch (e) {\n        console.log(`failed to send download progress event: `, e);\n        // Fetch arrayBuffer directly when it is not possible to get progress.\n        buf = await resp.arrayBuffer();\n        cb &&\n            cb({\n                url,\n                total: buf.byteLength,\n                received: buf.byteLength,\n                delta: 0,\n                done: true,\n            });\n    }\n    return buf;\n};\n/**\n * toBlobURL fetches data from an URL and return a blob URL.\n *\n * Example:\n *\n * ```ts\n * await toBlobURL(\"http://localhost:3000/ffmpeg.js\", \"text/javascript\");\n * ```\n */\nexport const toBlobURL = async (url, mimeType, progress = false, cb) => {\n    const buf = progress\n        ? await downloadWithProgress(url, cb)\n        : await (await fetch(url)).arrayBuffer();\n    const blob = new Blob([buf], { type: mimeType });\n    return URL.createObjectURL(blob);\n};\n","import { FFmpeg } from \"@ffmpeg/ffmpeg\";\nimport { toBlobURL } from \"@ffmpeg/util\";\nimport { Logger, LogLevel } from \"../utils/logger\";\nimport { getPathFromExtensionFile } from \"../compatibility/compatibilityStubs\";\n\nconst baseLogger = Logger.create(\"FFmpegInstance\", LogLevel.Debug); // Base logger for instances\n\n// No longer a single global instance exported directly\n// export const ffmpeg = new FFmpeg(); \n// let ffmpegLoaded = false;\n// let ffmpegLoadPromise: Promise<boolean> | null = null;\n\n// Removed global ffmpeg.on(\"log\") here, will be set per instance\n\nexport async function createAndLoadFFmpegInstance(instanceId?: string | number): Promise<FFmpeg | null> {\n    const instanceLogger = instanceId ? Logger.create(`FFmpegInstance:${instanceId}`, LogLevel.Debug) : baseLogger;\n    const newFfmpeg = new FFmpeg();\n\n    newFfmpeg.on(\"log\", ({ message }) => {\n        if (!message.startsWith(\"frame=\")) {\n            instanceLogger.logDebug(`[FFMPEG_WASM_LOG] ${message}`);\n        }\n    });\n\n    instanceLogger.logInfo(\"[FFMPEG_WASM] Initializing new FFmpeg.wasm instance from local files (using toBlobURL strategy)...\");\n\n    try {\n        const corePathSuffix = \"ffmpeg-core/\";\n        // IMPORTANT: getPathFromExtensionFile needs to be robust for multiple calls\n        // Assuming it consistently returns the correct path relative to the extension root.\n        const coreBaseURL = getPathFromExtensionFile(corePathSuffix);\n        if (!coreBaseURL) {\n            instanceLogger.logError(\"[FFMPEG_WASM] Failed to get base URL for FFmpeg core files.\");\n            return null;\n        }\n\n        const coreJsPath = coreBaseURL + \"ffmpeg-core.js\";\n        const coreWasmPath = coreBaseURL + \"ffmpeg-core.wasm\";\n\n        instanceLogger.logInfo(`[FFMPEG_WASM] Base URL for Blob: ${coreBaseURL}`);\n        instanceLogger.logInfo(\"[FFMPEG_WASM] Attempting to create Blob URLs for core files...\");\n\n        const coreBlobURL = await toBlobURL(coreJsPath, \"text/javascript\");\n        const wasmBlobURL = await toBlobURL(coreWasmPath, \"application/wasm\");\n        instanceLogger.logInfo(\"[FFMPEG_WASM] Blob URLs created. Loading FFmpeg instance...\");\n\n        await newFfmpeg.load({\n            coreURL: coreBlobURL,\n            wasmURL: wasmBlobURL,\n        });\n        instanceLogger.logInfo(\"[FFMPEG_WASM] FFmpeg.wasm instance loaded successfully via Blob URLs.\");\n        return newFfmpeg;\n    } catch (error) {\n        instanceLogger.logError(\"[FFMPEG_WASM] Failed to load FFmpeg.wasm instance via Blob URLs\", error);\n        return null;\n    }\n    // No finally block manipulating global load promise as each instance is independent\n}\n\n// The old loadFFmpeg function is effectively replaced by createAndLoadFFmpegInstance.\n// If other parts of your code were calling loadFFmpeg() expecting it to prepare a global instance,\n// those parts will need to be updated to work with the new instance-based approach,\n// likely via an FFMPEG manager. ","import { FFmpeg } from \"@ffmpeg/ffmpeg\";\nimport { Logger, LogLevel } from \"../utils/logger\";\nimport { createAndLoadFFmpegInstance } from \"./ffmpeg\";\nimport { getConfigValue } from \"../settings/config\";\n\nconst logger = Logger.create(\"FFmpegManager\", LogLevel.Debug);\n\n// const MAX_CONCURRENT_OPERATIONS = 2; // Old hardcoded value\nconst initialMaxFFmpegOperations = Math.max(1, Math.min(Number(getConfigValue(\"maxConcurrentTrackDownloads\")) || 2, 10));\n// Defaulting to 2 if config is not found, and clamped 1-10. \n// This uses the same config key as general track downloads for simplicity.\nconst MAX_CONCURRENT_OPERATIONS = initialMaxFFmpegOperations;\nlogger.logInfo(`FFmpegManager initialized with MAX_CONCURRENT_OPERATIONS: ${MAX_CONCURRENT_OPERATIONS}`);\n\ninterface FFmpegInstanceWrapper {\n    id: number;\n    instance: FFmpeg;\n    isAvailable: boolean;\n    isCompromised: boolean;\n}\n\ninterface RemuxTask {\n    taskId: string; // Typically the downloadId\n    inputBuffer: ArrayBuffer;\n    fileExtension: string;\n    progressCallback?: (progress: number) => void; // For FFMPEG internal progress\n    resolve: (outputBuffer: ArrayBuffer) => void;\n    reject: (error: any) => void;\n}\n\nconst ffmpegPool: FFmpegInstanceWrapper[] = [];\nconst taskQueue: RemuxTask[] = [];\nlet poolInitialized = false;\nlet poolInitializationPromise: Promise<void> | null = null;\n\nasync function initializePool(): Promise<void> {\n    if (poolInitialized) return Promise.resolve();\n    if (poolInitializationPromise) return poolInitializationPromise;\n\n    logger.logInfo(`Initializing FFmpeg instance pool with size: ${MAX_CONCURRENT_OPERATIONS}`);\n    poolInitializationPromise = (async () => {\n        try {\n            const loadPromises: Promise<FFmpeg | null>[] = [];\n            for (let i = 0; i < MAX_CONCURRENT_OPERATIONS; i++) {\n                loadPromises.push(createAndLoadFFmpegInstance(i));\n            }\n\n            const loadedInstances = await Promise.all(loadPromises);\n\n            for (let i = 0; i < loadedInstances.length; i++) {\n                const instance = loadedInstances[i];\n                if (instance) {\n                    ffmpegPool.push({ id: i, instance, isAvailable: true, isCompromised: false });\n                } else {\n                    logger.logError(`Failed to load FFmpeg instance ${i} for the pool.`);\n                }\n            }\n\n            if (ffmpegPool.length === 0 && MAX_CONCURRENT_OPERATIONS > 0) {\n                throw new Error(\"No FFmpeg instances could be initialized for the pool.\");\n            }\n\n            poolInitialized = true;\n            logger.logInfo(`FFmpeg instance pool initialized with ${ffmpegPool.length} instances.`);\n        } catch (error) {\n            logger.logError(\"Failed to initialize FFmpeg pool\", error);\n            poolInitialized = false; // Ensure it can be retried if needed\n            poolInitializationPromise = null; // Reset promise on failure\n            throw error; // Re-throw to propagate the error\n        }\n    })();\n    return poolInitializationPromise;\n}\n\nasync function _performRemux(instanceWrapper: FFmpegInstanceWrapper, task: RemuxTask): Promise<void> {\n    const { instance, id: instanceId } = instanceWrapper;\n    const { taskId, inputBuffer, fileExtension, progressCallback, resolve, reject } = task;\n\n    const inputFilename = `input_${taskId}_${instanceId}.${fileExtension || \"mp4\"}`;\n    const outputFilename = `output_remuxed_${taskId}_${instanceId}.${fileExtension || \"mp4\"}`;\n    logger.logInfo(`[FFmpegManager] Instance ${instanceId} starting remux for task ${taskId}: ${inputFilename} -> ${outputFilename}`);\n\n    let ffmpegProgressHandler: (({ progress }: { progress: number; }) => void) | undefined;\n\n    try {\n        let uInt8ArrayBuffer: Uint8Array;\n        try {\n            logger.logDebug(`[FFmpegManager] Instance ${instanceId}, Task ${taskId}: Attempting inputBuffer.slice(0). Input buffer byteLength: ${inputBuffer?.byteLength}`);\n            const slicedBuffer = inputBuffer.slice(0);\n            logger.logDebug(`[FFmpegManager] Instance ${instanceId}, Task ${taskId}: Successfully sliced buffer. Slice byteLength: ${slicedBuffer?.byteLength}. Attempting new Uint8Array().`);\n            uInt8ArrayBuffer = new Uint8Array(slicedBuffer);\n            logger.logDebug(`[FFmpegManager] Instance ${instanceId}, Task ${taskId}: Created Uint8Array with byteLength: ${uInt8ArrayBuffer?.byteLength}. About to call instance.writeFile with ${inputFilename}.`);\n        } catch (bufferError) {\n            logger.logError(`[FFmpegManager] Instance ${instanceId}, Task ${taskId}: ERROR during buffer slice or Uint8Array creation:`, bufferError);\n            throw bufferError; // Re-throw to be caught by the outer catch\n        }\n\n        await instance.writeFile(inputFilename, uInt8ArrayBuffer);\n        logger.logDebug(`[FFmpegManager] Instance ${instanceId}, Task ${taskId}: Successfully called instance.writeFile with ${inputFilename}.`);\n\n        const ffmpegArgs = [\"-loglevel\", \"debug\", \"-i\", inputFilename, \"-c\", \"copy\", outputFilename];\n        logger.logDebug(`[FFmpegManager] Instance ${instanceId}, Task ${taskId}: FFmpeg exec arguments:`, ffmpegArgs);\n\n        if (progressCallback) {\n            let lastReportedFFmpegProgress = -1;\n            ffmpegProgressHandler = ({ progress }: { progress: number }) => {\n                const currentFFmpegProgress = Math.round(progress * 100);\n                if (currentFFmpegProgress > lastReportedFFmpegProgress && currentFFmpegProgress <= 100) {\n                    // Example: FFMPEG remuxing can be considered a part of total progress,\n                    // e.g., from 85% to 98%. The caller needs to scale this.\n                    progressCallback(currentFFmpegProgress);\n                    lastReportedFFmpegProgress = currentFFmpegProgress;\n                }\n            };\n            instance.on(\"progress\", ffmpegProgressHandler);\n        }\n\n        await instance.exec(ffmpegArgs);\n        const outputData = await instance.readFile(outputFilename);\n\n        if (typeof outputData === \"string\") {\n            throw new Error(\"FFmpeg remux output was a string, expected Uint8Array\");\n        }\n\n        logger.logInfo(`[FFmpegManager] Instance ${instanceId} finished remux for task ${taskId}`);\n        resolve(outputData.buffer.slice(0)); // Resolve with a copy of the buffer\n\n    } catch (error) {\n        logger.logError(`[FFmpegManager] Instance ${instanceId} FAILED remux for task ${taskId}`, error);\n        instanceWrapper.isCompromised = true; // Mark as compromised\n        reject(error);\n    } finally {\n        if (ffmpegProgressHandler && typeof instance.off === \"function\") {\n            instance.off(\"progress\", ffmpegProgressHandler);\n        }\n        try {\n            await instance.deleteFile(inputFilename);\n            await instance.deleteFile(outputFilename);\n        } catch (cleanupError) {\n            logger.logWarn(`[FFmpegManager] Instance ${instanceId} failed to cleanup files for task ${taskId}`, cleanupError);\n            instanceWrapper.isCompromised = true; // Mark as compromised if cleanup fails too\n        }\n    }\n}\n\nfunction processQueue(): void {\n    if (!poolInitialized || taskQueue.length === 0) {\n        return;\n    }\n\n    const availableInstanceWrapper = ffmpegPool.find(iw => iw.isAvailable);\n    if (!availableInstanceWrapper) {\n        logger.logDebug(\"No FFmpeg instance available right now, queue length: \" + taskQueue.length);\n        return;\n    }\n\n    const taskToProcess = taskQueue.shift();\n    if (!taskToProcess) {\n        return; // Should not happen if queue.length > 0\n    }\n\n    availableInstanceWrapper.isAvailable = false;\n    logger.logDebug(`Assigning task ${taskToProcess.taskId} to FFmpeg instance ${availableInstanceWrapper.id}`);\n\n    _performRemux(availableInstanceWrapper, taskToProcess)\n        .finally(async () => {\n            if (availableInstanceWrapper.isCompromised) {\n                logger.logWarn(`[FFmpegManager] Instance ${availableInstanceWrapper.id} is compromised. Terminating and attempting to replace.`);\n                try {\n                    await availableInstanceWrapper.instance.terminate();\n                    logger.logInfo(`[FFmpegManager] Terminated compromised instance ${availableInstanceWrapper.id}.`);\n                } catch (terminateError) {\n                    logger.logError(`[FFmpegManager] Error terminating compromised instance ${availableInstanceWrapper.id}:`, terminateError);\n                }\n\n                // Remove from pool\n                const poolIndex = ffmpegPool.findIndex(iw => iw.id === availableInstanceWrapper.id);\n                if (poolIndex > -1) {\n                    ffmpegPool.splice(poolIndex, 1);\n                }\n\n                // Attempt to create and add a new instance\n                logger.logInfo(`[FFmpegManager] Attempting to create new FFmpeg instance to replace ${availableInstanceWrapper.id}.`);\n                const newInstance = await createAndLoadFFmpegInstance(availableInstanceWrapper.id); // Reuse ID for logging context\n                if (newInstance) {\n                    ffmpegPool.push({\n                        id: availableInstanceWrapper.id, // Keep original ID for slot reference\n                        instance: newInstance,\n                        isAvailable: true,\n                        isCompromised: false\n                    });\n                    logger.logInfo(`[FFmpegManager] Successfully replaced instance ${availableInstanceWrapper.id}. Pool size: ${ffmpegPool.length}`);\n                } else {\n                    logger.logError(`[FFmpegManager] Failed to create new FFmpeg instance to replace ${availableInstanceWrapper.id}. Pool size will be reduced.`);\n                }\n            } else {\n                availableInstanceWrapper.isAvailable = true;\n                logger.logDebug(`FFmpeg instance ${availableInstanceWrapper.id} is now available.`);\n            }\n            processQueue(); // Attempt to process next task\n        });\n}\n\nexport async function requestRemux(\n    taskId: string, // Typically the downloadId\n    inputBuffer: ArrayBuffer,\n    fileExtension: string,\n    ffmpegProgress?: (ffmpegInternalProgress: number) => void // Callback for FFMPEG's own 0-100% progress\n): Promise<ArrayBuffer> {\n    if (!poolInitialized && !poolInitializationPromise) {\n        initializePool().catch(err => {\n            logger.logError(\"FFmpeg Pool Initialization failed lazily, subsequent requests might fail.\", err);\n            // Don't rethrow here as the promise for this request will handle it.\n        });\n    }\n    // Wait for initialization if it's in progress\n    if (poolInitializationPromise) {\n        await poolInitializationPromise;\n    }\n\n    if (!poolInitialized || ffmpegPool.length === 0) {\n        return Promise.reject(new Error(\"FFmpegManager: Pool not initialized or no instances available after init attempt.\"));\n    }\n\n    return new Promise<ArrayBuffer>((resolve, reject) => {\n        logger.logDebug(`Task ${taskId} added to FFmpeg remux queue.`);\n        taskQueue.push({\n            taskId,\n            inputBuffer,\n            fileExtension,\n            progressCallback: ffmpegProgress, // Pass the FFMPEG specific progress callback\n            resolve,\n            reject,\n        });\n        processQueue();\n    });\n}\n\n// Optional: Pre-initialize the pool when the background script starts.\n// This can be called from background.ts after initial config load.\nexport function preInitializeFFmpegPool(): void {\n    if (!poolInitialized && !poolInitializationPromise) {\n        initializePool().catch(err => {\n            logger.logError(\"Pre-initialization of FFmpeg Pool failed.\", err);\n        });\n    }\n} ","function e(e){return String(e).split(\"\").map((e=>e.charCodeAt(0)))}function t(t){return new Uint8Array(e(t))}function a(t){const a=new ArrayBuffer(2*t.length),r=new Uint8Array(a);return new Uint16Array(a).set(e(t)),r}function r(e){const t=255;return[e>>>24&t,e>>>16&t,e>>>8&t,e&t]}function n(e){return 11+e}function s(e,t,a,r){return 11+t+1+1+(r?2+2*(a+1):a+1)+e}function i(e){let t=0;return e.forEach((e=>{t+=2+2*e[0].length+2+2+2*e[1].length+2})),11+t}function c(e,t){const a=2*t;let r=0;return e.forEach((e=>{r+=2+2*e[0].length+2+4})),18+a+2+r}class o{_setIntegerFrame(e,t){const a=parseInt(t,10);this.frames.push({name:e,value:a,size:n(a.toString().length)})}_setStringFrame(e,t){const a=t.toString();let r=13+2*a.length;\"TDAT\"===e&&(r=n(a.length)),this.frames.push({name:e,value:a,size:r})}_setPictureFrame(e,t,a,r){const n=function(e){if(!e||!e.length)return null;if(255===e[0]&&216===e[1]&&255===e[2])return\"image/jpeg\";if(137===e[0]&&80===e[1]&&78===e[2]&&71===e[3])return\"image/png\";if(71===e[0]&&73===e[1]&&70===e[2])return\"image/gif\";if(87===e[8]&&69===e[9]&&66===e[10]&&80===e[11])return\"image/webp\";const t=73===e[0]&&73===e[1]&&42===e[2]&&0===e[3],a=77===e[0]&&77===e[1]&&0===e[2]&&42===e[3];return t||a?\"image/tiff\":66===e[0]&&77===e[1]?\"image/bmp\":0===e[0]&&0===e[1]&&1===e[2]&&0===e[3]?\"image/x-icon\":null}(new Uint8Array(t)),i=a.toString();if(!n)throw new Error(\"Unknown picture MIME type\");a||(r=!1),this.frames.push({name:\"APIC\",value:t,pictureType:e,mimeType:n,useUnicodeEncoding:r,description:i,size:s(t.byteLength,n.length,i.length,r)})}_setLyricsFrame(e,t,a){const r=e.split(\"\").map((e=>e.charCodeAt(0))),n=t.toString(),s=a.toString();var i,c;this.frames.push({name:\"USLT\",value:s,language:r,description:n,size:(i=n.length,c=s.length,16+2*i+2+2+2*c)})}_setCommentFrame(e,t,a){const r=e.split(\"\").map((e=>e.charCodeAt(0))),n=t.toString(),s=a.toString();var i,c;this.frames.push({name:\"COMM\",value:s,language:r,description:n,size:(i=n.length,c=s.length,16+2*i+2+2+2*c)})}_setPrivateFrame(e,t){const a=e.toString();var r,n;this.frames.push({name:\"PRIV\",value:t,id:a,size:(r=a.length,n=t.byteLength,10+r+1+n)})}_setUserStringFrame(e,t){const a=e.toString(),r=t.toString();var n,s;this.frames.push({name:\"TXXX\",description:a,value:r,size:(n=a.length,s=r.length,13+2*n+2+2+2*s)})}_setUrlLinkFrame(e,t){const a=t.toString();var r;this.frames.push({name:e,value:a,size:(r=a.length,10+r)})}_setPairedTextFrame(e,t){this.frames.push({name:e,value:t,size:i(t)})}_setSynchronisedLyricsFrame(e,t,a,r,n){const s=n.toString(),i=r.split(\"\").map((e=>e.charCodeAt(0)));this.frames.push({name:\"SYLT\",value:t,language:i,description:s,type:e,timestampFormat:a,size:c(t,s.length)})}constructor(e){if(!e||\"object\"!=typeof e||!(\"byteLength\"in e))throw new Error(\"First argument should be an instance of ArrayBuffer or Buffer\");this.arrayBuffer=e,this.padding=4096,this.frames=[],this.url=\"\"}setFrame(e,t){switch(e){case\"TPE1\":case\"TCOM\":case\"TCON\":{if(!Array.isArray(t))throw new Error(`${e} frame value should be an array of strings`);const a=\"TCON\"===e?\";\":\"/\",r=t.join(a);this._setStringFrame(e,r);break}case\"TLAN\":case\"TIT1\":case\"TIT2\":case\"TIT3\":case\"TALB\":case\"TPE2\":case\"TPE3\":case\"TPE4\":case\"TRCK\":case\"TPOS\":case\"TMED\":case\"TPUB\":case\"TCOP\":case\"TKEY\":case\"TEXT\":case\"TDAT\":case\"TCMP\":case\"TSRC\":this._setStringFrame(e,t);break;case\"TBPM\":case\"TLEN\":case\"TYER\":this._setIntegerFrame(e,t);break;case\"USLT\":if(t.language=t.language||\"eng\",\"object\"!=typeof t||!(\"description\"in t)||!(\"lyrics\"in t))throw new Error(\"USLT frame value should be an object with keys description and lyrics\");if(t.language&&!t.language.match(/[a-z]{3}/i))throw new Error(\"Language must be coded following the ISO 639-2 standards\");this._setLyricsFrame(t.language,t.description,t.lyrics);break;case\"APIC\":if(\"object\"!=typeof t||!(\"type\"in t)||!(\"data\"in t)||!(\"description\"in t))throw new Error(\"APIC frame value should be an object with keys type, data and description\");if(t.type<0||t.type>20)throw new Error(\"Incorrect APIC frame picture type\");this._setPictureFrame(t.type,t.data,t.description,!!t.useUnicodeEncoding);break;case\"TXXX\":if(\"object\"!=typeof t||!(\"description\"in t)||!(\"value\"in t))throw new Error(\"TXXX frame value should be an object with keys description and value\");this._setUserStringFrame(t.description,t.value);break;case\"WCOM\":case\"WCOP\":case\"WOAF\":case\"WOAR\":case\"WOAS\":case\"WORS\":case\"WPAY\":case\"WPUB\":this._setUrlLinkFrame(e,t);break;case\"COMM\":if(t.language=t.language||\"eng\",\"object\"!=typeof t||!(\"description\"in t)||!(\"text\"in t))throw new Error(\"COMM frame value should be an object with keys description and text\");if(t.language&&!t.language.match(/[a-z]{3}/i))throw new Error(\"Language must be coded following the ISO 639-2 standards\");this._setCommentFrame(t.language,t.description,t.text);break;case\"PRIV\":if(\"object\"!=typeof t||!(\"id\"in t)||!(\"data\"in t))throw new Error(\"PRIV frame value should be an object with keys id and data\");this._setPrivateFrame(t.id,t.data);break;case\"IPLS\":if(!Array.isArray(t)||!Array.isArray(t[0]))throw new Error(\"IPLS frame value should be an array of pairs\");this._setPairedTextFrame(e,t);break;case\"SYLT\":if(\"object\"!=typeof t||!(\"type\"in t)||!(\"text\"in t)||!(\"timestampFormat\"in t))throw new Error(\"SYLT frame value should be an object with keys type, text and timestampFormat\");if(!Array.isArray(t.text)||!Array.isArray(t.text[0]))throw new Error(\"SYLT frame text value should be an array of pairs\");if(t.type<0||t.type>6)throw new Error(\"Incorrect SYLT frame content type\");if(t.timestampFormat<1||t.timestampFormat>2)throw new Error(\"Incorrect SYLT frame time stamp format\");t.language=t.language||\"eng\",t.description=t.description||\"\",this._setSynchronisedLyricsFrame(t.type,t.text,t.timestampFormat,t.language,t.description);break;default:throw new Error(`Unsupported frame ${e}`)}return this}removeTag(){if(this.arrayBuffer.byteLength<10)return;const e=new Uint8Array(this.arrayBuffer),t=e[3],a=((r=[e[6],e[7],e[8],e[9]])[0]<<21)+(r[1]<<14)+(r[2]<<7)+r[3]+10;var r,n;73!==(n=e)[0]||68!==n[1]||51!==n[2]||t<2||t>4||(this.arrayBuffer=new Uint8Array(e.subarray(a)).buffer)}addTag(){this.removeTag();const e=[255,254],n=10+this.frames.reduce(((e,t)=>e+t.size),0)+this.padding,s=new ArrayBuffer(this.arrayBuffer.byteLength+n),i=new Uint8Array(s);let c=0,o=[];return o=[73,68,51,3],i.set(o,c),c+=o.length,c++,c++,o=function(e){const t=127;return[e>>>21&t,e>>>14&t,e>>>7&t,e&t]}(n-10),i.set(o,c),c+=o.length,this.frames.forEach((n=>{switch(o=t(n.name),i.set(o,c),c+=o.length,o=r(n.size-10),i.set(o,c),c+=o.length,c+=2,n.name){case\"WCOM\":case\"WCOP\":case\"WOAF\":case\"WOAR\":case\"WOAS\":case\"WORS\":case\"WPAY\":case\"WPUB\":o=t(n.value),i.set(o,c),c+=o.length;break;case\"TPE1\":case\"TCOM\":case\"TCON\":case\"TLAN\":case\"TIT1\":case\"TIT2\":case\"TIT3\":case\"TALB\":case\"TPE2\":case\"TPE3\":case\"TPE4\":case\"TRCK\":case\"TPOS\":case\"TKEY\":case\"TMED\":case\"TPUB\":case\"TCOP\":case\"TEXT\":case\"TSRC\":o=[1].concat(e),i.set(o,c),c+=o.length,o=a(n.value),i.set(o,c),c+=o.length;break;case\"TXXX\":case\"USLT\":case\"COMM\":o=[1],\"USLT\"!==n.name&&\"COMM\"!==n.name||(o=o.concat(n.language)),o=o.concat(e),i.set(o,c),c+=o.length,o=a(n.description),i.set(o,c),c+=o.length,o=[0,0].concat(e),i.set(o,c),c+=o.length,o=a(n.value),i.set(o,c),c+=o.length;break;case\"TBPM\":case\"TLEN\":case\"TDAT\":case\"TYER\":c++,o=t(n.value),i.set(o,c),c+=o.length;break;case\"PRIV\":o=t(n.id),i.set(o,c),c+=o.length,c++,i.set(new Uint8Array(n.value),c),c+=n.value.byteLength;break;case\"APIC\":o=[n.useUnicodeEncoding?1:0],i.set(o,c),c+=o.length,o=t(n.mimeType),i.set(o,c),c+=o.length,o=[0,n.pictureType],i.set(o,c),c+=o.length,n.useUnicodeEncoding?(o=[].concat(e),i.set(o,c),c+=o.length,o=a(n.description),i.set(o,c),c+=o.length,c+=2):(o=t(n.description),i.set(o,c),c+=o.length,c++),i.set(new Uint8Array(n.value),c),c+=n.value.byteLength;break;case\"IPLS\":o=[1],i.set(o,c),c+=o.length,n.value.forEach((t=>{o=[].concat(e),i.set(o,c),c+=o.length,o=a(t[0].toString()),i.set(o,c),c+=o.length,o=[0,0].concat(e),i.set(o,c),c+=o.length,o=a(t[1].toString()),i.set(o,c),c+=o.length,o=[0,0],i.set(o,c),c+=o.length}));break;case\"SYLT\":o=[1].concat(n.language).concat(n.timestampFormat).concat(n.type),i.set(o,c),c+=o.length,o=[].concat(e),i.set(o,c),c+=o.length,o=a(n.description),i.set(o,c),c+=o.length,c+=2,n.value.forEach((t=>{o=[].concat(e),i.set(o,c),c+=o.length,o=a(t[0].toString()),i.set(o,c),c+=o.length,o=[0,0],i.set(o,c),c+=o.length,o=r(t[1]),i.set(o,c),c+=o.length}))}})),c+=this.padding,i.set(new Uint8Array(this.arrayBuffer),c),this.arrayBuffer=s,s}getBlob(){return new Blob([this.arrayBuffer],{type:\"audio/mpeg\"})}getURL(){return this.url||(this.url=URL.createObjectURL(this.getBlob())),this.url}revokeURL(){URL.revokeObjectURL(this.url)}}export{o as ID3Writer};","import { ID3Writer } from \"browser-id3-writer\";\nimport { TagWriter } from \"./tagWriter\";\nimport type { TagWriterOutput } from \"./tagWriter\";\n\nexport class Mp3TagWriter implements TagWriter {\n  private writer: ID3Writer;\n\n  constructor(buffer: ArrayBuffer) {\n    this.writer = new ID3Writer(buffer);\n  }\n\n  setTitle(title: string): void {\n    if (!title) throw new Error(\"Invalid value for title\");\n\n    this.writer.setFrame(\"TIT2\", title);\n  }\n\n  setArtists(artists: string[]): void {\n    if (!artists || artists.length < 1) throw new Error(\"Invalid value for artists\");\n\n    this.writer.setFrame(\"TPE1\", artists);\n  }\n\n  setAlbum(album: string): void {\n    if (!album) throw new Error(\"Invalid value for album\");\n\n    this.writer.setFrame(\"TALB\", album);\n  }\n\n  setComment(comment: string): void {\n    if (!comment) throw new Error(\"Invalid value for comment\");\n\n    this.writer.setFrame(\"COMM\", {\n      text: comment,\n      description: \"\",\n    });\n  }\n\n  setTrackNumber(trackNumber: number): void {\n    // not sure what the highest track number is for ID3, but let's assume it's the max value of short\n    if (trackNumber < 1 || trackNumber > 32767) throw new Error(\"Invalid value for trackNumber\");\n\n    this.writer.setFrame(\"TRCK\", trackNumber.toString());\n  }\n\n  setYear(year: number): void {\n    if (year < 1) throw new Error(\"Invalud value for year\");\n\n    this.writer.setFrame(\"TYER\", year);\n  }\n\n  setGrouping(grouping: string): void {\n    if (!grouping) throw new Error(\"Invalid value for grouping\");\n\n    this.writer.setFrame(\"TIT1\", grouping);\n  }\n\n  setArtwork(artworkBuffer: ArrayBuffer): void {\n    if (!artworkBuffer || artworkBuffer.byteLength < 1) throw new Error(\"Invalid value for artworkBuffer\");\n\n    this.writer.setFrame(\"APIC\", {\n      type: 3,\n      data: artworkBuffer,\n      description: \"\",\n    });\n  }\n\n  getBuffer(): Promise<TagWriterOutput> {\n    this.writer.addTag();\n\n    const blob = this.writer.getBlob();\n\n    return blob.arrayBuffer().then(buffer => {\n      return { buffer, tagsApplied: true };\n    });\n  }\n}\n","import { TagWriter } from \"./tagWriter\";\nimport { Logger, LogLevel } from \"../../utils/logger\";\nimport { concatArrayBuffers } from \"../download\";\nimport type { TagWriterOutput } from \"./tagWriter\";\n\ninterface Atom {\n  length: number;\n  name?: string;\n  offset?: number;\n  children?: Atom[];\n  data?: ArrayBuffer;\n}\n\ninterface AtomLevel {\n  parent: Atom;\n  offset: number;\n  childIndex: number;\n}\n\n// length(4) + name(4)\nconst ATOM_HEAD_LENGTH = 8;\n// data-length(4) + data-name(4) + data-flags(4)\nconst ATOM_DATA_HEAD_LENGTH = 16;\n\nconst ATOM_HEADER_LENGTH = ATOM_HEAD_LENGTH + ATOM_DATA_HEAD_LENGTH;\n\nclass Mp4 {\n  private readonly _metadataPath = [\"moov\", \"udta\", \"meta\", \"ilst\"];\n  private _buffer: ArrayBuffer | null;\n  private _bufferView: DataView | null;\n  private _atoms: Atom[] = [];\n  private _loggedErrors: Set<string> = new Set();\n  private _hasValidStructure = false;\n  private _logger: Logger;\n\n  public get hasValidMp4Structure(): boolean {\n    return this._hasValidStructure;\n  }\n\n  private _logError(message: string): void {\n    // Only log each unique error message once\n    if (!this._loggedErrors.has(message)) {\n      this._logger.logDebug(`MP4 metadata: ${message}`); // Using logDebug instead of logError\n      this._loggedErrors.add(message);\n    }\n  }\n\n  constructor(buffer: ArrayBuffer) {\n    this._buffer = buffer;\n    this._bufferView = new DataView(buffer);\n    this._logger = Logger.create(\"MP4TagWriterInternals\", LogLevel.Debug); // Changed source name and level\n  }\n\n  parse() {\n    if (!this._buffer) throw new Error(\"Buffer can not be null\");\n    if (this._atoms.length > 0) throw new Error(\"Buffer already parsed\");\n    this._logger.logDebug(\"Starting MP4 parse...\"); // Add start marker\n\n    let offset = 0;\n    let atom: Atom;\n    let atomsFound: { name: string; length: number; offset: number }[] = []; // Store found atoms\n\n    while (true) {\n      atom = this._readAtom(offset);\n\n      if (!atom || atom.length < 1 || offset >= this._buffer.byteLength) { // Add buffer boundary check\n        if (offset < this._buffer.byteLength) {\n          this._logger.logDebug(`Parsing stopped: _readAtom returned invalid atom or zero length at offset ${offset}.`);\n        } else {\n          this._logger.logDebug(`Parsing stopped: Reached end of buffer at offset ${offset}.`);\n        }\n        break;\n      }\n\n      // Log details of the found atom\n      atomsFound.push({ name: atom.name || \"undefined\", length: atom.length, offset: atom.offset });\n      // this._logger.logDebug(`Found top-level atom: Name=${atom.name || '?'}, Length=${atom.length}, Offset=${atom.offset}`);\n\n      this._atoms.push(atom);\n      offset = atom.offset + atom.length;\n\n      // Safety break if offset seems wrong (e.g., negative length, goes backwards)\n      if (offset <= atom.offset) {\n        this._logger.logError(`Parsing stopped: Invalid offset progression. Current offset ${atom.offset}, next offset calculated as ${offset}.`);\n        break;\n      }\n    }\n\n    this._logger.logDebug(`Finished MP4 parse. Found ${this._atoms.length} top-level atoms.`);\n    // Log the summary of atoms found\n    this._logger.logDebug(`Top-level atoms summary: ${JSON.stringify(atomsFound)}`);\n\n\n    if (this._atoms.length < 1) {\n      this._logError(\"Buffer could not be parsed - no valid top-level atoms found.\"); // Changed error message slightly\n      this._hasValidStructure = false;\n      return; // Exit early if no atoms found\n    }\n\n    // Check if this is a valid MP4 file with a 'moov' atom (case-insensitive check just for this debug step)\n    const moovAtom = this._atoms.find(a => a.name?.toLowerCase() === \"moov\");\n    this._hasValidStructure = !!moovAtom; // Set based on finding 'moov' (case-insensitive for now)\n\n    if (!this._hasValidStructure) {\n      this._logError(\"File structure check failed: Did not find a top-level 'moov' atom (checked case-insensitively).\");\n    } else {\n      this._logger.logDebug(\"File structure check passed: Found top-level 'moov' atom (case-insensitive check).\");\n    }\n  }\n\n  setDuration(duration: number) {\n    try {\n      // Skip if not a valid MP4 structure\n      if (!this._hasValidStructure) {\n        this._logError(\"Cannot set duration - file doesn't have a valid MP4 structure\");\n        return;\n      }\n\n      const mvhdAtom: Atom = this._findAtom(this._atoms, [\"moov\", \"mvhd\"]);\n\n      if (!mvhdAtom) throw new Error(\"'mvhd' atom could not be found\");\n\n      // version(4) + created(4) + modified(4) + timescale(4)\n      const precedingDataLength = 16;\n      this._bufferView.setUint32(mvhdAtom.offset + ATOM_HEAD_LENGTH + precedingDataLength, duration);\n    } catch (error) {\n      this._logError(`Failed to set duration: ${error.message}`);\n    }\n  }\n\n  addMetadataAtom(name: string, data: ArrayBuffer | string | number) {\n    try {\n      // Skip if not a valid MP4 structure\n      if (!this._hasValidStructure) {\n        this._logError(`Cannot add ${name} metadata - file doesn't have a valid MP4 structure`);\n        return;\n      }\n\n      if (name.length > 4 || name.length < 1) throw new Error(`Unsupported atom name: '${name}'`);\n\n      let dataBuffer: ArrayBuffer;\n\n      if (data instanceof ArrayBuffer) {\n        dataBuffer = data;\n      } else if (typeof data === \"string\") {\n        dataBuffer = this._getBufferFromString(data);\n      } else if (typeof data === \"number\") {\n        dataBuffer = new ArrayBuffer(4);\n        const dataView = new DataView(dataBuffer);\n        dataView.setUint32(0, data);\n      } else {\n        throw new Error(`Unsupported data: '${data}'`);\n      }\n\n      const atom: Atom = {\n        name,\n        length: ATOM_HEADER_LENGTH + dataBuffer.byteLength,\n        data: dataBuffer,\n      };\n\n      this._insertAtom(atom, this._metadataPath);\n    } catch (error) {\n      // Log error but don't throw - this makes the tag writer more resilient\n      this._logError(`Failed to add metadata atom '${name}': ${error.message}`);\n    }\n  }\n\n  getBuffer() {\n    const buffers: ArrayBuffer[] = [];\n    let bufferIndex = 0;\n\n    // we don't change the offsets, since it would add needless complexity without benefit\n    for (const atom of this._atoms) {\n      if (!atom.children) {\n        // nothing has been added or removed\n        const slice = this._buffer.slice(atom.offset, atom.offset + atom.length);\n        buffers.push(slice);\n        bufferIndex++;\n\n        continue;\n      }\n\n      atom.length = ATOM_HEAD_LENGTH;\n\n      const levels: AtomLevel[] = [{ parent: atom, offset: bufferIndex, childIndex: 0 }];\n      let levelIndex = 0;\n\n      while (true) {\n        const { parent, offset, childIndex } = levels[levelIndex];\n\n        if (childIndex >= parent.children.length) {\n          // move one level up\n          levelIndex--;\n          levels.pop();\n\n          let parentHeadLength = ATOM_HEAD_LENGTH;\n          if (parent.name === \"meta\") {\n            parent.length += 4;\n            parentHeadLength += 4;\n          } else if (parent.name === \"stsd\") {\n            parent.length += 8;\n            parentHeadLength += 8;\n          }\n\n          // set length of parent in buffer\n          this._bufferView.setUint32(parent.offset, parent.length);\n\n          const parentHeader = this._buffer.slice(parent.offset, parent.offset + parentHeadLength);\n          buffers.splice(offset, 0, parentHeader);\n\n          // we completed the last parent - exit\n          if (levelIndex < 0) break;\n\n          // add our current parents length to new parent and move childIndex of new parent one ahead\n          const newParent = levels[levelIndex].parent;\n          newParent.length += parent.length;\n          levels[levelIndex].childIndex++;\n\n          continue;\n        }\n\n        const child = parent.children[childIndex];\n\n        if (child.children) {\n          // move one level down\n          child.length = ATOM_HEAD_LENGTH;\n          levels.push({ parent: child, offset: bufferIndex, childIndex: 0 });\n          levelIndex++;\n          continue;\n        } else if (child.data) {\n          // add new data to buffer\n          const headerBuffer = this._getHeaderBufferFromAtom(child);\n          buffers.push(headerBuffer);\n          buffers.push(child.data);\n        } else {\n          // add entire child to buffer\n          const slice = this._buffer.slice(child.offset, child.offset + child.length);\n          buffers.push(slice);\n        }\n\n        bufferIndex++;\n\n        parent.length += child.length;\n\n        // move one child ahead\n        levels[levelIndex].childIndex++;\n      }\n    }\n\n    this._bufferView = null;\n    this._buffer = null;\n    this._atoms = [];\n\n    return concatArrayBuffers(buffers);\n  }\n\n  private _insertAtom(atom: Atom, path: string[]) {\n    try {\n      this._logger.logDebug(`Attempting to insert atom '${atom.name}' at path '${path.join(\" > \")}'.`);\n      // For tag atoms, the path should always end in 'ilst'\n      if (!path || path[path.length - 1] !== \"ilst\") {\n        this._logError(`Cannot insert tag atom '${atom.name}': Path does not end in 'ilst'.`);\n        return;\n      }\n\n      // Ensure the metadata path exists, potentially creating it. Get the 'ilst' atom.\n      const parentAtom = this._createMetadataPath(); // This now returns the 'ilst' atom or null\n\n      if (!parentAtom) {\n        // _createMetadataPath already logged the error\n        this._logError(`Cannot insert atom '${atom.name}': Failed to find or create parent 'ilst' atom.`);\n        return;\n      }\n\n      // Ensure parent's children are loaded (should be handled by _createMetadataPath returning it)\n      if (parentAtom.children === undefined) {\n        parentAtom.children = this._readChildAtoms(parentAtom);\n        this._logger.logDebug(`Loaded children for '${parentAtom.name}' in _insertAtom.`);\n      }\n\n      // Check if an atom with the same name already exists (e.g., existing 'covr')\n      // Simple replacement: remove existing, add new. More complex merging could be added later.\n      const existingIndex = parentAtom.children.findIndex(child => child.name === atom.name);\n      if (existingIndex !== -1) {\n        this._logger.logDebug(`Replacing existing atom '${atom.name}' in '${parentAtom.name}'.`);\n        parentAtom.children.splice(existingIndex, 1);\n      }\n\n\n      // Calculate offset placeholder (actual position determined during getBuffer reconstruction)\n      let offset = parentAtom.offset + this._getAtomHeaderLength(parentAtom);\n      if (parentAtom.children.length > 0) {\n        const lastChild = parentAtom.children[parentAtom.children.length - 1];\n        offset = lastChild.offset + lastChild.length; // Append after last child\n      }\n      atom.offset = offset; // Assign placeholder offset\n\n      // Add the new atom\n      parentAtom.children.push(atom);\n      this._logger.logDebug(`Successfully prepared atom '${atom.name}' for insertion into '${parentAtom.name}'.`);\n\n      // Note: Parent atom lengths will be recalculated in getBuffer()\n    } catch (error) {\n      this._logError(`Error during _insertAtom for '${atom.name}': ${error.message}`);\n    }\n  }\n\n  private _findAtom(atoms: Atom[], path: string[]): Atom | null {\n    if (!path || path.length < 1) throw new Error(\"Path can not be empty\");\n\n    const curPath = [...path];\n    const curName = curPath.shift();\n    const curElem = atoms.find((i) => i.name === curName);\n\n    if (curPath.length < 1) return curElem;\n\n    if (!curElem) return null;\n\n    if (curElem.children === undefined) {\n      curElem.children = this._readChildAtoms(curElem);\n    }\n\n    if (curElem.children.length < 1) return null;\n\n    return this._findAtom(curElem.children, curPath);\n  }\n\n  private _readChildAtoms(atom: Atom): Atom[] {\n    const children: Atom[] = [];\n\n    const childEnd = atom.offset + atom.length;\n    let childOffset = atom.offset + ATOM_HEAD_LENGTH;\n\n    if (atom.name === \"meta\") {\n      childOffset += 4;\n    } else if (atom.name === \"stsd\") {\n      childOffset += 8;\n    }\n\n    while (true) {\n      if (childOffset >= childEnd) break;\n\n      const childAtom = this._readAtom(childOffset);\n\n      if (!childAtom || childAtom.length < 1) break;\n\n      childOffset = childAtom.offset + childAtom.length;\n\n      children.push(childAtom);\n    }\n\n    return children;\n  }\n\n  private _readAtom(offset: number): Atom {\n    const begin = offset;\n    const end = offset + ATOM_HEAD_LENGTH;\n\n    const buffer = this._buffer.slice(begin, end);\n\n    if (buffer.byteLength < ATOM_HEAD_LENGTH) {\n      return {\n        length: buffer.byteLength,\n        offset,\n      };\n    }\n\n    const dataView = new DataView(buffer);\n\n    let length = dataView.getUint32(0, false);\n\n    let name = \"\";\n    for (let i = 0; i < 4; i++) {\n      name += String.fromCharCode(dataView.getUint8(4 + i));\n    }\n\n    return {\n      name,\n      length,\n      offset,\n    };\n  }\n\n  private _getHeaderBufferFromAtom(atom: Atom) {\n    if (!atom || atom.length < 1 || !atom.name || !atom.data)\n      throw new Error(\"Can not compute header buffer for this atom\");\n\n    const headerBuffer = new ArrayBuffer(ATOM_HEADER_LENGTH);\n    const headerBufferView = new DataView(headerBuffer);\n\n    // length at 0, length = 4\n    headerBufferView.setUint32(0, atom.length);\n\n    // name at 4, length = 4\n    const nameChars = this._getCharCodes(atom.name);\n    for (let i = 0; i < nameChars.length; i++) {\n      headerBufferView.setUint8(4 + i, nameChars[i]);\n    }\n\n    // data length at 8, length = 4\n    headerBufferView.setUint32(8, ATOM_DATA_HEAD_LENGTH + atom.data.byteLength);\n\n    // data name at 12, length = 4\n    const dataNameChars = this._getCharCodes(\"data\");\n    for (let i = 0; i < dataNameChars.length; i++) {\n      headerBufferView.setUint8(12 + i, dataNameChars[i]);\n    }\n\n    // data flags at 16, length = 4\n    headerBufferView.setUint32(16, this._getFlags(atom.name));\n\n    return headerBuffer;\n  }\n\n  private _getBufferFromString(input: string): ArrayBuffer {\n    // return new TextEncoder().encode(input).buffer;\n\n    const buffer = new ArrayBuffer(input.length);\n    const bufferView = new DataView(buffer);\n    const chars = this._getCharCodes(input);\n\n    for (let i = 0; i < chars.length; i++) {\n      bufferView.setUint8(i, chars[i]);\n    }\n\n    return buffer;\n  }\n\n  private _getCharCodes(input: string) {\n    const chars: number[] = [];\n\n    for (let i = 0; i < input.length; i++) {\n      chars.push(input.charCodeAt(i));\n    }\n\n    return chars;\n  }\n\n  private _getFlags(name: string) {\n    switch (name) {\n      case \"covr\":\n        // 13 for jpeg, 14 for png\n        return 13;\n      case \"trkn\":\n      case \"disk\":\n        return 0;\n      case \"tmpo\":\n      case \"cpil\":\n      case \"rtng\":\n        return 21;\n      default:\n        return 1;\n    }\n  }\n\n  // Helper method to create the metadata path if it doesn't exist\n  private _createMetadataPath(): Atom | null { // Return the final 'ilst' atom if successful\n    try {\n      this._logger.logDebug(\"Attempting to ensure metadata path moov > udta > meta > ilst exists.\");\n\n      // 1. Find 'moov' - it must exist for us to proceed.\n      const moovAtom = this._findAtom(this._atoms, [\"moov\"]);\n      if (!moovAtom) {\n        this._logError(\"Cannot create metadata path: Required 'moov' atom not found.\");\n        return null;\n      }\n      // Ensure moov children are loaded for modification\n      if (moovAtom.children === undefined) {\n        moovAtom.children = this._readChildAtoms(moovAtom);\n      }\n\n      let currentParent = moovAtom;\n      const pathSegments = [\"udta\", \"meta\", \"ilst\"];\n\n      for (const segmentName of pathSegments) {\n        let segmentAtom = this._findAtom(currentParent.children, [segmentName]);\n\n        if (!segmentAtom) {\n          this._logger.logDebug(`Creating missing '${segmentName}' atom.`);\n          // Calculate offset: immediately after the parent's header (or after last existing child)\n          let newAtomOffset = currentParent.offset + this._getAtomHeaderLength(currentParent);\n          if (currentParent.children.length > 0) {\n            const lastChild = currentParent.children[currentParent.children.length - 1];\n            newAtomOffset = lastChild.offset + lastChild.length;\n          }\n\n          // Create the new atom with minimal default size\n          const newAtomLength = this._getAtomHeaderLength({ name: segmentName } as Atom);\n          segmentAtom = {\n            name: segmentName,\n            length: newAtomLength,\n            offset: newAtomOffset, // Placeholder offset, might not be perfectly sequential if gaps exist\n            children: [] // Initialize children array\n          };\n\n          // Add to parent's children and update parent's length\n          currentParent.children.push(segmentAtom);\n          // Don't update length here, let getBuffer recalculate based on final children\n\n          this._logger.logDebug(`Created '${segmentName}' atom.`);\n        } else {\n          this._logger.logDebug(`Found existing '${segmentName}' atom.`);\n          // Ensure children are loaded if we plan to descend further\n          if (segmentAtom.children === undefined) {\n            segmentAtom.children = this._readChildAtoms(segmentAtom);\n          }\n        }\n        currentParent = segmentAtom; // Move down the hierarchy\n      }\n\n      // Return the final atom in the path ('ilst')\n      this._logger.logDebug(\"Metadata path creation/verification successful. Returning 'ilst' atom.\");\n      return currentParent;\n\n    } catch (error) {\n      this._logError(`Failed during _createMetadataPath: ${error.message}`);\n      return null;\n    }\n  }\n\n  // Helper to get header length (including meta/stsd variations)\n  private _getAtomHeaderLength(atom: Atom): number {\n    let headLength = ATOM_HEAD_LENGTH;\n    if (atom.name === \"meta\") {\n      headLength += 4; // version/flags\n    } else if (atom.name === \"stsd\") {\n      headLength += 8; // Specific stsd header bytes\n    }\n    return headLength;\n  }\n}\n\nexport class Mp4TagWriter implements TagWriter {\n  private _originalBuffer: ArrayBuffer;\n  private _mp4: Mp4;\n  private _hasValidMp4: boolean = false;\n\n  // Track errors that have already been logged to avoid spamming console\n  private static _loggedErrors: Set<string> = new Set();\n  private static _logger: Logger = Logger.create(\"MP4TagWriter\", LogLevel.Debug);\n\n  private static _logError(message: string): void {\n    // Only log each unique error message once\n    if (!Mp4TagWriter._loggedErrors.has(message)) {\n      Mp4TagWriter._logger.logDebug(`MP4 metadata: ${message}`); // Use logDebug to keep it quieter\n      Mp4TagWriter._loggedErrors.add(message);\n    }\n  }\n\n  constructor(buffer: ArrayBuffer) {\n    try {\n      // Create a clone of the original buffer to avoid detached ArrayBuffer issues\n      this._originalBuffer = buffer.slice(0);\n      Mp4TagWriter._logger.logDebug(`Creating Mp4TagWriter with buffer of size: ${this._originalBuffer.byteLength}`);\n\n      try {\n        this._mp4 = new Mp4(this._originalBuffer);\n        this._mp4.parse();\n        this._hasValidMp4 = this._mp4.hasValidMp4Structure;\n\n        if (!this._hasValidMp4) {\n          Mp4TagWriter._logError(\"MP4 structure validation failed. Tags will not be applied but original audio will still be saved.\");\n        } else {\n          Mp4TagWriter._logger.logDebug(\"MP4 structure validation passed. TagWriter ready for use.\");\n        }\n      } catch (parseError) {\n        this._hasValidMp4 = false;\n        Mp4TagWriter._logError(`Failed to initialize MP4 parser: ${parseError.message}`);\n        // Even if parsing fails, we'll still have the original buffer for fallback\n      }\n    } catch (constructorError) {\n      Mp4TagWriter._logError(`Mp4TagWriter constructor error: ${constructorError.message}`);\n      // Initialize _originalBuffer to an empty buffer as a last resort\n      this._originalBuffer = new ArrayBuffer(0);\n      this._hasValidMp4 = false;\n    }\n  }\n\n  setTitle(title: string): void {\n    try {\n      if (!title) throw new Error(\"Invalid value for title\");\n\n      this._mp4.addMetadataAtom(\"©nam\", title);\n    } catch (error) {\n      Mp4TagWriter._logError(`Failed to set title: ${error.message}`);\n    }\n  }\n\n  setArtists(artists: string[]): void {\n    try {\n      if (!artists || artists.length < 1) throw new Error(\"Invalid value for artists\");\n\n      this._mp4.addMetadataAtom(\"©ART\", artists.join(\", \"));\n    } catch (error) {\n      Mp4TagWriter._logError(`Failed to set artists: ${error.message}`);\n    }\n  }\n\n  setAlbum(album: string): void {\n    try {\n      if (!album) throw new Error(\"Invalid value for album\");\n\n      this._mp4.addMetadataAtom(\"©alb\", album);\n    } catch (error) {\n      Mp4TagWriter._logError(`Failed to set album: ${error.message}`);\n    }\n  }\n\n  setComment(comment: string): void {\n    try {\n      if (!comment) throw new Error(\"Invalid value for comment\");\n\n      this._mp4.addMetadataAtom(\"©cmt\", comment);\n    } catch (error) {\n      Mp4TagWriter._logError(`Failed to set comment: ${error.message}`);\n    }\n  }\n\n  setTrackNumber(trackNumber: number): void {\n    try {\n      // max trackNumber is max of Uint8\n      if (trackNumber < 1 || trackNumber > 32767) throw new Error(\"Invalid value for trackNumber\");\n\n      this._mp4.addMetadataAtom(\"trkn\", trackNumber);\n    } catch (error) {\n      Mp4TagWriter._logError(`Failed to set track number: ${error.message}`);\n    }\n  }\n\n  setYear(year: number): void {\n    try {\n      if (year < 1) throw new Error(\"Invalid value for year\");\n\n      this._mp4.addMetadataAtom(\"©day\", year.toString());\n    } catch (error) {\n      Mp4TagWriter._logError(`Failed to set year: ${error.message}`);\n    }\n  }\n\n  setGrouping(grouping: string): void {\n    try {\n      if (!grouping) throw new Error(\"Invalid value for grouping\");\n\n      this._mp4.addMetadataAtom(\"©grp\", grouping);\n    } catch (error) {\n      Mp4TagWriter._logError(`Failed to set grouping: ${error.message}`);\n    }\n  }\n\n  setArtwork(artworkBuffer: ArrayBuffer): void {\n    try {\n      if (!artworkBuffer || artworkBuffer.byteLength < 1) throw new Error(\"Invalid value for artworkBuffer\");\n\n      this._mp4.addMetadataAtom(\"covr\", artworkBuffer);\n    } catch (error) {\n      Mp4TagWriter._logError(`Failed to set artwork: ${error.message}`);\n    }\n  }\n\n  setDuration(duration: number): void {\n    try {\n      if (duration < 1) throw new Error(\"Invalid value for duration\");\n\n      this._mp4.setDuration(duration);\n    } catch (error) {\n      Mp4TagWriter._logError(`Failed to set duration: ${error.message}`);\n    }\n  }\n\n  getBuffer(): Promise<TagWriterOutput> {\n    try {\n      // Make sure we still have a valid buffer\n      if (!this._originalBuffer || this._originalBuffer.byteLength === 0) {\n        throw new Error(\"Original buffer is missing or empty\");\n      }\n\n      // If MP4 instance is invalid, return original buffer without tagging\n      if (!this._mp4 || !this._hasValidMp4) {\n        Mp4TagWriter._logError(\n          \"MP4 structure check failed. Returning original buffer without applying tags.\"\n        );\n        return Promise.resolve({\n          buffer: this._originalBuffer.slice(0), // Create a fresh copy to avoid detached buffer issues\n          tagsApplied: false,\n          message: \"Invalid MP4 structure for tagging.\"\n        });\n      }\n\n      let processedBuffer: ArrayBuffer;\n      try {\n        processedBuffer = this._mp4.getBuffer();\n\n        // Additional safety check in case getBuffer returns empty or null\n        if (!processedBuffer || processedBuffer.byteLength === 0) {\n          throw new Error(\"Processed buffer is empty or null\");\n        }\n\n        // Create a copy of the processed buffer to avoid any detached buffer issues\n        processedBuffer = processedBuffer.slice(0);\n      } catch (bufferError) {\n        Mp4TagWriter._logError(`Failed to get processed buffer: ${bufferError.message}`);\n        return Promise.resolve({\n          buffer: this._originalBuffer.slice(0), // Create a fresh copy\n          tagsApplied: false,\n          message: `Failed to process MP4 buffer: ${bufferError.message}`\n        });\n      }\n\n      let tagsSuccessfullyApplied = true;\n      let message: string | undefined = undefined;\n\n      if (processedBuffer.byteLength !== this._originalBuffer.byteLength) {\n        tagsSuccessfullyApplied = true;\n        message = `Successfully applied tags (original: ${this._originalBuffer.byteLength}, new: ${processedBuffer.byteLength})`;\n      }\n\n      return Promise.resolve({\n        buffer: processedBuffer,\n        tagsApplied: tagsSuccessfullyApplied,\n        message\n      });\n    } catch (error) {\n      const errorMessage = `Failed to get processed buffer: ${error.message}. Using original buffer as fallback.`;\n      Mp4TagWriter._logError(errorMessage);\n\n      try {\n        // Return a copy of the original buffer to prevent detached ArrayBuffer issues\n        return Promise.resolve({\n          buffer: this._originalBuffer.slice(0),\n          tagsApplied: false,\n          message: errorMessage\n        });\n      } catch (finalError) {\n        // If even creating a copy of the original buffer fails, we're in real trouble\n        Mp4TagWriter._logError(`CRITICAL: Failed to create copy of original buffer: ${finalError.message}`);\n\n        // Return empty buffer as absolute last resort (caller should handle this)\n        return Promise.resolve({\n          buffer: new ArrayBuffer(0),\n          tagsApplied: false,\n          message: `CRITICAL ERROR: ${errorMessage} + ${finalError.message}`\n        });\n      }\n    }\n  }\n}\n","export default function escapeStringRegexp(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n}\n","import escapeStringRegexp from \"escape-string-regexp\";\nimport XRegExp from \"xregexp\";\n\nexport enum ArtistType {\n  Main,\n  Feature,\n  Remixer,\n  Producer,\n}\n\nexport enum RemixType {\n  Remix,\n  Flip,\n  Bootleg,\n  Mashup,\n  Edit,\n}\n\nexport function getRemixTypeFromString(input: string) {\n  const loweredInput = input.toLowerCase().trim();\n\n  switch (loweredInput) {\n    case \"flip\":\n      return RemixType.Flip;\n    case \"bootleg\":\n      return RemixType.Bootleg;\n    case \"mashup\":\n      return RemixType.Mashup;\n    case \"edit\":\n      return RemixType.Edit;\n    case \"remix\":\n    default:\n      return RemixType.Remix;\n  }\n}\n\nexport interface Artist {\n  name: string;\n  type: ArtistType;\n  remixType?: RemixType;\n}\n\ninterface TitleSplit {\n  artistNames: string[];\n  title: string;\n}\n\ninterface RemixTitleSplit {\n  artists: Artist[];\n  title: string;\n}\n\nfunction stableSort<T>(input: T[], prop: keyof T) {\n  const storedPositions = input.map((data, index) => ({\n    data,\n    index,\n  }));\n\n  return storedPositions\n    .sort((a, b) => {\n      if (a.data[prop] < b.data[prop]) return -1;\n      if (a.data[prop] > b.data[prop]) return 1;\n      return a.index - b.index;\n    })\n    .map((i) => i.data);\n}\n\nexport class MetadataExtractor {\n  static readonly titleSeparators = [\"-\", \"–\", \"—\", \"~\"];\n  static readonly featureSeparators = [\"featuring\", \"feat.\", \"feat\", \"ft.\", \" ft \", \"w/\", \" w /\", \" w \", \"+\"];\n  static readonly combiningFeatureSeparators = [...MetadataExtractor.featureSeparators, \", \", \" & \", \" x \"];\n  static readonly remixIndicators = [\"remix\", \"flip\", \"bootleg\", \"mashup\", \"edit\"];\n  static readonly producerIndicators = [\n    \"prod. by \",\n    \"prod by \",\n    \"prod. \",\n    \"p. \",\n    \"prod \",\n  ];\n  static readonly promotions = [\"free download\", \"video in description\", \"video in desc\", \"vid in desc\", \"Original Mix\"];\n\n  constructor(private title: string, private username: string, private userPermalink?: string) { }\n\n  getArtists(): Artist[] {\n    const title = this.preprocessTitle(this.title);\n\n    let artists: Artist[] = [];\n\n    const titleSplit = this.splitByTitleSeparators(title, true);\n\n    // artists before the title separator, e.g. >artist< - title\n    artists = artists.concat(\n      titleSplit.artistNames.map<Artist>((name, index) => ({\n        name,\n        type: index === 0 ? ArtistType.Main : ArtistType.Feature,\n      }))\n    );\n\n    // producers after the title separator, e.g. artist - title (prod. >artist<)\n    // we expect the producer section to be last, if not everthing fails :(\n    const producerSplit = this.splitByProducer(titleSplit.title, true);\n\n    artists = artists.concat(\n      producerSplit.artistNames.map<Artist>((name) => ({\n        name,\n        type: ArtistType.Producer,\n      }))\n    );\n\n    // remixers after the title separator, e.g. artist - title (>artist< Remix)\n    const remixSplit = this.splitByRemix(producerSplit.title, true);\n\n    artists = artists.concat(remixSplit.artists);\n\n    // get producers from braces, e.g. artist - title (producer)\n    const unsafeProducerSplit = this.splitByUnsafeProducers(remixSplit.title, true);\n\n    artists = artists.concat(\n      unsafeProducerSplit.artistNames.map<Artist>((name) => ({\n        name,\n        type: ArtistType.Producer,\n      }))\n    );\n\n    // features after the title separator, e.g. artist - title (ft. >artist<)\n    const featureSplit = this.splitByFeatures(remixSplit.title, true);\n\n    artists = artists.concat(\n      featureSplit.artistNames.map<Artist>((name) => ({\n        name,\n        type: ArtistType.Feature,\n      }))\n    );\n\n    const hasMainArtist = artists.some((i) => i.type === ArtistType.Main);\n\n    if (!hasMainArtist) {\n      const user = {\n        name: this.sanitizeArtistName(this.username) || this.userPermalink,\n        type: ArtistType.Main,\n      };\n\n      if (user.name) {\n        if (artists.length > 0) {\n          artists = [user, ...artists];\n        } else {\n          artists.push(user);\n        }\n      }\n    }\n\n    artists = artists.map((artist) => this.removeTwitterHandle(artist));\n\n    const distinctArtists: Artist[] = [];\n\n    // Only distinct artists\n    for (const artist of artists) {\n      if (distinctArtists.some((i) => i.name == artist.name)) continue;\n\n      distinctArtists.push(artist);\n    }\n\n    // sort by importance\n    return stableSort(distinctArtists, \"type\");\n  }\n\n  getTitle(): string {\n    let title = this.preprocessTitle(this.title);\n\n    title = this.splitByTitleSeparators(title, false).title;\n\n    title = this.splitByProducer(title, false).title;\n\n    title = this.splitByRemix(title, false).title;\n\n    title = this.splitByFeatures(title, false).title;\n\n    title = this.splitByUnsafeProducers(title, false).title;\n\n    return this.sanitizeTitle(title);\n  }\n\n  private removeTwitterHandle(artist: Artist) {\n    artist.name = artist.name.replace(/^[@]+/, \"\");\n\n    const result = /^([^(]+)\\s?\\(\\s?@.+\\)?$/.exec(artist.name);\n\n    if (result && result.length > 1) {\n      artist.name = result[1].trimEnd();\n    }\n\n    return artist;\n  }\n\n  private splitByTitleSeparators(title: string, extractArtists: boolean): TitleSplit {\n    let artistNames: string[] = [];\n\n    if (this.includes(title, MetadataExtractor.titleSeparators)) {\n      const separators = this.escapeRegexArray(MetadataExtractor.titleSeparators);\n      const regex = new RegExp(`^((.+)\\\\s[${separators}]\\\\s)(.+)$`);\n\n      const result = regex.exec(title);\n\n      if (result && result.length > 0) {\n        const [_, artistSection, artistString] = result;\n\n        if (extractArtists) {\n          artistNames = this.getArtistNames(artistString);\n        }\n\n        title = title.replace(artistSection, \"\");\n      }\n    }\n\n    return {\n      artistNames,\n      title,\n    };\n  }\n\n  private splitByFeatures(title: string, extractArtists: boolean): TitleSplit {\n    let artistNames: string[] = [];\n\n    if (this.includes(title, MetadataExtractor.featureSeparators)) {\n      const separators = this.escapeRegexArray(MetadataExtractor.featureSeparators).join(\"|\");\n      const regex = new RegExp(`(?:${separators})([^\\\\[\\\\]\\\\(\\\\)]+)`, \"i\");\n\n      const result = regex.exec(title);\n\n      if (result && result.length > 0) {\n        const [featureSection, artistsString] = result;\n\n        if (extractArtists) {\n          artistNames = this.getArtistNames(artistsString);\n        }\n\n        title = title.replace(featureSection, \"\");\n      }\n    }\n\n    return {\n      artistNames,\n      title,\n    };\n  }\n\n  private splitByProducer(title: string, extractArtists: boolean): TitleSplit {\n    let artistNames: string[] = [];\n\n    if (this.includes(title, MetadataExtractor.producerIndicators)) {\n      const separators = this.escapeRegexArray(MetadataExtractor.producerIndicators).join(\"|\");\n      const regex = new RegExp(`(?:${separators})([^\\\\[\\\\]\\\\(\\\\)]+)`, \"i\");\n\n      const result = regex.exec(title);\n\n      if (result && result.length > 0) {\n        const [producerSection, artistsString] = result;\n\n        if (extractArtists) {\n          artistNames = this.getArtistNames(artistsString);\n        }\n\n        title = title.replace(producerSection, \"\");\n      }\n    }\n\n    return {\n      artistNames,\n      title,\n    };\n  }\n\n  private splitByUnsafeProducers(title: string, extractArtists: boolean): TitleSplit {\n    let artistNames: string[] = [];\n\n    const featureSeparators = this.escapeRegexArray(MetadataExtractor.featureSeparators).join(\"|\");\n    const regex = new RegExp(`[\\\\(\\\\[](?!${featureSeparators})(.+)[\\\\)\\\\]]`, \"i\");\n\n    const result = regex.exec(title);\n\n    if (result && result.length > 0) {\n      const [producerSection, artistsString] = result;\n\n      if (extractArtists) {\n        artistNames = this.getArtistNames(artistsString);\n      }\n\n      title = title.replace(producerSection, \"\");\n    }\n    return {\n      artistNames,\n      title,\n    };\n  }\n\n  private splitByRemix(title: string, extractArtists: boolean): RemixTitleSplit {\n    let artists: Artist[] = [];\n\n    if (this.includes(title, MetadataExtractor.remixIndicators)) {\n      const separators = this.escapeRegexArray(MetadataExtractor.remixIndicators).join(\"|\");\n      const regex = new RegExp(`[\\\\[\\\\(](.+)(${separators})[\\\\]\\\\)]`, \"i\");\n\n      const result = regex.exec(title);\n\n      if (result && result.length > 0) {\n        const [remixSection, artistsString, remixTypeString] = result;\n\n        if (extractArtists) {\n          const artistNames = this.getArtistNames(artistsString);\n\n          const remixType = getRemixTypeFromString(remixTypeString);\n\n          artists = artistNames.map<Artist>((name) => ({\n            name,\n            type: ArtistType.Remixer,\n            remixType,\n          }));\n        }\n\n        title = title.replace(remixSection, \"\");\n      }\n    }\n\n    return {\n      artists,\n      title,\n    };\n  }\n\n  private getArtistNames(input: string): string[] {\n    const separators = this.escapeRegexArray(MetadataExtractor.combiningFeatureSeparators).join(\"|\");\n    const regex = new RegExp(`(.+)\\\\s?(${separators})\\\\s?(.+)`, \"i\");\n\n    const names = [];\n\n    while (true) {\n      const result = regex.exec(input);\n\n      if (!result) {\n        names.push(this.sanitizeArtistName(input));\n        break;\n      }\n\n      names.push(this.sanitizeArtistName(result[3]));\n      input = result[1];\n    }\n\n    return names.reverse();\n  }\n\n  private preprocessTitle(input: string) {\n    // remove duplicated +s\n    input = input.replace(/\\+([+]+)/g, \"+\");\n\n    // remove promotions\n    const promotions = MetadataExtractor.promotions.join(\"|\");\n    const regex = new RegExp(`[\\\\[\\\\(]?\\\\s*(${promotions})\\\\s*[\\\\]\\\\)]?`, \"i\");\n\n    return input.replace(regex, \"\");\n  }\n\n  private sanitizeArtistName(input: string) {\n    return this.removeNonAsciiCharacters(input).trim();\n  }\n\n  private sanitizeTitle(input: string) {\n    let sanitized = this.removeNonAsciiCharacters(input);\n\n    sanitized = sanitized.replace(\"()\", \"\").replace(\"[]\", \"\");\n\n    return sanitized.trim();\n  }\n\n  private removeNonAsciiCharacters(input: string) {\n    return XRegExp.replace(input, XRegExp(\"[^\\\\p{L}\\\\p{N}\\\\p{Zs}\\x00-\\x7F]\", \"g\"), \"\");\n  }\n\n  private includes(input: string, separators: string[]) {\n    const loweredInput = input.toLowerCase();\n\n    return separators.some((separator) => loweredInput.includes(separator));\n  }\n\n  private escapeRegexArray(input: string[]) {\n    return input.map((i) => escapeStringRegexp(i));\n  }\n}\n","/**\n * @file stream.js\n */\n\n/**\n * A lightweight readable stream implemention that handles event dispatching.\n *\n * @class Stream\n */\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\n   * Add a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener the callback to be invoked when an event of\n   * the specified type occurs\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\n   * Remove a listener for a specified event type.\n   *\n   * @param {string} type the event name\n   * @param {Function} listener  a function previously registered for this\n   * type of event through `on`\n   * @return {boolean} if we could turn it off or not\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n    // In Video.js we slice listener functions\n    // on trigger so that it does not mess up the order\n    // while we loop through.\n    //\n    // Here we slice on off so that the loop in trigger\n    // can continue using it's old reference to loop without\n    // messing up the order.\n\n    this.listeners[type] = this.listeners[type].slice(0);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\n   * Trigger an event of the specified type on this stream. Any additional\n   * arguments to this function are passed as parameters to event listeners.\n   *\n   * @param {string} type the event name\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  }\n  /**\n   * Destroys the stream and cleans up.\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   *\n   * @param {Stream} destination the stream that will receive all `data` events\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\nexport { Stream as default };","function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };","var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","import window from 'global/window';\n\nvar atob = function atob(s) {\n  return window.atob ? window.atob(s) : Buffer.from(s, 'base64').toString('binary');\n};\n\nexport default function decodeB64ToUint8Array(b64Text) {\n  var decodedString = atob(b64Text);\n  var array = new Uint8Array(decodedString.length);\n\n  for (var i = 0; i < decodedString.length; i++) {\n    array[i] = decodedString.charCodeAt(i);\n  }\n\n  return array;\n}","/*! @name m3u8-parser @version 7.2.0 @license Apache-2.0 */\nimport Stream from '@videojs/vhs-utils/es/stream.js';\nimport _extends from '@babel/runtime/helpers/extends';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array.js';\n\n/**\n * @file m3u8/line-stream.js\n */\n/**\n * A stream that buffers string input and generates a `data` event for each\n * line.\n *\n * @class LineStream\n * @extends Stream\n */\n\nclass LineStream extends Stream {\n  constructor() {\n    super();\n    this.buffer = '';\n  }\n  /**\n   * Add new data to be parsed.\n   *\n   * @param {string} data the text to process\n   */\n\n\n  push(data) {\n    let nextNewline;\n    this.buffer += data;\n    nextNewline = this.buffer.indexOf('\\n');\n\n    for (; nextNewline > -1; nextNewline = this.buffer.indexOf('\\n')) {\n      this.trigger('data', this.buffer.substring(0, nextNewline));\n      this.buffer = this.buffer.substring(nextNewline + 1);\n    }\n  }\n\n}\n\nconst TAB = String.fromCharCode(0x09);\n\nconst parseByterange = function (byterangeString) {\n  // optionally match and capture 0+ digits before `@`\n  // optionally match and capture 0+ digits after `@`\n  const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || '');\n  const result = {};\n\n  if (match[1]) {\n    result.length = parseInt(match[1], 10);\n  }\n\n  if (match[2]) {\n    result.offset = parseInt(match[2], 10);\n  }\n\n  return result;\n};\n/**\n * \"forgiving\" attribute list psuedo-grammar:\n * attributes -> keyvalue (',' keyvalue)*\n * keyvalue   -> key '=' value\n * key        -> [^=]*\n * value      -> '\"' [^\"]* '\"' | [^,]*\n */\n\n\nconst attributeSeparator = function () {\n  const key = '[^=]*';\n  const value = '\"[^\"]*\"|[^,]*';\n  const keyvalue = '(?:' + key + ')=(?:' + value + ')';\n  return new RegExp('(?:^|,)(' + keyvalue + ')');\n};\n/**\n * Parse attributes from a line given the separator\n *\n * @param {string} attributes the attribute line to parse\n */\n\n\nconst parseAttributes = function (attributes) {\n  const result = {};\n\n  if (!attributes) {\n    return result;\n  } // split the string using attributes as the separator\n\n\n  const attrs = attributes.split(attributeSeparator());\n  let i = attrs.length;\n  let attr;\n\n  while (i--) {\n    // filter out unmatched portions of the string\n    if (attrs[i] === '') {\n      continue;\n    } // split the key and value\n\n\n    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1); // trim whitespace and remove optional quotes around the value\n\n    attr[0] = attr[0].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^\\s+|\\s+$/g, '');\n    attr[1] = attr[1].replace(/^['\"](.*)['\"]$/g, '$1');\n    result[attr[0]] = attr[1];\n  }\n\n  return result;\n};\n/**\n * Converts a string into a resolution object\n *\n * @param {string} resolution a string such as 3840x2160\n *\n * @return {Object} An object representing the resolution\n *\n */\n\n\nconst parseResolution = resolution => {\n  const split = resolution.split('x');\n  const result = {};\n\n  if (split[0]) {\n    result.width = parseInt(split[0], 10);\n  }\n\n  if (split[1]) {\n    result.height = parseInt(split[1], 10);\n  }\n\n  return result;\n};\n/**\n * A line-level M3U8 parser event stream. It expects to receive input one\n * line at a time and performs a context-free parse of its contents. A stream\n * interpretation of a manifest can be useful if the manifest is expected to\n * be too large to fit comfortably into memory or the entirety of the input\n * is not immediately available. Otherwise, it's probably much easier to work\n * with a regular `Parser` object.\n *\n * Produces `data` events with an object that captures the parser's\n * interpretation of the input. That object has a property `tag` that is one\n * of `uri`, `comment`, or `tag`. URIs only have a single additional\n * property, `line`, which captures the entirety of the input without\n * interpretation. Comments similarly have a single additional property\n * `text` which is the input without the leading `#`.\n *\n * Tags always have a property `tagType` which is the lower-cased version of\n * the M3U8 directive without the `#EXT` or `#EXT-X-` prefix. For instance,\n * `#EXT-X-MEDIA-SEQUENCE` becomes `media-sequence` when parsed. Unrecognized\n * tags are given the tag type `unknown` and a single additional property\n * `data` with the remainder of the input.\n *\n * @class ParseStream\n * @extends Stream\n */\n\n\nclass ParseStream extends Stream {\n  constructor() {\n    super();\n    this.customParsers = [];\n    this.tagMappers = [];\n  }\n  /**\n   * Parses an additional line of input.\n   *\n   * @param {string} line a single line of an M3U8 file to parse\n   */\n\n\n  push(line) {\n    let match;\n    let event; // strip whitespace\n\n    line = line.trim();\n\n    if (line.length === 0) {\n      // ignore empty lines\n      return;\n    } // URIs\n\n\n    if (line[0] !== '#') {\n      this.trigger('data', {\n        type: 'uri',\n        uri: line\n      });\n      return;\n    } // map tags\n\n\n    const newLines = this.tagMappers.reduce((acc, mapper) => {\n      const mappedLine = mapper(line); // skip if unchanged\n\n      if (mappedLine === line) {\n        return acc;\n      }\n\n      return acc.concat([mappedLine]);\n    }, [line]);\n    newLines.forEach(newLine => {\n      for (let i = 0; i < this.customParsers.length; i++) {\n        if (this.customParsers[i].call(this, newLine)) {\n          return;\n        }\n      } // Comments\n\n\n      if (newLine.indexOf('#EXT') !== 0) {\n        this.trigger('data', {\n          type: 'comment',\n          text: newLine.slice(1)\n        });\n        return;\n      } // strip off any carriage returns here so the regex matching\n      // doesn't have to account for them.\n\n\n      newLine = newLine.replace('\\r', ''); // Tags\n\n      match = /^#EXTM3U/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'm3u'\n        });\n        return;\n      }\n\n      match = /^#EXTINF:([0-9\\.]*)?,?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'inf'\n        };\n\n        if (match[1]) {\n          event.duration = parseFloat(match[1]);\n        }\n\n        if (match[2]) {\n          event.title = match[2];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'targetduration'\n        };\n\n        if (match[1]) {\n          event.duration = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'version'\n        };\n\n        if (match[1]) {\n          event.version = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\\-?[0-9.]*)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'discontinuity-sequence'\n        };\n\n        if (match[1]) {\n          event.number = parseInt(match[1], 10);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'playlist-type'\n        };\n\n        if (match[1]) {\n          event.playlistType = match[1];\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = _extends(parseByterange(match[1]), {\n          type: 'tag',\n          tagType: 'byterange'\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'allow-cache'\n        };\n\n        if (match[1]) {\n          event.allowed = !/NO/.test(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MAP:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'map'\n        };\n\n        if (match[1]) {\n          const attributes = parseAttributes(match[1]);\n\n          if (attributes.URI) {\n            event.uri = attributes.URI;\n          }\n\n          if (attributes.BYTERANGE) {\n            event.byterange = parseByterange(attributes.BYTERANGE);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'stream-inf'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n\n          if (event.attributes.RESOLUTION) {\n            event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n          }\n\n          if (event.attributes.BANDWIDTH) {\n            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n          }\n\n          if (event.attributes['FRAME-RATE']) {\n            event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n          }\n\n          if (event.attributes['PROGRAM-ID']) {\n            event.attributes['PROGRAM-ID'] = parseInt(event.attributes['PROGRAM-ID'], 10);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'media'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-ENDLIST/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'endlist'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-DISCONTINUITY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'discontinuity'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'program-date-time'\n        };\n\n        if (match[1]) {\n          event.dateTimeString = match[1];\n          event.dateTimeObject = new Date(match[1]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-KEY:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'key'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]); // parse the IV string into a Uint32Array\n\n          if (event.attributes.IV) {\n            if (event.attributes.IV.substring(0, 2).toLowerCase() === '0x') {\n              event.attributes.IV = event.attributes.IV.substring(2);\n            }\n\n            event.attributes.IV = event.attributes.IV.match(/.{8}/g);\n            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);\n            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);\n            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);\n            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);\n            event.attributes.IV = new Uint32Array(event.attributes.IV);\n          }\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-START:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'start'\n        };\n\n        if (match[1]) {\n          event.attributes = parseAttributes(match[1]);\n          event.attributes['TIME-OFFSET'] = parseFloat(event.attributes['TIME-OFFSET']);\n          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out-cont'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-out'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'cue-in'\n        };\n\n        if (match[1]) {\n          event.data = match[1];\n        } else {\n          event.data = '';\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'skip'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.hasOwnProperty('SKIPPED-SEGMENTS')) {\n          event.attributes['SKIPPED-SEGMENTS'] = parseInt(event.attributes['SKIPPED-SEGMENTS'], 10);\n        }\n\n        if (event.attributes.hasOwnProperty('RECENTLY-REMOVED-DATERANGES')) {\n          event.attributes['RECENTLY-REMOVED-DATERANGES'] = event.attributes['RECENTLY-REMOVED-DATERANGES'].split(TAB);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['INDEPENDENT', 'GAP'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n\n        if (event.attributes.hasOwnProperty('BYTERANGE')) {\n          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'server-control'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['CAN-SKIP-UNTIL', 'PART-HOLD-BACK', 'HOLD-BACK'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['CAN-SKIP-DATERANGES', 'CAN-BLOCK-RELOAD'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/.test(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'part-inf'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['PART-TARGET'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'preload-hint'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['BYTERANGE-START', 'BYTERANGE-LENGTH'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n            const subkey = key === 'BYTERANGE-LENGTH' ? 'length' : 'offset';\n            event.attributes.byterange = event.attributes.byterange || {};\n            event.attributes.byterange[subkey] = event.attributes[key]; // only keep the parsed byterange object.\n\n            delete event.attributes[key];\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'rendition-report'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['LAST-MSN', 'LAST-PART'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseInt(event.attributes[key], 10);\n          }\n        });\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);\n\n      if (match && match[1]) {\n        event = {\n          type: 'tag',\n          tagType: 'daterange'\n        };\n        event.attributes = parseAttributes(match[1]);\n        ['ID', 'CLASS'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = String(event.attributes[key]);\n          }\n        });\n        ['START-DATE', 'END-DATE'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = new Date(event.attributes[key]);\n          }\n        });\n        ['DURATION', 'PLANNED-DURATION'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = parseFloat(event.attributes[key]);\n          }\n        });\n        ['END-ON-NEXT'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = /YES/i.test(event.attributes[key]);\n          }\n        });\n        ['SCTE35-CMD', ' SCTE35-OUT', 'SCTE35-IN'].forEach(function (key) {\n          if (event.attributes.hasOwnProperty(key)) {\n            event.attributes[key] = event.attributes[key].toString(16);\n          }\n        });\n        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;\n\n        for (const key in event.attributes) {\n          if (!clientAttributePattern.test(key)) {\n            continue;\n          }\n\n          const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);\n          const isDecimalFloating = /^\\d+(\\.\\d+)?$/.test(event.attributes[key]);\n          event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'independent-segments'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-I-FRAMES-ONLY/.exec(newLine);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'tag',\n          tagType: 'i-frames-only'\n        });\n        return;\n      }\n\n      match = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'content-steering'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-I-FRAME-STREAM-INF:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'i-frame-playlist'\n        };\n        event.attributes = parseAttributes(match[1]);\n\n        if (event.attributes.URI) {\n          event.uri = event.attributes.URI;\n        }\n\n        if (event.attributes.BANDWIDTH) {\n          event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);\n        }\n\n        if (event.attributes.RESOLUTION) {\n          event.attributes.RESOLUTION = parseResolution(event.attributes.RESOLUTION);\n        }\n\n        if (event.attributes['AVERAGE-BANDWIDTH']) {\n          event.attributes['AVERAGE-BANDWIDTH'] = parseInt(event.attributes['AVERAGE-BANDWIDTH'], 10);\n        }\n\n        if (event.attributes['FRAME-RATE']) {\n          event.attributes['FRAME-RATE'] = parseFloat(event.attributes['FRAME-RATE']);\n        }\n\n        this.trigger('data', event);\n        return;\n      }\n\n      match = /^#EXT-X-DEFINE:(.*)$/.exec(newLine);\n\n      if (match) {\n        event = {\n          type: 'tag',\n          tagType: 'define'\n        };\n        event.attributes = parseAttributes(match[1]);\n        this.trigger('data', event);\n        return;\n      } // unknown tag type\n\n\n      this.trigger('data', {\n        type: 'tag',\n        data: newLine.slice(4)\n      });\n    });\n  }\n  /**\n   * Add a parser for custom headers\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser({\n    expression,\n    customType,\n    dataParser,\n    segment\n  }) {\n    if (typeof dataParser !== 'function') {\n      dataParser = line => line;\n    }\n\n    this.customParsers.push(line => {\n      const match = expression.exec(line);\n\n      if (match) {\n        this.trigger('data', {\n          type: 'custom',\n          data: dataParser(line),\n          customType,\n          segment\n        });\n        return true;\n      }\n    });\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper({\n    expression,\n    map\n  }) {\n    const mapFn = line => {\n      if (expression.test(line)) {\n        return map(line);\n      }\n\n      return line;\n    };\n\n    this.tagMappers.push(mapFn);\n  }\n\n}\n\nconst camelCase = str => str.toLowerCase().replace(/-(\\w)/g, a => a[1].toUpperCase());\n\nconst camelCaseKeys = function (attributes) {\n  const result = {};\n  Object.keys(attributes).forEach(function (key) {\n    result[camelCase(key)] = attributes[key];\n  });\n  return result;\n}; // set SERVER-CONTROL hold back based upon targetDuration and partTargetDuration\n// we need this helper because defaults are based upon targetDuration and\n// partTargetDuration being set, but they may not be if SERVER-CONTROL appears before\n// target durations are set.\n\n\nconst setHoldBack = function (manifest) {\n  const {\n    serverControl,\n    targetDuration,\n    partTargetDuration\n  } = manifest;\n\n  if (!serverControl) {\n    return;\n  }\n\n  const tag = '#EXT-X-SERVER-CONTROL';\n  const hb = 'holdBack';\n  const phb = 'partHoldBack';\n  const minTargetDuration = targetDuration && targetDuration * 3;\n  const minPartDuration = partTargetDuration && partTargetDuration * 2;\n\n  if (targetDuration && !serverControl.hasOwnProperty(hb)) {\n    serverControl[hb] = minTargetDuration;\n    this.trigger('info', {\n      message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`\n    });\n  }\n\n  if (minTargetDuration && serverControl[hb] < minTargetDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`\n    });\n    serverControl[hb] = minTargetDuration;\n  } // default no part hold back to part target duration * 3\n\n\n  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {\n    serverControl[phb] = partTargetDuration * 3;\n    this.trigger('info', {\n      message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`\n    });\n  } // if part hold back is too small default it to part target duration * 2\n\n\n  if (partTargetDuration && serverControl[phb] < minPartDuration) {\n    this.trigger('warn', {\n      message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`\n    });\n    serverControl[phb] = minPartDuration;\n  }\n};\n/**\n * A parser for M3U8 files. The current interpretation of the input is\n * exposed as a property `manifest` on parser objects. It's just two lines to\n * create and parse a manifest once you have the contents available as a string:\n *\n * ```js\n * var parser = new m3u8.Parser();\n * parser.push(xhr.responseText);\n * ```\n *\n * New input can later be applied to update the manifest object by calling\n * `push` again.\n *\n * The parser attempts to create a usable manifest object even if the\n * underlying input is somewhat nonsensical. It emits `info` and `warning`\n * events during the parse if it encounters input that seems invalid or\n * requires some property of the manifest object to be defaulted.\n *\n * @class Parser\n * @param {Object} [opts] Options for the constructor, needed for substitutions\n * @param {string} [opts.uri] URL to check for query params\n * @param {Object} [opts.mainDefinitions] Definitions on main playlist that can be imported\n * @extends Stream\n */\n\n\nclass Parser extends Stream {\n  constructor(opts = {}) {\n    super();\n    this.lineStream = new LineStream();\n    this.parseStream = new ParseStream();\n    this.lineStream.pipe(this.parseStream);\n    this.mainDefinitions = opts.mainDefinitions || {};\n    this.params = new URL(opts.uri, 'https://a.com').searchParams;\n    this.lastProgramDateTime = null;\n    /* eslint-disable consistent-this */\n\n    const self = this;\n    /* eslint-enable consistent-this */\n\n    const uris = [];\n    let currentUri = {}; // if specified, the active EXT-X-MAP definition\n\n    let currentMap; // if specified, the active decryption key\n\n    let key;\n    let hasParts = false;\n\n    const noop = function () {};\n\n    const defaultMediaGroups = {\n      'AUDIO': {},\n      'VIDEO': {},\n      'CLOSED-CAPTIONS': {},\n      'SUBTITLES': {}\n    }; // This is the Widevine UUID from DASH IF IOP. The same exact string is\n    // used in MPDs with Widevine encrypted streams.\n\n    const widevineUuid = 'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'; // group segments into numbered timelines delineated by discontinuities\n\n    let currentTimeline = 0; // the manifest is empty until the parse stream begins delivering data\n\n    this.manifest = {\n      allowCache: true,\n      discontinuityStarts: [],\n      dateRanges: [],\n      iFramePlaylists: [],\n      segments: []\n    }; // keep track of the last seen segment's byte range end, as segments are not required\n    // to provide the offset, in which case it defaults to the next byte after the\n    // previous segment\n\n    let lastByterangeEnd = 0; // keep track of the last seen part's byte range end.\n\n    let lastPartByterangeEnd = 0;\n    const dateRangeTags = {};\n    this.on('end', () => {\n      // only add preloadSegment if we don't yet have a uri for it.\n      // and we actually have parts/preloadHints\n      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {\n        return;\n      }\n\n      if (!currentUri.map && currentMap) {\n        currentUri.map = currentMap;\n      }\n\n      if (!currentUri.key && key) {\n        currentUri.key = key;\n      }\n\n      if (!currentUri.timeline && typeof currentTimeline === 'number') {\n        currentUri.timeline = currentTimeline;\n      }\n\n      this.manifest.preloadSegment = currentUri;\n    }); // update the manifest with the m3u8 entry from the parse stream\n\n    this.parseStream.on('data', function (entry) {\n      let mediaGroup;\n      let rendition; // Replace variables in uris and attributes as defined in #EXT-X-DEFINE tags\n\n      if (self.manifest.definitions) {\n        for (const def in self.manifest.definitions) {\n          if (entry.uri) {\n            entry.uri = entry.uri.replace(`{$${def}}`, self.manifest.definitions[def]);\n          }\n\n          if (entry.attributes) {\n            for (const attr in entry.attributes) {\n              if (typeof entry.attributes[attr] === 'string') {\n                entry.attributes[attr] = entry.attributes[attr].replace(`{$${def}}`, self.manifest.definitions[def]);\n              }\n            }\n          }\n        }\n      }\n\n      ({\n        tag() {\n          // switch based on the tag type\n          (({\n            version() {\n              if (entry.version) {\n                this.manifest.version = entry.version;\n              }\n            },\n\n            'allow-cache'() {\n              this.manifest.allowCache = entry.allowed;\n\n              if (!('allowed' in entry)) {\n                this.trigger('info', {\n                  message: 'defaulting allowCache to YES'\n                });\n                this.manifest.allowCache = true;\n              }\n            },\n\n            byterange() {\n              const byterange = {};\n\n              if ('length' in entry) {\n                currentUri.byterange = byterange;\n                byterange.length = entry.length;\n\n                if (!('offset' in entry)) {\n                  /*\n                   * From the latest spec (as of this writing):\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.2\n                   *\n                   * Same text since EXT-X-BYTERANGE's introduction in draft 7:\n                   * https://tools.ietf.org/html/draft-pantos-http-live-streaming-07#section-3.3.1)\n                   *\n                   * \"If o [offset] is not present, the sub-range begins at the next byte\n                   * following the sub-range of the previous media segment.\"\n                   */\n                  entry.offset = lastByterangeEnd;\n                }\n              }\n\n              if ('offset' in entry) {\n                currentUri.byterange = byterange;\n                byterange.offset = entry.offset;\n              }\n\n              lastByterangeEnd = byterange.offset + byterange.length;\n            },\n\n            endlist() {\n              this.manifest.endList = true;\n            },\n\n            inf() {\n              if (!('mediaSequence' in this.manifest)) {\n                this.manifest.mediaSequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting media sequence to zero'\n                });\n              }\n\n              if (!('discontinuitySequence' in this.manifest)) {\n                this.manifest.discontinuitySequence = 0;\n                this.trigger('info', {\n                  message: 'defaulting discontinuity sequence to zero'\n                });\n              }\n\n              if (entry.title) {\n                currentUri.title = entry.title;\n              }\n\n              if (entry.duration > 0) {\n                currentUri.duration = entry.duration;\n              }\n\n              if (entry.duration === 0) {\n                currentUri.duration = 0.01;\n                this.trigger('info', {\n                  message: 'updating zero segment duration to a small value'\n                });\n              }\n\n              this.manifest.segments = uris;\n            },\n\n            key() {\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without attribute list'\n                });\n                return;\n              } // clear the active encryption key\n\n\n              if (entry.attributes.METHOD === 'NONE') {\n                key = null;\n                return;\n              }\n\n              if (!entry.attributes.URI) {\n                this.trigger('warn', {\n                  message: 'ignoring key declaration without URI'\n                });\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.apple.streamingkeydelivery') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.apple.fps.1_0'] = {\n                  attributes: entry.attributes\n                };\n                return;\n              }\n\n              if (entry.attributes.KEYFORMAT === 'com.microsoft.playready') {\n                this.manifest.contentProtection = this.manifest.contentProtection || {}; // TODO: add full support for this.\n\n                this.manifest.contentProtection['com.microsoft.playready'] = {\n                  uri: entry.attributes.URI\n                };\n                return;\n              } // check if the content is encrypted for Widevine\n              // Widevine/HLS spec: https://storage.googleapis.com/wvdocs/Widevine_DRM_HLS.pdf\n\n\n              if (entry.attributes.KEYFORMAT === widevineUuid) {\n                const VALID_METHODS = ['SAMPLE-AES', 'SAMPLE-AES-CTR', 'SAMPLE-AES-CENC'];\n\n                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {\n                  this.trigger('warn', {\n                    message: 'invalid key method provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (entry.attributes.METHOD === 'SAMPLE-AES-CENC') {\n                  this.trigger('warn', {\n                    message: 'SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead'\n                  });\n                }\n\n                if (entry.attributes.URI.substring(0, 23) !== 'data:text/plain;base64,') {\n                  this.trigger('warn', {\n                    message: 'invalid key URI provided for Widevine'\n                  });\n                  return;\n                }\n\n                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === '0x')) {\n                  this.trigger('warn', {\n                    message: 'invalid key ID provided for Widevine'\n                  });\n                  return;\n                } // if Widevine key attributes are valid, store them as `contentProtection`\n                // on the manifest to emulate Widevine tag structure in a DASH mpd\n\n\n                this.manifest.contentProtection = this.manifest.contentProtection || {};\n                this.manifest.contentProtection['com.widevine.alpha'] = {\n                  attributes: {\n                    schemeIdUri: entry.attributes.KEYFORMAT,\n                    // remove '0x' from the key id string\n                    keyId: entry.attributes.KEYID.substring(2)\n                  },\n                  // decode the base64-encoded PSSH box\n                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(',')[1])\n                };\n                return;\n              }\n\n              if (!entry.attributes.METHOD) {\n                this.trigger('warn', {\n                  message: 'defaulting key method to AES-128'\n                });\n              } // setup an encryption key for upcoming segments\n\n\n              key = {\n                method: entry.attributes.METHOD || 'AES-128',\n                uri: entry.attributes.URI\n              };\n\n              if (typeof entry.attributes.IV !== 'undefined') {\n                key.iv = entry.attributes.IV;\n              }\n            },\n\n            'media-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid media sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.mediaSequence = entry.number;\n            },\n\n            'discontinuity-sequence'() {\n              if (!isFinite(entry.number)) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid discontinuity sequence: ' + entry.number\n                });\n                return;\n              }\n\n              this.manifest.discontinuitySequence = entry.number;\n              currentTimeline = entry.number;\n            },\n\n            'playlist-type'() {\n              if (!/VOD|EVENT/.test(entry.playlistType)) {\n                this.trigger('warn', {\n                  message: 'ignoring unknown playlist type: ' + entry.playlist\n                });\n                return;\n              }\n\n              this.manifest.playlistType = entry.playlistType;\n            },\n\n            map() {\n              currentMap = {};\n\n              if (entry.uri) {\n                currentMap.uri = entry.uri;\n              }\n\n              if (entry.byterange) {\n                currentMap.byterange = entry.byterange;\n              }\n\n              if (key) {\n                currentMap.key = key;\n              }\n            },\n\n            'stream-inf'() {\n              this.manifest.playlists = uris;\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!entry.attributes) {\n                this.trigger('warn', {\n                  message: 'ignoring empty stream-inf attributes'\n                });\n                return;\n              }\n\n              if (!currentUri.attributes) {\n                currentUri.attributes = {};\n              }\n\n              _extends(currentUri.attributes, entry.attributes);\n            },\n\n            media() {\n              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;\n\n              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes['GROUP-ID'] && entry.attributes.NAME)) {\n                this.trigger('warn', {\n                  message: 'ignoring incomplete or missing media group'\n                });\n                return;\n              } // find the media group, creating defaults as necessary\n\n\n              const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];\n              mediaGroupType[entry.attributes['GROUP-ID']] = mediaGroupType[entry.attributes['GROUP-ID']] || {};\n              mediaGroup = mediaGroupType[entry.attributes['GROUP-ID']]; // collect the rendition metadata\n\n              rendition = {\n                default: /yes/i.test(entry.attributes.DEFAULT)\n              };\n\n              if (rendition.default) {\n                rendition.autoselect = true;\n              } else {\n                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);\n              }\n\n              if (entry.attributes.LANGUAGE) {\n                rendition.language = entry.attributes.LANGUAGE;\n              }\n\n              if (entry.attributes.URI) {\n                rendition.uri = entry.attributes.URI;\n              }\n\n              if (entry.attributes['INSTREAM-ID']) {\n                rendition.instreamId = entry.attributes['INSTREAM-ID'];\n              }\n\n              if (entry.attributes.CHARACTERISTICS) {\n                rendition.characteristics = entry.attributes.CHARACTERISTICS;\n              }\n\n              if (entry.attributes.FORCED) {\n                rendition.forced = /yes/i.test(entry.attributes.FORCED);\n              } // insert the new rendition\n\n\n              mediaGroup[entry.attributes.NAME] = rendition;\n            },\n\n            discontinuity() {\n              currentTimeline += 1;\n              currentUri.discontinuity = true;\n              this.manifest.discontinuityStarts.push(uris.length);\n            },\n\n            'program-date-time'() {\n              if (typeof this.manifest.dateTimeString === 'undefined') {\n                // PROGRAM-DATE-TIME is a media-segment tag, but for backwards\n                // compatibility, we add the first occurence of the PROGRAM-DATE-TIME tag\n                // to the manifest object\n                // TODO: Consider removing this in future major version\n                this.manifest.dateTimeString = entry.dateTimeString;\n                this.manifest.dateTimeObject = entry.dateTimeObject;\n              }\n\n              currentUri.dateTimeString = entry.dateTimeString;\n              currentUri.dateTimeObject = entry.dateTimeObject;\n              const {\n                lastProgramDateTime\n              } = this;\n              this.lastProgramDateTime = new Date(entry.dateTimeString).getTime(); // We should extrapolate Program Date Time backward only during first program date time occurrence.\n              // Once we have at least one program date time point, we can always extrapolate it forward using lastProgramDateTime reference.\n\n              if (lastProgramDateTime === null) {\n                // Extrapolate Program Date Time backward\n                // Since it is first program date time occurrence we're assuming that\n                // all this.manifest.segments have no program date time info\n                this.manifest.segments.reduceRight((programDateTime, segment) => {\n                  segment.programDateTime = programDateTime - segment.duration * 1000;\n                  return segment.programDateTime;\n                }, this.lastProgramDateTime);\n              }\n            },\n\n            targetduration() {\n              if (!isFinite(entry.duration) || entry.duration < 0) {\n                this.trigger('warn', {\n                  message: 'ignoring invalid target duration: ' + entry.duration\n                });\n                return;\n              }\n\n              this.manifest.targetDuration = entry.duration;\n              setHoldBack.call(this, this.manifest);\n            },\n\n            start() {\n              if (!entry.attributes || isNaN(entry.attributes['TIME-OFFSET'])) {\n                this.trigger('warn', {\n                  message: 'ignoring start declaration without appropriate attribute list'\n                });\n                return;\n              }\n\n              this.manifest.start = {\n                timeOffset: entry.attributes['TIME-OFFSET'],\n                precise: entry.attributes.PRECISE\n              };\n            },\n\n            'cue-out'() {\n              currentUri.cueOut = entry.data;\n            },\n\n            'cue-out-cont'() {\n              currentUri.cueOutCont = entry.data;\n            },\n\n            'cue-in'() {\n              currentUri.cueIn = entry.data;\n            },\n\n            'skip'() {\n              this.manifest.skip = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-SKIP', entry.attributes, ['SKIPPED-SEGMENTS']);\n            },\n\n            'part'() {\n              hasParts = true; // parts are always specifed before a segment\n\n              const segmentIndex = this.manifest.segments.length;\n              const part = camelCaseKeys(entry.attributes);\n              currentUri.parts = currentUri.parts || [];\n              currentUri.parts.push(part);\n\n              if (part.byterange) {\n                if (!part.byterange.hasOwnProperty('offset')) {\n                  part.byterange.offset = lastPartByterangeEnd;\n                }\n\n                lastPartByterangeEnd = part.byterange.offset + part.byterange.length;\n              }\n\n              const partIndex = currentUri.parts.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, ['URI', 'DURATION']);\n\n              if (this.manifest.renditionReports) {\n                this.manifest.renditionReports.forEach((r, i) => {\n                  if (!r.hasOwnProperty('lastPart')) {\n                    this.trigger('warn', {\n                      message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`\n                    });\n                  }\n                });\n              }\n            },\n\n            'server-control'() {\n              const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);\n\n              if (!attrs.hasOwnProperty('canBlockReload')) {\n                attrs.canBlockReload = false;\n                this.trigger('info', {\n                  message: '#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false'\n                });\n              }\n\n              setHoldBack.call(this, this.manifest);\n\n              if (attrs.canSkipDateranges && !attrs.hasOwnProperty('canSkipUntil')) {\n                this.trigger('warn', {\n                  message: '#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set'\n                });\n              }\n            },\n\n            'preload-hint'() {\n              // parts are always specifed before a segment\n              const segmentIndex = this.manifest.segments.length;\n              const hint = camelCaseKeys(entry.attributes);\n              const isPart = hint.type && hint.type === 'PART';\n              currentUri.preloadHints = currentUri.preloadHints || [];\n              currentUri.preloadHints.push(hint);\n\n              if (hint.byterange) {\n                if (!hint.byterange.hasOwnProperty('offset')) {\n                  // use last part byterange end or zero if not a part.\n                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;\n\n                  if (isPart) {\n                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;\n                  }\n                }\n              }\n\n              const index = currentUri.preloadHints.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, ['TYPE', 'URI']);\n\n              if (!hint.type) {\n                return;\n              } // search through all preload hints except for the current one for\n              // a duplicate type.\n\n\n              for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {\n                const otherHint = currentUri.preloadHints[i];\n\n                if (!otherHint.type) {\n                  continue;\n                }\n\n                if (otherHint.type === hint.type) {\n                  this.trigger('warn', {\n                    message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`\n                  });\n                }\n              }\n            },\n\n            'rendition-report'() {\n              const report = camelCaseKeys(entry.attributes);\n              this.manifest.renditionReports = this.manifest.renditionReports || [];\n              this.manifest.renditionReports.push(report);\n              const index = this.manifest.renditionReports.length - 1;\n              const required = ['LAST-MSN', 'URI'];\n\n              if (hasParts) {\n                required.push('LAST-PART');\n              }\n\n              this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);\n            },\n\n            'part-inf'() {\n              this.manifest.partInf = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-PART-INF', entry.attributes, ['PART-TARGET']);\n\n              if (this.manifest.partInf.partTarget) {\n                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;\n              }\n\n              setHoldBack.call(this, this.manifest);\n            },\n\n            'daterange'() {\n              this.manifest.dateRanges.push(camelCaseKeys(entry.attributes));\n              const index = this.manifest.dateRanges.length - 1;\n              this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, ['ID', 'START-DATE']);\n              const dateRange = this.manifest.dateRanges[index];\n\n              if (dateRange.endDate && dateRange.startDate && new Date(dateRange.endDate) < new Date(dateRange.startDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE'\n                });\n              }\n\n              if (dateRange.duration && dateRange.duration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE DURATION must not be negative'\n                });\n              }\n\n              if (dateRange.plannedDuration && dateRange.plannedDuration < 0) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE PLANNED-DURATION must not be negative'\n                });\n              }\n\n              const endOnNextYes = !!dateRange.endOnNext;\n\n              if (endOnNextYes && !dateRange.class) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute'\n                });\n              }\n\n              if (endOnNextYes && (dateRange.duration || dateRange.endDate)) {\n                this.trigger('warn', {\n                  message: 'EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes'\n                });\n              }\n\n              if (dateRange.duration && dateRange.endDate) {\n                const startDate = dateRange.startDate;\n                const newDateInSeconds = startDate.getTime() + dateRange.duration * 1000;\n                this.manifest.dateRanges[index].endDate = new Date(newDateInSeconds);\n              }\n\n              if (!dateRangeTags[dateRange.id]) {\n                dateRangeTags[dateRange.id] = dateRange;\n              } else {\n                for (const attribute in dateRangeTags[dateRange.id]) {\n                  if (!!dateRange[attribute] && JSON.stringify(dateRangeTags[dateRange.id][attribute]) !== JSON.stringify(dateRange[attribute])) {\n                    this.trigger('warn', {\n                      message: 'EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values'\n                    });\n                    break;\n                  }\n                } // if tags with the same ID do not have conflicting attributes, merge them\n\n\n                const dateRangeWithSameId = this.manifest.dateRanges.findIndex(dateRangeToFind => dateRangeToFind.id === dateRange.id);\n                this.manifest.dateRanges[dateRangeWithSameId] = _extends(this.manifest.dateRanges[dateRangeWithSameId], dateRange);\n                dateRangeTags[dateRange.id] = _extends(dateRangeTags[dateRange.id], dateRange); // after merging, delete the duplicate dateRange that was added last\n\n                this.manifest.dateRanges.pop();\n              }\n            },\n\n            'independent-segments'() {\n              this.manifest.independentSegments = true;\n            },\n\n            'i-frames-only'() {\n              this.manifest.iFramesOnly = true;\n              this.requiredCompatibilityversion(this.manifest.version, 4);\n            },\n\n            'content-steering'() {\n              this.manifest.contentSteering = camelCaseKeys(entry.attributes);\n              this.warnOnMissingAttributes_('#EXT-X-CONTENT-STEERING', entry.attributes, ['SERVER-URI']);\n            },\n\n            /** @this {Parser} */\n            define() {\n              this.manifest.definitions = this.manifest.definitions || {};\n\n              const addDef = (n, v) => {\n                if (n in this.manifest.definitions) {\n                  // An EXT-X-DEFINE tag MUST NOT specify the same Variable Name as any other\n                  // EXT-X-DEFINE tag in the same Playlist.  Parsers that encounter duplicate\n                  // Variable Name declarations MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: Duplicate name ${n}`\n                  });\n                  return;\n                }\n\n                this.manifest.definitions[n] = v;\n              };\n\n              if ('QUERYPARAM' in entry.attributes) {\n                if ('NAME' in entry.attributes || 'IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n\n                const val = this.params.get(entry.attributes.QUERYPARAM);\n\n                if (!val) {\n                  // If the QUERYPARAM attribute value does not match any query parameter in\n                  // the URI or the matching parameter has no associated value, the parser\n                  // MUST fail to parse the Playlist.  If more than one parameter matches,\n                  // any of the associated values MAY be used.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No query param ${entry.attributes.QUERYPARAM}`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.QUERYPARAM, decodeURIComponent(val));\n                return;\n              }\n\n              if ('NAME' in entry.attributes) {\n                if ('IMPORT' in entry.attributes) {\n                  // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a\n                  // QUERYPARAM attribute, but only one of the three.  Otherwise, the\n                  // client MUST fail to parse the Playlist.\n                  this.trigger('error', {\n                    message: 'EXT-X-DEFINE: Invalid attributes'\n                  });\n                  return;\n                }\n\n                if (!('VALUE' in entry.attributes) || typeof entry.attributes.VALUE !== 'string') {\n                  // This attribute is REQUIRED if the EXT-X-DEFINE tag has a NAME attribute.\n                  // The quoted-string MAY be empty.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value for ${entry.attributes.NAME}`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.NAME, entry.attributes.VALUE);\n                return;\n              }\n\n              if ('IMPORT' in entry.attributes) {\n                if (!this.mainDefinitions[entry.attributes.IMPORT]) {\n                  // Covers two conditions, as mainDefinitions will always be empty on main\n                  //\n                  // EXT-X-DEFINE tags containing the IMPORT attribute MUST NOT occur in\n                  // Multivariant Playlists; they are only allowed in Media Playlists.\n                  //\n                  // If the IMPORT attribute value does not match any Variable Name in the\n                  // Multivariant Playlist, or if the Media Playlist loaded from a\n                  // Multivariant Playlist, the parser MUST fail the Playlist.\n                  this.trigger('error', {\n                    message: `EXT-X-DEFINE: No value ${entry.attributes.IMPORT} to import, or IMPORT used on main playlist`\n                  });\n                  return;\n                }\n\n                addDef(entry.attributes.IMPORT, this.mainDefinitions[entry.attributes.IMPORT]);\n                return;\n              } // An EXT-X-DEFINE tag MUST contain either a NAME, an IMPORT, or a QUERYPARAM\n              // attribute, but only one of the three.  Otherwise, the client MUST fail to\n              // parse the Playlist.\n\n\n              this.trigger('error', {\n                message: 'EXT-X-DEFINE: No attribute'\n              });\n            },\n\n            'i-frame-playlist'() {\n              this.manifest.iFramePlaylists.push({\n                attributes: entry.attributes,\n                uri: entry.uri,\n                timeline: currentTimeline\n              });\n              this.warnOnMissingAttributes_('#EXT-X-I-FRAME-STREAM-INF', entry.attributes, ['BANDWIDTH', 'URI']);\n            }\n\n          })[entry.tagType] || noop).call(self);\n        },\n\n        uri() {\n          currentUri.uri = entry.uri;\n          uris.push(currentUri); // if no explicit duration was declared, use the target duration\n\n          if (this.manifest.targetDuration && !('duration' in currentUri)) {\n            this.trigger('warn', {\n              message: 'defaulting segment duration to the target duration'\n            });\n            currentUri.duration = this.manifest.targetDuration;\n          } // annotate with encryption information, if necessary\n\n\n          if (key) {\n            currentUri.key = key;\n          }\n\n          currentUri.timeline = currentTimeline; // annotate with initialization segment information, if necessary\n\n          if (currentMap) {\n            currentUri.map = currentMap;\n          } // reset the last byterange end as it needs to be 0 between parts\n\n\n          lastPartByterangeEnd = 0; // Once we have at least one program date time we can always extrapolate it forward\n\n          if (this.lastProgramDateTime !== null) {\n            currentUri.programDateTime = this.lastProgramDateTime;\n            this.lastProgramDateTime += currentUri.duration * 1000;\n          } // prepare for the next URI\n\n\n          currentUri = {};\n        },\n\n        comment() {// comments are not important for playback\n        },\n\n        custom() {\n          // if this is segment-level data attach the output to the segment\n          if (entry.segment) {\n            currentUri.custom = currentUri.custom || {};\n            currentUri.custom[entry.customType] = entry.data; // if this is manifest-level data attach to the top level manifest object\n          } else {\n            this.manifest.custom = this.manifest.custom || {};\n            this.manifest.custom[entry.customType] = entry.data;\n          }\n        }\n\n      })[entry.type].call(self);\n    });\n  }\n\n  requiredCompatibilityversion(currentVersion, targetVersion) {\n    if (currentVersion < targetVersion || !currentVersion) {\n      this.trigger('warn', {\n        message: `manifest must be at least version ${targetVersion}`\n      });\n    }\n  }\n\n  warnOnMissingAttributes_(identifier, attributes, required) {\n    const missing = [];\n    required.forEach(function (key) {\n      if (!attributes.hasOwnProperty(key)) {\n        missing.push(key);\n      }\n    });\n\n    if (missing.length) {\n      this.trigger('warn', {\n        message: `${identifier} lacks required attribute(s): ${missing.join(', ')}`\n      });\n    }\n  }\n  /**\n   * Parse the input string and update the manifest object.\n   *\n   * @param {string} chunk a potentially incomplete portion of the manifest\n   */\n\n\n  push(chunk) {\n    this.lineStream.push(chunk);\n  }\n  /**\n   * Flush any remaining input. This can be handy if the last line of an M3U8\n   * manifest did not contain a trailing newline but the file has been\n   * completely received.\n   */\n\n\n  end() {\n    // flush any buffered input\n    this.lineStream.push('\\n');\n\n    if (this.manifest.dateRanges.length && this.lastProgramDateTime === null) {\n      this.trigger('warn', {\n        message: 'A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag'\n      });\n    }\n\n    this.lastProgramDateTime = null;\n    this.trigger('end');\n  }\n  /**\n   * Add an additional parser for non-standard tags\n   *\n   * @param {Object}   options              a map of options for the added parser\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {string}   options.customType   the custom type to register to the output\n   * @param {Function} [options.dataParser] function to parse the line into an object\n   * @param {boolean}  [options.segment]    should tag data be attached to the segment object\n   */\n\n\n  addParser(options) {\n    this.parseStream.addParser(options);\n  }\n  /**\n   * Add a custom header mapper\n   *\n   * @param {Object}   options\n   * @param {RegExp}   options.expression   a regular expression to match the custom header\n   * @param {Function} options.map          function to translate tag into a different tag\n   */\n\n\n  addTagMapper(options) {\n    this.parseStream.addTagMapper(options);\n  }\n\n}\n\nexport { LineStream, ParseStream, Parser };\n","import { Logger, LogLevel } from \"../utils/logger\";\nimport { getConfigValue, storeConfigValue, loadConfigValue } from \"../settings/config\";\nimport { sanitizeFilenameForDownload, concatArrayBuffers } from \"./download\";\nimport { SoundCloudApi, Track, StreamDetails } from \"../api/soundcloudApi\";\nimport { requestRemux } from \"./ffmpegManager\";\nimport { Mp3TagWriter } from \"./tagWriters/mp3TagWriter\";\nimport { Mp4TagWriter } from \"./tagWriters/mp4TagWriter\";\nimport { TagWriter } from \"./tagWriters/tagWriter\";\nimport { downloadToFile, searchDownloads } from \"../compatibility/compatibilityStubs\";\nimport { MetadataExtractor, ArtistType, RemixType } from \"./metadataExtractor\";\nimport { DownloadData, TranscodingDetails } from \"../types\";\nimport { Parser } from \"m3u8-parser\";\nimport { createURLFromBlob, revokeURL, isServiceWorkerContext } from \"../utils/browser\";\n\n// Re-define or import TrackError if it's thrown or caught here\nexport class TrackError extends Error {\n    constructor(message: string, trackId: number) {\n        super(`${message} (TrackId: ${trackId})`);\n    }\n}\n\nconst logger = Logger.create(\"DownloadHandler\", LogLevel.Debug);\nconst soundcloudApi = new SoundCloudApi(); // This might need to be passed in or instantiated differently\n\n// --- HELPER FUNCTIONS AND INTERFACE FOR downloadTrack (MOVED FROM BACKGROUND.TS) ---\nfunction isValidTrack(track: Track): boolean {\n    return track && track.kind === \"track\" && track.state === \"finished\" && (track.streamable || track.downloadable);\n}\n\nfunction isTranscodingDetails(detail: unknown): detail is TranscodingDetails {\n    return typeof detail === \"object\" && detail !== null && \"protocol\" in detail;\n}\n\nfunction getTranscodingDetails(details: Track): TranscodingDetails[] | null {\n    if (details?.media?.transcodings?.length < 1) {\n        logger.logDebug(`[DownloadHandler TrackId: ${details.id}] No transcodings array or empty in track.media.`);\n        return null;\n    }\n    // Log the raw transcodings for debugging\n    logger.logDebug(`[DownloadHandler TrackId: ${details.id}] Raw transcodings:`, JSON.stringify(details.media.transcodings, null, 2));\n\n    const mpegStreams = details.media.transcodings\n        .filter(\n            (transcoding) =>\n                (transcoding.format?.protocol === \"progressive\" || transcoding.format?.protocol === \"hls\") &&\n                (transcoding.format?.mime_type?.startsWith(\"audio/mpeg\") ||\n                    transcoding.format?.mime_type?.startsWith(\"audio/mp4\")) &&\n                !transcoding.snipped\n        )\n        .map<TranscodingDetails>((transcoding) => ({\n            protocol: transcoding.format.protocol as \"hls\" | \"progressive\",\n            url: transcoding.url,\n            quality: transcoding.quality as \"hq\" | \"sq\",\n        }));\n\n    if (mpegStreams.length < 1) {\n        logger.logWarn(\"[DownloadHandler] No transcodings streams could be determined for Track \" + details.id);\n        return null;\n    }\n    let streams = mpegStreams.sort((a, b) => {\n        if (a.quality === \"hq\" && b.quality === \"sq\") return -1;\n        if (a.quality === \"sq\" && b.quality === \"hq\") return 1;\n        if (a.protocol === \"progressive\" && b.protocol === \"hls\") return -1;\n        if (a.protocol === \"hls\" && b.protocol === \"progressive\") return 1;\n        return 0;\n    });\n    if (!getConfigValue(\"download-hq-version\")) {\n        streams = streams.filter((stream) => stream.quality !== \"hq\");\n    }\n    if (streams.some((stream) => stream.quality === \"hq\")) {\n        logger.logInfo(\"[DownloadHandler] Including high quality streams for Track \" + details.id);\n    }\n    return streams;\n}\n// --- END HELPER FUNCTIONS ---\n\n// MOVED FROM BACKGROUND.TS - Now part of DownloadHandler module\nexport async function downloadTrack(\n    track: Track,\n    trackNumber: number | undefined,\n    albumName: string | undefined,\n    playlistNameString: string | undefined,\n    reportProgress: (progress?: number, browserDownloadId?: number) => void\n): Promise<number> {\n    if (!isValidTrack(track)) { // Uses local helper\n        logger.logError(\"[DownloadHandler] Track does not satisfy constraints needed to be downloadable\", track);\n        // Use the TrackError defined in this module\n        throw new TrackError(\"Track does not satisfy constraints needed to be downloadable\", track.id);\n    }\n\n    const downloadDetails: Array<StreamDetails | TranscodingDetails> = [];\n\n    if (getConfigValue(\"download-original-version\") && track.downloadable && track.has_downloads_left) {\n        // Uses the soundcloudApi instance from this module\n        const originalDownloadUrl = await soundcloudApi.getOriginalDownloadUrl(track.id);\n        if (originalDownloadUrl) {\n            const stream: StreamDetails = {\n                url: originalDownloadUrl,\n                hls: false,\n                extension: undefined, // original_format issue handled, relying on handleDownload inference\n            };\n            downloadDetails.push(stream);\n        }\n    }\n\n    const transcodingDetailsResult = getTranscodingDetails(track); // Uses local helper\n    if (transcodingDetailsResult) {\n        downloadDetails.push(...transcodingDetailsResult);\n    }\n\n    if (downloadDetails.length < 1) {\n        const errorMessage = `[DownloadHandler] No download details could be determined for track: \"${track.title}\"`;\n        throw new TrackError(errorMessage, track.id); // Use local TrackError\n    }\n\n    for (const downloadDetail of downloadDetails) {\n        let stream: StreamDetails | null = null;\n        let hlsUsed = false;\n        let resolvedStreamUrl: string | null = null;\n        let resolvedExtension: string | undefined = undefined;\n\n        try {\n            if (isTranscodingDetails(downloadDetail)) { // Uses local helper\n                logger.logDebug(`[DownloadHandler TrackId: ${track.id}] Getting stream details for transcoding`, downloadDetail);\n                // Uses the soundcloudApi instance from this module\n                stream = await soundcloudApi.getStreamDetails(downloadDetail.url);\n                if (stream) {\n                    hlsUsed = stream.hls;\n                    resolvedStreamUrl = stream.url;\n                    resolvedExtension = stream.extension;\n                } else {\n                    logger.logWarn(`[DownloadHandler TrackId: ${track.id}] Failed to get stream details for transcoding option (url: ${downloadDetail.url}), trying next...`);\n                    continue;\n                }\n            } else {\n                stream = downloadDetail as StreamDetails;\n                resolvedStreamUrl = stream.url;\n                hlsUsed = stream.hls;\n                resolvedExtension = stream.extension;\n                logger.logDebug(`[DownloadHandler TrackId: ${track.id}] Using direct download detail (original file?)`, { url: resolvedStreamUrl, hls: hlsUsed, extension: resolvedExtension });\n            }\n\n            if (!resolvedStreamUrl) {\n                logger.logWarn(`[DownloadHandler TrackId: ${track.id}] No stream URL resolved, trying next...`, { downloadDetail });\n                continue;\n            }\n\n            let finalStreamUrl = resolvedStreamUrl;\n            let finalHlsFlag = hlsUsed;\n\n            const downloadData: DownloadData = {\n                trackId: track.id,\n                duration: track.duration,\n                uploadDate: new Date(track.display_date),\n                streamUrl: finalStreamUrl,\n                fileExtension: resolvedExtension,\n                title: track.title,\n                username: track.user.username,\n                userPermalink: track.user.permalink,\n                artworkUrl: track.artwork_url,\n                avatarUrl: track.user.avatar_url,\n                trackNumber,\n                albumName,\n                playlistName: playlistNameString,\n                hls: finalHlsFlag,\n                wasOriginallyHls: hlsUsed,\n            };\n\n            logger.logDebug(`[DownloadHandler TrackId: ${track.id}] Calling handleDownload with data`, { downloadData });\n            // Calls handleDownload from the same module and gets the browser's downloadId\n            // The reportProgress callback passed to handleDownload will handle progress from 0 up to just before file saving.\n            const browserDownloadIdFromHandler = await handleDownload(downloadData, reportProgress);\n\n            logger.logInfo(`[DownloadHandler TrackId: ${track.id}] handleDownload returned browserDownloadId: ${browserDownloadIdFromHandler} for stream: ${finalStreamUrl}`);\n\n            // downloadTrack now takes responsibility for the final 101 signal WITH the browser ID.\n            // This ensures that the browserDownloadId is available when 101 is reported.\n            reportProgress(101, browserDownloadIdFromHandler);\n            return browserDownloadIdFromHandler; // Return the browser's downloadId up the chain\n\n        } catch (error) {\n            logger.logWarn(\n                `[DownloadHandler TrackId: ${track.id}] Download attempt failed for option. Error: ${error?.message || error}`,\n                { downloadDetail, streamUrl: resolvedStreamUrl }\n            );\n            // Error from handleDownload will be TrackError instance from this file.\n        }\n    }\n\n    logger.logError(`[DownloadHandler TrackId: ${track.id}] All download attempts failed after trying ${downloadDetails.length} options.`);\n    reportProgress(102); // No browser ID to report here if all failed before that stage\n    // Use the TrackError defined in this module\n    throw new TrackError(\"No version of this track could be downloaded\", track.id);\n}\n\nexport async function handleDownload(data: DownloadData, reportProgress: (progress?: number, browserDownloadId?: number) => void): Promise<number> {\n    // --- DEBUG START: Moved to very beginning ---\n    logger.logDebug(`[handleDownload ENTRY] Processing TrackId: ${data.trackId}. History check comes later.`);\n    // --- DEBUG END ---\n\n    let artistsString = data.username;\n    let titleString = data.title;\n    let rawFilenameBase: string;\n    let artworkUrl = data.artworkUrl;\n    let streamBuffer: ArrayBuffer | undefined;\n    let streamHeaders: Headers | undefined;\n\n    // Hoisted variables for broader scope across new try-catch blocks\n    let saveAs: boolean;\n    let defaultDownloadLocation: string | undefined | null;\n    let shouldSkipExisting: boolean;\n    let determinedContentType: string | null | undefined;\n    let finalDownloadFilename: string;\n    let objectUrlToRevoke: string | undefined;\n    let potentialDownloadFilename: string;\n\n    try {\n        // SECTION 1: Metadata processing & rawFilenameBase creation\n        try {\n            logger.logInfo(`Initiating metadata processing for ${data.trackId} with payload`, { payload: data });\n            if (getConfigValue(\"normalize-track\")) {\n                const extractor = new MetadataExtractor(data.title, data.username, data.userPermalink);\n                let artists = extractor.getArtists();\n                if (!getConfigValue(\"include-producers\")) artists = artists.filter((i) => i.type !== ArtistType.Producer);\n                artistsString = artists.map((i) => i.name).join(\", \");\n                titleString = extractor.getTitle();\n                const remixers = artists.filter((i) => i.type === ArtistType.Remixer);\n                if (remixers.length > 0) {\n                    const remixerNames = remixers.map((i) => i.name).join(\" & \");\n                    const remixTypeString = RemixType[remixers[0].remixType || RemixType.Remix].toString();\n                    titleString += ` (${remixerNames} ${remixTypeString})`;\n                }\n            }\n\n            if (!artistsString) artistsString = \"Unknown\";\n            if (!titleString) titleString = \"Unknown\";\n\n            rawFilenameBase = sanitizeFilenameForDownload(`${artistsString} - ${titleString}`);\n        } catch (error) {\n            logger.logError(`[DownloadHandler TrackId: ${data.trackId}] Error during metadata processing:`, error);\n            throw new TrackError(`Metadata processing failed for track ${data.trackId}: ${(error as Error).message}`, data.trackId);\n        }\n\n        // Initialize config-dependent hoisted variables here, AFTER rawFilenameBase is set\n        saveAs = !getConfigValue(\"download-without-prompt\");\n        defaultDownloadLocation = getConfigValue(\"default-download-location\");\n        shouldSkipExisting = getConfigValue(\"skipExistingFiles\");\n\n        // SECTION 2: Filename and Skip Logic (uses rawFilenameBase)\n        try {\n            const checkExtension = data.fileExtension || \"mp3\";\n            potentialDownloadFilename = rawFilenameBase + \".\" + checkExtension;\n\n            if (!saveAs && defaultDownloadLocation) {\n                if (data.playlistName) {\n                    const sanitizedPlaylistName = sanitizeFilenameForDownload(data.playlistName);\n                    potentialDownloadFilename = defaultDownloadLocation + \"/\" + sanitizedPlaylistName + \"/\" + potentialDownloadFilename;\n                } else {\n                    potentialDownloadFilename = defaultDownloadLocation + \"/\" + potentialDownloadFilename;\n                }\n            }\n\n            if (shouldSkipExisting) {\n                let pathPrefix = \"\";\n                if (defaultDownloadLocation) {\n                    if (data.playlistName) {\n                        const sanitizedPlaylistName = sanitizeFilenameForDownload(data.playlistName);\n                        pathPrefix = defaultDownloadLocation + \"/\" + sanitizedPlaylistName + \"/\";\n                    } else {\n                        pathPrefix = defaultDownloadLocation + \"/\";\n                    }\n                }\n\n                const trackIdKey = `track-${data.trackId}`;\n                const trackDownloadHistory = await loadConfigValue(\"track-download-history\") || {};\n\n                logger.logDebug(`[History Check] shouldSkipExisting=${shouldSkipExisting}, trackIdKey=${trackIdKey}, history exists=${!!trackDownloadHistory}`);\n                if (Object.keys(trackDownloadHistory).length > 0) {\n                    logger.logDebug(`[History Check] History has ${Object.keys(trackDownloadHistory).length} entries`);\n                }\n\n                if (trackDownloadHistory && trackDownloadHistory[trackIdKey]) {\n                    const previousDownload = trackDownloadHistory[trackIdKey];\n                    logger.logInfo(`Skipping download for TrackId: ${data.trackId}. Previously downloaded as: ${previousDownload.filename} at ${new Date(previousDownload.timestamp).toLocaleString()}`);\n                    reportProgress(101);\n                    // Generate a fake download ID for the UI to use when skipping downloads\n                    const fakeDownloadId = Math.floor(Math.random() * 1000000) + 1000;\n                    logger.logInfo(`Using fake download ID ${fakeDownloadId} for skipped track ${data.trackId}`);\n                    return fakeDownloadId;\n                }\n\n                const specificFilename = `${pathPrefix}${rawFilenameBase}.${data.fileExtension || \"mp3\"}`;\n                const exactQuery: chrome.downloads.DownloadQuery = { filename: specificFilename };\n                logger.logDebug(`[History Check] Searching downloads with exactQuery: ${JSON.stringify(exactQuery)}`);\n                const exactMatches = await searchDownloads(exactQuery);\n                logger.logDebug(`[History Check] exactMatches found: ${exactMatches.length}`);\n\n                const escapedPathPrefix = pathPrefix.replace(/[-/^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n                const escapedRawFilenameBase = rawFilenameBase.replace(/[-/^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n                const regexQuery: chrome.downloads.DownloadQuery = { filenameRegex: `^${escapedPathPrefix}${escapedRawFilenameBase}\\\\..+$` };\n                logger.logDebug(`[History Check] Searching downloads with regexQuery: ${JSON.stringify(regexQuery)}`);\n                const regexMatches = exactMatches.length === 0 ? await searchDownloads(regexQuery) : [];\n                logger.logDebug(`[History Check] regexMatches found: ${regexMatches.length}`);\n\n                const filenameWithoutPathRegex = `${escapedRawFilenameBase}\\\\..+$`;\n                const titleArtistQuery: chrome.downloads.DownloadQuery = { filenameRegex: filenameWithoutPathRegex };\n                logger.logDebug(`[History Check] Searching downloads with titleArtistQuery: ${JSON.stringify(titleArtistQuery)}`);\n                const titleArtistMatches = exactMatches.length === 0 && regexMatches.length === 0 ?\n                    await searchDownloads(titleArtistQuery) : [];\n                logger.logDebug(`[History Check] titleArtistMatches found: ${titleArtistMatches.length}`);\n\n                const allMatches = [...exactMatches, ...regexMatches, ...titleArtistMatches];\n                const completedDownloads = allMatches.filter(d => d.state === \"complete\");\n\n                if (completedDownloads.length > 0) {\n                    logger.logInfo(`Skipping download for TrackId: ${data.trackId}. File already exists in download history: ${completedDownloads[0].filename}`);\n                    // Log the first few matches to help with debugging\n                    if (completedDownloads.length > 0) {\n                        completedDownloads.slice(0, 3).forEach((download, i) => {\n                            logger.logDebug(`[History Check] Match ${i}: filename=${download.filename}, state=${download.state}`);\n                        });\n                    }\n\n                    trackDownloadHistory[trackIdKey] = {\n                        filename: completedDownloads[0].filename,\n                        timestamp: Date.now()\n                    };\n                    await storeConfigValue(\"track-download-history\", trackDownloadHistory);\n                    reportProgress(101);\n                    // Generate a fake download ID for the UI to use when skipping downloads\n                    const fakeDownloadId = Math.floor(Math.random() * 1000000) + 1000;\n                    logger.logInfo(`Using fake download ID ${fakeDownloadId} for already downloaded track ${data.trackId}`);\n                    return fakeDownloadId;\n                } else {\n                    logger.logDebug(`No matching downloads found for TrackId: ${data.trackId} with filename base \"${rawFilenameBase}\"`);\n                }\n            } else {\n                logger.logDebug(\"[History Check] Skip existing files check is disabled\");\n            }\n        } catch (error) {\n            logger.logError(`[DownloadHandler TrackId: ${data.trackId}] Error during filename/skip logic:`, error);\n            throw new TrackError(`Filename/skip logic failed for track ${data.trackId}: ${(error as Error).message}`, data.trackId);\n        }\n\n        // SECTION 3: Artwork URL handling (updates artworkUrl used for tagging)\n        try {\n            if (!artworkUrl) {\n                logger.logInfo(`No Artwork URL in data. Fallback to User Avatar (TrackId: ${data.trackId})`);\n                artworkUrl = data.avatarUrl;\n            }\n        } catch (error) {\n            logger.logWarn(`[DownloadHandler TrackId: ${data.trackId}] Error checking/falling back artwork URL: ${(error as Error).message}. Will attempt with current value.`);\n        }\n\n        logger.logInfo(`Starting download of '${rawFilenameBase}' (TrackId: ${data.trackId})...`);\n\n        let originalStreamBuffer: ArrayBuffer | undefined;\n\n        // SECTION 4: Downloading (HLS/Progressive), Extension Inference, FFmpeg\n        try {\n            if (data.hls) {\n                logger.logInfo(`[TrackId: ${data.trackId}] Starting HLS segment fetching from: ${data.streamUrl}`);\n                const [playlistBuffer, initialHeaders] = await soundcloudApi.downloadStream(data.streamUrl, (p) => {\n                    if (p !== undefined) reportProgress(p * 0.1);\n                });\n                streamHeaders = initialHeaders;\n                if (!playlistBuffer) throw new Error(\"HLS playlist download failed or returned empty buffer.\");\n                const playlistText = new TextDecoder().decode(playlistBuffer);\n                const parser = new Parser();\n                parser.push(playlistText);\n                parser.end();\n                let initSegmentBuffer: ArrayBuffer | null = null;\n                if (parser.manifest?.segments?.length > 0) {\n                    const segmentWithMap = parser.manifest.segments.find(seg => seg.map?.uri);\n                    if (segmentWithMap?.map?.uri) {\n                        let initSegmentFullUrl = segmentWithMap.map.uri;\n                        try {\n                            if (!(initSegmentFullUrl.startsWith(\"http://\") || initSegmentFullUrl.startsWith(\"https://\"))) {\n                                initSegmentFullUrl = new URL(initSegmentFullUrl, data.streamUrl).href;\n                            }\n                        } catch (_e) {\n                            if (!(initSegmentFullUrl.startsWith(\"http://\") || initSegmentFullUrl.startsWith(\"https://\"))) {\n                                throw new Error(`Failed to resolve relative HLS init segment URI: ${initSegmentFullUrl}`);\n                            }\n                        }\n                        const [initData] = await soundcloudApi.downloadStream(initSegmentFullUrl, (p) => { if (p !== undefined) reportProgress(5 + (p * 0.05)); });\n                        if (!initData) throw new Error(`Failed to download HLS init segment: ${initSegmentFullUrl}`);\n                        initSegmentBuffer = initData;\n                    }\n                }\n                let segmentUris: string[] = [];\n                if (parser.manifest?.segments?.length > 0) {\n                    segmentUris = parser.manifest.segments.map(segment => {\n                        try { return new URL(segment.uri, data.streamUrl).href; } catch (_e) {\n                            if (segment.uri.startsWith(\"http://\") || segment.uri.startsWith(\"https://\")) return segment.uri;\n                            throw new Error(`Failed to resolve relative HLS segment URI: ${segment.uri}`);\n                        }\n                    });\n                }\n                if (segmentUris.length === 0 && !initSegmentBuffer) throw new Error(\"HLS playlist contains no media segments or init segment.\");\n                const segments: ArrayBuffer[] = [];\n                const totalSegments = segmentUris.length;\n                const segmentProgressStart = initSegmentBuffer ? 10 : 5;\n                const segmentProgressRange = initSegmentBuffer ? 80 : 85;\n                for (let i = 0; i < totalSegments; i++) {\n                    const [segmentData] = await soundcloudApi.downloadStream(segmentUris[i], (p_segment) => {\n                        if (p_segment !== undefined) reportProgress(segmentProgressStart + ((i + (p_segment / 100)) / totalSegments) * segmentProgressRange);\n                    });\n                    if (!segmentData) throw new Error(`Failed to download HLS segment: ${segmentUris[i]}`);\n                    segments.push(segmentData);\n                    const rateLimitMs = (getConfigValue(\"hls-rate-limit-delay-ms\") as number | undefined) ?? 0;\n                    if (rateLimitMs > 0 && i < totalSegments - 1) await new Promise(resolve => setTimeout(resolve, rateLimitMs));\n                }\n                const buffersToConcat: ArrayBuffer[] = [];\n                if (initSegmentBuffer) buffersToConcat.push(initSegmentBuffer);\n                buffersToConcat.push(...segments);\n                streamBuffer = concatArrayBuffers(buffersToConcat);\n                data.hls = false;\n            } else {\n                [streamBuffer, streamHeaders] = await soundcloudApi.downloadStream(data.streamUrl, reportProgress);\n            }\n\n            if (!streamBuffer) {\n                throw new TrackError(\"Stream buffer is undefined after download attempts\", data.trackId);\n            }\n            originalStreamBuffer = streamBuffer.slice(0);\n            logger.logDebug(`[DownloadHandler TrackId: ${data.trackId}] Initial streamBuffer byteLength: ${streamBuffer?.byteLength}, originalStreamBuffer byteLength: ${originalStreamBuffer?.byteLength}`);\n\n            // --- BEGIN Extension Correction for HLS Bug ---\n            if (data.wasOriginallyHls && data.fileExtension && /^[a-f0-9]{4}$/i.test(data.fileExtension) && data.streamUrl.includes(\"/aac\")) {\n                // Heuristic: If it was HLS, extension is 4 hex chars (like '6c2c' from a UUID segment), and original URL indicates AAC audio.\n                logger.logWarn(`[DownloadHandler TrackId: ${data.trackId}] Correcting likely bogus HLS AAC extension '${data.fileExtension}' to 'm4a'.`);\n                data.fileExtension = \"m4a\";\n            } else if (data.wasOriginallyHls && data.fileExtension && data.fileExtension.toLowerCase() === \"m3u8\") {\n                // If the API somehow returned m3u8 as the extension for the audio stream itself\n                logger.logWarn(`[DownloadHandler TrackId: ${data.trackId}] Correcting HLS extension from 'm3u8' to 'm4a' (assuming AAC).`);\n                data.fileExtension = \"m4a\"; // Default to m4a, could be mp3 if URL indicated mp3 HLS\n            }\n            // --- END Extension Correction for HLS Bug ---\n\n            if (!data.fileExtension && streamHeaders) {\n                determinedContentType = streamHeaders.get(\"content-type\");\n                let extension = \"mp3\";\n                if (determinedContentType === \"audio/mp4\") extension = \"m4a\";\n                else if (determinedContentType === \"audio/x-wav\" || determinedContentType === \"audio/wav\") extension = \"wav\";\n                data.fileExtension = extension;\n            } else if (!data.fileExtension) {\n                data.fileExtension = \"mp3\";\n            }\n\n            const ffmpegRemuxEnabled = getConfigValue(\"ffmpeg-remux-hls-mp4\");\n            if (ffmpegRemuxEnabled && (data.fileExtension === \"m4a\" || data.fileExtension === \"mp4\")) {\n                reportProgress(85);\n\n                // Define a callback for FFMPEG's internal progress (0-100% for its own operation)\n                const handleFFmpegInternalProgress = (ffmpegInternalProgress: number) => {\n                    // Scale FFMPEG's 0-100% progress to fit within a smaller range of the overall progress,\n                    // for example, mapping it from 85% to 98% of the total download progress.\n                    // 13% of total progress is allocated to FFMPEG (98 - 85 = 13).\n                    const overallProgressUpdate = 85 + Math.floor(ffmpegInternalProgress * 0.13);\n                    reportProgress(overallProgressUpdate);\n                };\n\n                try {\n                    logger.logInfo(`[DownloadHandler TrackId: ${data.trackId}] Sending remux task to FFmpegManager. Original streamBuffer byteLength before remux: ${originalStreamBuffer?.byteLength}`);\n                    // Use originalStreamBuffer, which should be the complete downloaded (possibly HLS-concatenated) buffer\n                    const remuxedBuffer = await requestRemux(\n                        data.trackId.toString(), // Ensure taskId is a string for the manager\n                        originalStreamBuffer,    // This is the buffer to be remuxed\n                        data.fileExtension || \"mp4\",\n                        handleFFmpegInternalProgress\n                    );\n                    streamBuffer = remuxedBuffer; // Update streamBuffer with the remuxed result\n                    if (data.fileExtension === \"m4a\" || data.fileExtension === \"mp4\") determinedContentType = \"audio/mp4\";\n                    reportProgress(99); // Indicate FFMPEG phase finished successfully\n                    logger.logInfo(`[DownloadHandler TrackId: ${data.trackId}] Remux task completed by FFmpegManager.`);\n                } catch (ffmpegError) {\n                    logger.logError(`[FFMPEG_MANAGER] Error during remux via manager. Proceeding with original. TrackId: ${data.trackId}`, ffmpegError);\n                    // Fallback to originalStreamBuffer if remuxing fails\n                    streamBuffer = originalStreamBuffer.slice(0); // Use a copy for safety\n                    logger.logDebug(`[DownloadHandler TrackId: ${data.trackId}] FFmpeg failed. Fallen back to originalStreamBuffer. ByteLength: ${streamBuffer?.byteLength}`);\n                    // reportProgress still at 85 or whatever it was before failure if ffmpegError is caught\n                }\n            } else {\n                logger.logDebug(`[DownloadHandler TrackId: ${data.trackId}] FFmpeg remux skipped (disabled or not applicable filetype).`);\n            }\n        } catch (error) {\n            logger.logError(`[DownloadHandler TrackId: ${data.trackId}] Error during download/FFmpeg stage:`, error);\n            throw new TrackError(`Download/FFmpeg failed for track ${data.trackId}: ${(error as Error).message}`, data.trackId);\n        }\n\n        let taggedBuffer: ArrayBuffer | undefined;\n\n        // SECTION 5: Metadata Tagging (uses artistsString, titleString from SECTION 1)\n        try {\n            const setMetadata = getConfigValue(\"set-metadata\");\n            if (setMetadata && streamBuffer) {\n                let writer: TagWriter | undefined;\n                const bufferForTagging = streamBuffer.slice(0);\n\n                if (data.fileExtension === \"mp3\") writer = new Mp3TagWriter(bufferForTagging);\n                else if (data.fileExtension === \"m4a\" || data.fileExtension === \"mp4\") writer = new Mp4TagWriter(bufferForTagging);\n\n                if (writer) {\n                    if (titleString) writer.setTitle(titleString);\n                    if (artistsString) writer.setArtists([artistsString]);\n\n                    if (data.albumName) writer.setAlbum(data.albumName);\n                    else if (data.playlistName) writer.setAlbum(data.playlistName);\n\n                    if (data.uploadDate) {\n                        const year = data.uploadDate.getFullYear();\n                        if (!isNaN(year)) writer.setYear(year);\n                    }\n                    if (data.trackNumber) writer.setTrackNumber(data.trackNumber);\n\n                    if (artworkUrl) {\n                        try {\n                            const actualArtworkUrl = artworkUrl.replace(\"-large.jpg\", \"-t500x500.jpg\");\n                            const artworkResponse = await fetch(actualArtworkUrl);\n                            if (!artworkResponse.ok) throw new Error(`Artwork fetch failed: ${artworkResponse.statusText}`);\n                            const fetchedArtworkBuffer = await artworkResponse.arrayBuffer();\n                            writer.setArtwork(fetchedArtworkBuffer);\n                        } catch (artworkError) {\n                            logger.logWarn(`[Artwork] Failed to fetch/set artwork for tagging TrackId: ${data.trackId}`, artworkError);\n                        }\n                    }\n\n                    const tagWriterResult = await writer.getBuffer();\n                    if (tagWriterResult?.buffer?.byteLength > 0) {\n                        taggedBuffer = tagWriterResult.buffer;\n                    } else {\n                        logger.logWarn(\"[Metadata] TagWriter returned invalid buffer. Using untagged buffer.\");\n                        taggedBuffer = streamBuffer.slice(0);\n                    }\n                } else {\n                    logger.logWarn(`[TrackId: ${data.trackId}] No TagWriter for ext '${data.fileExtension}'. Using untagged buffer.`);\n                    taggedBuffer = streamBuffer.slice(0);\n                }\n            } else {\n                logger.logInfo(`[TrackId: ${data.trackId}] Metadata disabled or no streamBuffer. Using untagged.`);\n                taggedBuffer = streamBuffer?.slice(0);\n            }\n        } catch (error) {\n            logger.logError(`[DownloadHandler TrackId: ${data.trackId}] Error during metadata tagging:`, error);\n            taggedBuffer = streamBuffer?.slice(0);\n        }\n\n        let bufferToSave: ArrayBuffer;\n\n        // SECTION 6: Final Buffer Selection and Blob Creation\n        try {\n            bufferToSave = taggedBuffer?.byteLength > 0 ? taggedBuffer :\n                streamBuffer?.byteLength > 0 ? streamBuffer.slice(0) :\n                    originalStreamBuffer?.byteLength > 0 ? originalStreamBuffer.slice(0) :\n                        (() => { throw new TrackError(`All buffers invalid for ${data.trackId}`, data.trackId); })();\n            if (bufferToSave.byteLength < 100) logger.logWarn(`Final buffer small: ${bufferToSave.byteLength} bytes.`);\n            logger.logDebug(`[DownloadHandler TrackId: ${data.trackId}] Final bufferToSave byteLength before Blob creation: ${bufferToSave?.byteLength}`);\n\n            const blobOptions: BlobPropertyBag = {};\n            if (determinedContentType) blobOptions.type = determinedContentType;\n            else if (data.fileExtension === \"mp3\") blobOptions.type = \"audio/mpeg\";\n            else if (data.fileExtension === \"m4a\" || data.fileExtension === \"mp4\") blobOptions.type = \"audio/mp4\";\n            else if (data.fileExtension === \"wav\") blobOptions.type = \"audio/wav\";\n\n            const downloadBlob = new Blob([bufferToSave], blobOptions);\n\n            // Use our browser-compatible utility to create the URL\n            logger.logInfo(`Creating URL for download (TrackId: ${data.trackId}). Service worker context: ${isServiceWorkerContext()}`);\n            objectUrlToRevoke = await createURLFromBlob(downloadBlob);\n\n        } catch (error) {\n            logger.logError(`[DownloadHandler TrackId: ${data.trackId}] Error preparing final buffer or Blob/DataURL:`, error);\n            throw new TrackError(`Failed to prepare buffer/DataURL for track ${data.trackId}: ${(error as Error).message}`, data.trackId);\n        }\n\n        finalDownloadFilename = rawFilenameBase + \".\" + (data.fileExtension || \"mp3\");\n        if (!saveAs && defaultDownloadLocation) {\n            // Corrected path construction to avoid potential double slashes if defaultDownloadLocation ends with /\n            const base = defaultDownloadLocation.endsWith(\"/\") ? defaultDownloadLocation.slice(0, -1) : defaultDownloadLocation;\n            const playlistFolder = data.playlistName ? `/${sanitizeFilenameForDownload(data.playlistName)}` : \"\";\n            const justTheFilename = finalDownloadFilename.split(\"/\").pop() || finalDownloadFilename;\n            finalDownloadFilename = `${base}${playlistFolder}/${justTheFilename}`;\n        }\n\n        // SECTION 7: File Saving and History Update\n        try {\n            logger.logInfo(`Downloading track as '${finalDownloadFilename}' (TrackId: ${data.trackId}). SaveAs: ${saveAs}`);\n            const urlToDownload = objectUrlToRevoke; // This now holds the data URL\n\n            if (!urlToDownload) {\n                throw new Error(\"Data URL for download is undefined.\");\n            }\n\n            // Get the downloadId from downloadToFile\n            const browserDownloadId = await downloadToFile(urlToDownload, finalDownloadFilename, saveAs);\n            logger.logInfo(`Successfully initiated browser download for '${rawFilenameBase}' (TrackId: ${data.trackId}) with browserDownloadId: ${browserDownloadId}`);\n\n            if (shouldSkipExisting) {\n                const histKey = `track-${data.trackId}`;\n                const history = await loadConfigValue(\"track-download-history\") || {};\n                history[histKey] = { filename: finalDownloadFilename, timestamp: Date.now() };\n                await storeConfigValue(\"track-download-history\", history);\n            }\n            // REMOVED: reportProgress(101); \n            // The function now returns the browser's download ID.\n            // The caller (downloadTrack) will be responsible for the final 101 progress report.\n            return browserDownloadId;\n        } catch (saveError) {\n            logger.logError(`[DownloadHandler TrackId: ${data.trackId}] Download save stage error:`, saveError);\n            throw new TrackError(`Save failed for track ${data.trackId}: ${(saveError as Error).message}`, data.trackId);\n        }\n        // No finally block with URL.revokeObjectURL is needed for data URLs.\n        // The variable objectUrlToRevoke could be renamed throughout the function if desired for clarity.\n\n    } catch (error) {\n        logger.logError(`[DownloadHandler TrackId: ${data.trackId}] Uncaught error in handleDownload`, error);\n        // Ensure progress is reported as error if it hasn't reached completion stage\n        // However, reportProgress might not be defined if error is very early. Consider implications.\n        // reportProgress(undefined); // This might be too simplistic or cause issues if called too early.\n        if (error instanceof TrackError) {\n            throw error;\n        } else {\n            throw new TrackError(`Unknown error during download: ${error?.message || error}`, data.trackId);\n        }\n    }\n} ","import { Logger, LogLevel } from \"../utils/logger\"; // Assuming logger is in utils\n\nconst logger = Logger.create(\"Semaphore\", LogLevel.Debug);\n\nexport class Semaphore {\n    private tasks: (() => void)[] = [];\n    private count: number;\n    private readonly maxCount: number;\n\n    constructor(count: number) {\n        if (count <= 0) {\n            throw new Error(\"Semaphore count must be a positive integer.\");\n        }\n        this.count = count;\n        this.maxCount = count;\n    }\n\n    private async acquire(): Promise<void> {\n        logger.logDebug(`Acquire attempt: current count ${this.count}, tasks in queue ${this.tasks.length}`);\n        if (this.count > 0) {\n            this.count--;\n            logger.logDebug(`Acquired immediately. New count ${this.count}`);\n            return Promise.resolve();\n        }\n        // Wait for a slot to be released\n        return new Promise<void>((resolve) => {\n            this.tasks.push(resolve);\n            logger.logDebug(`Queued. New queue length ${this.tasks.length}`);\n        });\n    }\n\n    private release(): void {\n        this.count++;\n        logger.logDebug(`Released. New count ${this.count}`);\n        if (this.tasks.length > 0) {\n            const nextTaskResolve = this.tasks.shift();\n            if (nextTaskResolve) {\n                this.count--; // Re-acquire for the new task that is about to be resolved\n                logger.logDebug(`Processing queued task. New count ${this.count}, New queue length ${this.tasks.length}`);\n                nextTaskResolve();\n            }\n        }\n        if (this.count > this.maxCount) {\n            logger.logWarn(`Semaphore count (${this.count}) exceeded maxCount (${this.maxCount}) after release. This might indicate an issue.`);\n            this.count = this.maxCount; // Correct it\n        }\n    }\n\n    public async withLock<T>(fn: () => Promise<T>): Promise<T> {\n        await this.acquire();\n        try {\n            return await fn();\n        } finally {\n            this.release();\n        }\n    }\n\n    public getAvailablePermits(): number {\n        return this.count;\n    }\n\n    public getQueueLength(): number {\n        return this.tasks.length;\n    }\n} ","import { SoundCloudApi, Track } from \"../api/soundcloudApi\";\nimport { LogLevel, Logger } from \"../utils/logger\";\nimport { downloadTrack } from \"../downloader/downloadHandler\";\nimport {\n    sendDownloadProgress,\n    chunkArray,\n} from \"./background\";\nimport { sendMessageToTab } from \"../compatibility/compatibilityStubs\";\nimport {\n    DownloadRequest,\n    DownloadSetRangeRequest,\n    Playlist,\n} from \"../types\";\nimport { loadConfigValue, storeConfigValue, getConfigValue, loadConfiguration, configKeys, Config } from \"../settings/config\";\nimport { MetadataExtractor } from \"../downloader/metadataExtractor\";\nimport { eraseDownloadHistoryEntry } from \"../utils/browser\";\nimport { Semaphore } from \"./semaphore\";\n\n// Message Type Constants\nexport const DOWNLOAD_SET = \"DOWNLOAD_SET\";\nexport const DOWNLOAD = \"DOWNLOAD\";\nexport const DOWNLOAD_SET_RANGE = \"DOWNLOAD_SET_RANGE\";\nexport const PAUSE_DOWNLOAD = \"PAUSE_DOWNLOAD\";\nexport const RESUME_DOWNLOAD = \"RESUME_DOWNLOAD\";\n\n// Local TrackError for message handling issues, or import a general one if suitable\nclass MessageHandlerError extends Error {\n    constructor(message: string) {\n        super(message);\n    }\n}\n\n// State for paused downloads\nconst pausedDownloads: { [downloadId: string]: boolean } = {};\n\nconst soundcloudApi = new SoundCloudApi();\nconst logger = Logger.create(\"MessageHandler\", LogLevel.Debug);\n\n// ADDED: Semaphore for controlling downloadTrack concurrency\n// const downloadTrackSemaphore = new Semaphore(3); // Old hardcoded value\nconst initialMaxConcurrentDownloads = Math.max(1, Math.min(Number(getConfigValue(\"maxConcurrentTrackDownloads\")) || 3, 10));\nconst downloadTrackSemaphore = new Semaphore(initialMaxConcurrentDownloads);\nlogger.logInfo(`Download track semaphore initialized with concurrency: ${initialMaxConcurrentDownloads}`);\n\n// Main message handling function\nexport async function handleIncomingMessage(message: DownloadRequest, sender: chrome.runtime.MessageSender) {\n    // --- Add critical logging at the very beginning ---\n    let receivedMessageForLog = {};\n    try {\n        receivedMessageForLog = JSON.parse(JSON.stringify(message));\n    } catch (_e) {\n        receivedMessageForLog = { errorParsingMessage: true, rawMessage: String(message) };\n    }\n    logger.logDebug(\"[MessageHandler DEBUG] Received message:\", receivedMessageForLog);\n\n    if (!message || (message.downloadId === undefined && message.type !== undefined && message.type !== \"GET_EXTENSION_CONFIG\")) {\n        logger.logError(\n            \"CRITICAL: MessageHandler received message with undefined or missing downloadId for a relevant type!\",\n            receivedMessageForLog\n        );\n        // Depending on how you want to handle this, you might return or throw.\n    }\n    // --- End critical logging ---\n\n    const tabId = sender.tab?.id;\n    const { downloadId, url, type } = message;\n\n    if (!tabId) {\n        logger.logWarn(\"Message received without a valid tab ID\", { sender, message });\n        return { error: \"No valid tab ID found in message sender\" }; // Return a JSON-serializable error object\n    }\n\n    // Handle GET_EXTENSION_CONFIG separately as it doesn't involve typical download flow\n    if (type === \"GET_EXTENSION_CONFIG\") {\n        logger.logDebug(`[MessageHandler] Received GET_EXTENSION_CONFIG request from tab ${tabId}`);\n        try {\n            const currentFullConfig = await loadConfiguration(false); // monitorStorage is false, background already does this\n            const nonSecretConfig: Partial<Record<keyof Config, { value: any }>> = {};\n\n            for (const key of configKeys) {\n                if (!currentFullConfig[key].secret) {\n                    nonSecretConfig[key] = { value: currentFullConfig[key].value };\n                }\n            }\n            logger.logDebug(\"[MessageHandler] Sending non-secret configuration to content script:\", nonSecretConfig);\n            return Promise.resolve(nonSecretConfig);\n        } catch (err) {\n            logger.logError(\"[MessageHandler] Error loading or preparing configuration for content script:\", err);\n            return Promise.reject({ error: \"Failed to retrieve extension configuration.\" });\n        }\n    }\n\n    // --- IMMEDIATE TEST MESSAGE for DOWNLOAD type only to reduce noise --- \n    if (type === DOWNLOAD && downloadId) { // Ensure downloadId is present for meaningful test\n        const testMessagePayload = {\n            scdl_test_message: \"HELLO_FROM_MESSAGE_HANDLER_EARLY_ACK_TEST\",\n            testForDownloadId: downloadId,\n            timestamp: Date.now()\n        };\n        logger.logDebug(`[MessageHandler TX TestMsg] Attempting to send TEST MESSAGE to tab ${tabId} for downloadId ${downloadId}:`, JSON.parse(JSON.stringify(testMessagePayload)));\n        sendMessageToTab(tabId, testMessagePayload)\n            .then(() => logger.logInfo(`[MessageHandler TX TestMsg] TEST MESSAGE for downloadId ${downloadId} successfully sent to tab ${tabId} (promise resolved).`))\n            .catch(e => logger.logError(`[MessageHandler TX TestMsg] TEST MESSAGE for downloadId ${downloadId} FAILED to send to tab ${tabId}:`, e));\n    }\n    // --- END IMMEDIATE TEST MESSAGE ---\n\n    try {\n        if (type === DOWNLOAD_SET) {\n            logger.logDebug(\"Received set download request\", { url, downloadId });\n\n            const ackSetPayload = { success: true, originalDownloadId: downloadId, message: \"Set download command received, preparing tracks.\" };\n            logger.logDebug(`[MessageHandler TX Ack] Attempting to send EARLY ACK (DOWNLOAD_SET) to tab ${tabId} for downloadId ${downloadId}:`, JSON.parse(JSON.stringify(ackSetPayload)));\n            sendMessageToTab(tabId, ackSetPayload)\n                .then(() => logger.logInfo(`[MessageHandler TX Ack] EARLY ACK (DOWNLOAD_SET) for ${downloadId} sent to tab ${tabId}.`))\n                .catch(e => logger.logError(\"[MessageHandler TX Ack] DOWNLOAD_SET: Failed to send initial command ack to tab\", e));\n\n            const set = await soundcloudApi.resolveUrl<Playlist>(url);\n            if (!set) {\n                throw new MessageHandlerError(`Failed to resolve SoundCloud URL. Check if you are logged in or if the URL is correct. URL: ${url}`);\n            }\n            delete pausedDownloads[downloadId]; // Moved here, after validation, before async block\n\n            // Immediate response to content script\n            const immediateResponse = { success: true, message: \"Playlist download initiated. Processing tracks in background.\", originalDownloadId: downloadId };\n            logger.logInfo(`[MessageHandler] Preparing IMMEDIATE response for DOWNLOAD_SET ${downloadId}.`);\n\n            // Asynchronous processing block\n            (async () => {\n                try {\n                    const trackIds = set.tracks.map((i) => i.id);\n                    const progresses: { [key: number]: number } = {};\n                    const browserDownloadIds: { [key: number]: number } = {};\n\n                    const reportPlaylistProgress = (trackId: number) => (progress?: number, browserDlId?: number) => {\n                        if (progress !== undefined) {\n                            progresses[trackId] = progress;\n                        }\n                        if (browserDlId !== undefined) {\n                            browserDownloadIds[trackId] = browserDlId;\n                        }\n                        const totalProgress = Object.values(progresses).reduce((acc, cur) => acc + cur, 0);\n                        const latestBrowserDlId = browserDownloadIds[trackId];\n                        sendDownloadProgress(tabId, downloadId, totalProgress / trackIds.length, undefined, undefined, latestBrowserDlId);\n                    };\n\n                    const setAlbumName = set.set_type === \"album\" || set.set_type === \"ep\" ? set.title : undefined;\n                    const setPlaylistName = set.set_type !== \"album\" && set.set_type !== \"ep\" ? set.title : undefined;\n\n                    const trackIdChunkSize = 10;\n                    const trackIdChunks = chunkArray(trackIds, trackIdChunkSize);\n                    let currentTrackIdChunk = 0;\n                    let encounteredError = false;\n                    let lastError: Error | null = null;\n\n                    for (const trackIdChunk of trackIdChunks) {\n                        sendDownloadProgress(tabId, downloadId, undefined, undefined, pausedDownloads[downloadId] ? \"Paused\" : undefined);\n                        while (pausedDownloads[downloadId]) {\n                            logger.logDebug(`Download ${downloadId} is paused. Waiting...`);\n                            await new Promise(resolve => setTimeout(resolve, 1000));\n                        }\n\n                        const keyedTracks = await soundcloudApi.getTracks(trackIdChunk);\n                        const tracks = Object.values(keyedTracks).reverse();\n                        logger.logInfo(`Downloading set chunk ${currentTrackIdChunk + 1}/${trackIdChunks.length}...`);\n                        const downloads: Promise<number>[] = [];\n\n                        for (let i = 0; i < tracks.length; i++) {\n                            const originalIndex = set.tracks.findIndex(t => t.id === tracks[i].id);\n                            const trackNumber = originalIndex !== -1 ? originalIndex + 1 : undefined;\n                            // MODIFIED: Wrap downloadTrack in semaphore\n                            const trackDownloadPromise = downloadTrackSemaphore.withLock(() =>\n                                downloadTrack(tracks[i], trackNumber, setAlbumName, setPlaylistName, reportPlaylistProgress(tracks[i].id))\n                            );\n                            downloads.push(trackDownloadPromise);\n                        }\n\n                        await Promise.all(\n                            downloads.map((p) =>\n                                p.catch((error) => {\n                                    logger.logWarn(\"Failed to download track of set\", error);\n                                    encounteredError = true;\n                                    lastError = error;\n                                    return 0;\n                                })\n                            )\n                        );\n                        currentTrackIdChunk++;\n                    }\n\n                    if (encounteredError) {\n                        logger.logWarn(\"Playlist download completed with errors. Last error:\", lastError);\n                        sendDownloadProgress(tabId, downloadId, 102, lastError ?? new MessageHandlerError(\"One or more tracks failed to download.\"));\n                    } else {\n                        logger.logInfo(\"Downloaded set successfully!\");\n                        sendDownloadProgress(tabId, downloadId, 101);\n                    }\n                } catch (asyncError) {\n                    logger.logError(`[MessageHandler ASYNC DOWNLOAD_SET] Error during background processing for ${downloadId}:`, asyncError);\n                    const errorToSend = asyncError instanceof Error ? asyncError : new MessageHandlerError(String(asyncError));\n                    sendDownloadProgress(tabId, downloadId, undefined, errorToSend);\n                }\n            })(); // End of IIAFE\n\n            return immediateResponse; // Return immediate response\n        } else if (type === DOWNLOAD) {\n            logger.logDebug(\"Received track download request\", { url, downloadId });\n\n            // Step 1: Send early ack to UI (already happens via sendMessageToTab)\n            const ackDownloadPayload = { success: true, originalDownloadId: downloadId, message: \"Download command received, preparing track.\" };\n            logger.logDebug(`[MessageHandler TX Ack] Attempting to send EARLY ACK (DOWNLOAD) to tab ${tabId} for downloadId ${downloadId}:`, JSON.parse(JSON.stringify(ackDownloadPayload)));\n            sendMessageToTab(tabId, ackDownloadPayload)\n                .then(() => logger.logInfo(`[MessageHandler TX Ack] EARLY ACK (DOWNLOAD) for ${downloadId} sent to tab ${tabId}.`))\n                .catch(e => logger.logError(\"[MessageHandler TX Ack] DOWNLOAD: Failed to send initial command ack to tab\", e));\n\n            delete pausedDownloads[downloadId];\n\n            // Step 2: Resolve URL (still await this for basic validation)\n            const track = await soundcloudApi.resolveUrl<Track>(url);\n            if (!track) {\n                // If resolving fails, reject the initial message promise\n                throw new MessageHandlerError(`Failed to resolve SoundCloud track URL: ${url}`);\n            }\n\n            // Step 3: Define the immediate response to resolve the initial sendMessage promise\n            const immediateResponse = { success: true, message: \"Track resolved, download initiated.\", originalDownloadId: downloadId };\n            logger.logInfo(`[MessageHandler] Preparing IMMEDIATE response for ${downloadId} to content script.`);\n\n            // Step 4: START the download asynchronously (DO NOT AWAIT HERE)\n            // Use an immediately-invoked async function expression (IIAFE)\n            (async () => {\n                let originalSkipSetting: boolean | undefined = undefined; // Define here for finally block access\n                try {\n                    // Setup progress reporter (same as before)\n                    const reportTrackProgress = (progress?: number, browserDlIdFromCallback?: number) => {\n                        logger.logDebug(`[MessageHandler ASYNC] reportTrackProgress (for downloadId ${downloadId}) CALLED WITH: progress=${progress}, browserDlIdFromCallback=${browserDlIdFromCallback}`);\n                        sendDownloadProgress(tabId, downloadId, progress, undefined, undefined, browserDlIdFromCallback);\n                    };\n\n                    // Handle force redownload flags (same as before)\n                    const forceRedownload = (message as any).forceRedownload === true;\n                    if (forceRedownload) {\n                        logger.logInfo(`Force redownload requested for track ID ${track.id}. Temporarily bypassing all history and skip checks.`);\n\n                        // 1. Save the current skipExistingFiles setting\n                        originalSkipSetting = getConfigValue(\"skipExistingFiles\") as boolean;\n\n                        // 2. Temporarily disable skipExistingFiles\n                        if (originalSkipSetting) {\n                            logger.logInfo(\"Temporarily disabling skipExistingFiles for force redownload\");\n                            await storeConfigValue(\"skipExistingFiles\", false);\n                        }\n\n                        // 3. Temporarily remove this track from download history\n                        const trackIdKey = `track-${track.id}`;\n                        const trackDownloadHistory = await loadConfigValue(\"track-download-history\") || {};\n                        if (trackDownloadHistory && trackDownloadHistory[trackIdKey]) {\n                            // Save the original history entry - ASSUMING originalHistoryValue is defined elsewhere or not strictly needed for restore\n                            // originalHistoryValue = { ...trackDownloadHistory[trackIdKey] }; \n                            delete trackDownloadHistory[trackIdKey];\n                            await storeConfigValue(\"track-download-history\", trackDownloadHistory);\n                            logger.logInfo(`Temporarily removed track ${track.id} from download history for force redownload.`);\n                        }\n\n                        // 4. Erase from browser history (same as before)\n                        try {\n                            const extractor = new MetadataExtractor(track.title, track.user.username, track.user.permalink);\n                            const normalizedTitle = extractor.getTitle();\n                            const artistList = extractor.getArtists();\n                            const normalizedArtist = artistList.map(a => a.name).join(\", \");\n                            const filenamePattern = `${normalizedArtist} - ${normalizedTitle}`;\n                            const escapedPattern = filenamePattern.replace(/[-/^$*+?.()|[\\]{}]/g, \"\\\\$&\"); // Corrected regex escape\n                            const regexPattern = escapedPattern + \"\\\\..+$\";\n                            eraseDownloadHistoryEntry(regexPattern);\n                        } catch (error) {\n                            logger.logError(\"Force redownload: Failed to erase matching entries from browser download history:\", error);\n                        }\n                    }\n\n                    // Call downloadTrack (NO AWAIT needed here as we handle promise below)\n                    logger.logInfo(`[MessageHandler ASYNC] Starting downloadTrack for ${downloadId}`);\n                    downloadTrack(track, undefined, undefined, undefined, reportTrackProgress)\n                        .then(actualBrowserDownloadId => {\n                            logger.logInfo(`[MessageHandler ASYNC] Track download process for ${downloadId} finished by downloadTrack. Reported browser download ID: ${actualBrowserDownloadId}`);\n                            // Final 101 progress is sent by downloadTrack/reportTrackProgress itself now.\n                        })\n                        .catch(downloadError => {\n                            // If downloadTrack itself fails catastrophically (after trying all options)\n                            logger.logError(`[MessageHandler ASYNC] Error during downloadTrack execution for ${downloadId}:`, downloadError);\n                            // Send final error progress update\n                            sendDownloadProgress(tabId, downloadId, undefined, downloadError);\n                        })\n                        .finally(() => {\n                            // Restore skipExistingFiles setting if it was changed for force redownload\n                            if (forceRedownload && originalSkipSetting !== undefined) {\n                                logger.logInfo(`Restoring skipExistingFiles setting to ${originalSkipSetting} after force redownload for ${track.id}`);\n                                storeConfigValue(\"skipExistingFiles\", originalSkipSetting);\n                            }\n                            // TODO: Restore history entry if needed?\n                        });\n\n                } catch (asyncError) {\n                    // Catch errors from the setup phase within this async IIAFE (e.g., force redownload logic)\n                    logger.logError(`[MessageHandler ASYNC] Error setting up async download task for ${downloadId}:`, asyncError);\n                    sendDownloadProgress(tabId, downloadId, undefined, asyncError);\n                }\n            })(); // Immediately invoke the async function\n\n            // Step 5: Return the immediate response to resolve the initial sendMessage promise\n            return immediateResponse;\n        } else if (type === DOWNLOAD_SET_RANGE) {\n            const rangeMessage = message as DownloadSetRangeRequest;\n            logger.logInfo(\"Received set range download request\", {\n                url,\n                start: rangeMessage.start,\n                end: rangeMessage.end,\n                downloadId,\n                tabId\n            });\n\n            const ackRangePayload = { success: true, originalDownloadId: downloadId, message: \"Set range download command received, preparing tracks.\" };\n            logger.logDebug(`[MessageHandler TX Ack] Attempting to send EARLY ACK (DOWNLOAD_SET_RANGE) to tab ${tabId} for downloadId ${downloadId}:`, JSON.parse(JSON.stringify(ackRangePayload)));\n            sendMessageToTab(tabId, ackRangePayload)\n                .then(() => logger.logInfo(`[MessageHandler TX Ack] EARLY ACK (DOWNLOAD_SET_RANGE) for ${downloadId} sent to tab ${tabId}.`))\n                .catch(e => logger.logError(\"[MessageHandler TX Ack] DOWNLOAD_SET_RANGE: Failed to send initial command ack to tab\", e));\n\n            // Perform initial validations\n            const start = rangeMessage.start;\n            const end = rangeMessage.end;\n            const set = await soundcloudApi.resolveUrl<Playlist>(url);\n\n            if (!set) {\n                throw new MessageHandlerError(`Failed to resolve SoundCloud set. URL: ${url} returned null/undefined.`);\n            }\n            if (!set.tracks) {\n                throw new MessageHandlerError(`SoundCloud set is missing tracks property. URL: ${url}`);\n            }\n            if (set.tracks.length === 0) {\n                throw new MessageHandlerError(`SoundCloud set is empty (has 0 tracks). URL: ${url}`);\n            }\n\n            const totalTracks = set.tracks.length;\n            const validatedStart = Math.max(1, Math.min(start, totalTracks));\n            const validatedEnd = end === null ? totalTracks : Math.max(validatedStart, Math.min(end, totalTracks));\n\n            if (validatedStart > validatedEnd) {\n                throw new MessageHandlerError(`Invalid range: Start index (${validatedStart}) cannot be greater than End index (${validatedEnd}). Total tracks: ${totalTracks}`);\n            }\n\n            delete pausedDownloads[downloadId]; // Moved here, after validation, before async block\n\n            const immediateResponse = { success: true, message: \"Playlist range download initiated. Processing tracks in background.\", originalDownloadId: downloadId };\n            logger.logInfo(`[MessageHandler] Preparing IMMEDIATE response for DOWNLOAD_SET_RANGE ${downloadId}.`);\n\n            // Asynchronous processing block\n            (async () => {\n                try {\n                    logger.logInfo(`Successfully resolved playlist with ${set.tracks.length} tracks for range processing`, {\n                        title: set.title,\n                        set_type: set.set_type\n                    });\n                    logger.logInfo(`Processing range: ${validatedStart} to ${validatedEnd} (of ${totalTracks})`, {\n                        originalStart: start,\n                        originalEnd: end,\n                        validatedStart,\n                        validatedEnd,\n                        totalTracks\n                    });\n\n                    const tracksToDownload = set.tracks.slice(validatedStart - 1, validatedEnd);\n                    logger.logInfo(`Selected ${tracksToDownload.length} tracks for download in range`);\n\n                    if (tracksToDownload.length === 0) {\n                        logger.logWarn(\"Selected range resulted in zero tracks to download.\");\n                        sendDownloadProgress(tabId, downloadId, 101);\n                        return; // Exit IIAFE, immediateResponse was already sent\n                    }\n\n                    const isAlbum = set.set_type === \"album\" || set.set_type === \"ep\";\n                    const setAlbumName = isAlbum ? set.title : undefined;\n                    const setPlaylistName = !isAlbum ? set.title : undefined;\n\n                    logger.logInfo(\"Set metadata for range:\", {\n                        isAlbum,\n                        title: set.title,\n                        setAlbumName,\n                        setPlaylistName\n                    });\n\n                    const progresses: { [key: number]: number } = {};\n                    const browserDownloadIds: { [key: number]: number } = {};\n\n                    const reportPlaylistProgress = (trackId: number) => (progress?: number, browserDlId?: number) => {\n                        if (progress !== undefined) {\n                            progresses[trackId] = progress;\n                        }\n                        if (browserDlId !== undefined) {\n                            browserDownloadIds[trackId] = browserDlId;\n                        }\n                        const totalProgress = Object.values(progresses).reduce((acc, cur) => acc + cur, 0);\n                        const averageProgress = totalProgress / tracksToDownload.length;\n                        const latestBrowserDlId = browserDownloadIds[trackId];\n                        sendDownloadProgress(tabId, downloadId, averageProgress, undefined, undefined, latestBrowserDlId);\n                    };\n\n                    let encounteredError = false;\n                    let lastError: Error | null = null;\n                    const trackIdChunkSize = 5;\n                    const trackIdChunks = chunkArray(tracksToDownload.map(t => t.id), trackIdChunkSize);\n                    let currentTrackIdChunk = 0;\n\n                    logger.logInfo(`Splitting range download into ${trackIdChunks.length} chunks of size ${trackIdChunkSize}`);\n\n                    for (const trackIdChunk of trackIdChunks) {\n                        logger.logInfo(`Starting range chunk ${currentTrackIdChunk + 1}/${trackIdChunks.length}`, {\n                            trackIds: trackIdChunk\n                        });\n\n                        sendDownloadProgress(tabId, downloadId, undefined, undefined, pausedDownloads[downloadId] ? \"Paused\" : undefined);\n                        while (pausedDownloads[downloadId]) {\n                            logger.logDebug(`Download ${downloadId} is paused. Waiting...`);\n                            await new Promise(resolve => setTimeout(resolve, 1000));\n                        }\n\n                        logger.logInfo(`Fetching track data for range chunk ${currentTrackIdChunk + 1}`);\n                        const keyedTracks = await soundcloudApi.getTracks(trackIdChunk);\n                        const tracksInChunk = Object.values(keyedTracks).reverse();\n                        logger.logInfo(`Got ${tracksInChunk.length} tracks for range chunk ${currentTrackIdChunk + 1}/${trackIdChunks.length}`);\n\n                        const downloads: Promise<number>[] = [];\n\n                        for (let i = 0; i < tracksInChunk.length; i++) {\n                            const trackInfo = tracksInChunk[i];\n                            logger.logInfo(`Starting download for track ${i + 1}/${tracksInChunk.length} in range chunk`, {\n                                id: trackInfo.id,\n                                title: trackInfo.title\n                            });\n\n                            sendDownloadProgress(tabId, downloadId, undefined, undefined, pausedDownloads[downloadId] ? \"Paused\" : undefined);\n                            while (pausedDownloads[downloadId]) {\n                                logger.logDebug(`Download ${downloadId} is paused. Waiting...`);\n                                await new Promise(resolve => setTimeout(resolve, 1000));\n                            }\n\n                            const originalIndex = set.tracks.findIndex(t => t.id === trackInfo.id);\n                            const trackNumber = originalIndex !== -1 ? originalIndex + 1 : undefined;\n\n                            try {\n                                // MODIFIED: Wrap downloadTrack in semaphore\n                                const download = downloadTrackSemaphore.withLock(() =>\n                                    downloadTrack(\n                                        trackInfo,\n                                        trackNumber,\n                                        setAlbumName,\n                                        setPlaylistName,\n                                        reportPlaylistProgress(trackInfo.id)\n                                    )\n                                );\n                                downloads.push(download);\n                            } catch (trackError) {\n                                logger.logError(`Failed to start download for track ${trackInfo.title} in range`, trackError);\n                                encounteredError = true;\n                                lastError = trackError instanceof Error ? trackError : new Error(String(trackError));\n                            }\n                        }\n\n                        logger.logInfo(`Waiting for all downloads in range chunk ${currentTrackIdChunk + 1} to complete...`);\n                        await Promise.all(\n                            downloads.map((p) =>\n                                p.catch((error) => {\n                                    logger.logWarn(\"Failed to download track of set range\", error);\n                                    encounteredError = true;\n                                    lastError = error;\n                                    return 0;\n                                })\n                            )\n                        );\n                        logger.logInfo(`Completed all downloads in range chunk ${currentTrackIdChunk + 1}`);\n                        currentTrackIdChunk++;\n                    }\n\n                    if (encounteredError) {\n                        logger.logWarn(\"Playlist range download completed with errors. Last error:\", lastError);\n                        sendDownloadProgress(tabId, downloadId, 102, lastError ?? new MessageHandlerError(\"One or more tracks failed to download in the selected range.\"));\n                    } else {\n                        logger.logInfo(\"Downloaded playlist range successfully!\");\n                        sendDownloadProgress(tabId, downloadId, 101);\n                    }\n                } catch (asyncError) {\n                    logger.logError(`[MessageHandler ASYNC DOWNLOAD_SET_RANGE] Error during background processing for ${downloadId}:`, asyncError);\n                    const errorToSend = asyncError instanceof Error ? asyncError : new MessageHandlerError(String(asyncError));\n                    sendDownloadProgress(tabId, downloadId, undefined, errorToSend);\n                }\n            })(); // End of IIAFE for range download\n\n            return immediateResponse; // Return immediate response\n        } else if (type === PAUSE_DOWNLOAD) {\n            const pauseMessage = message as { downloadId: string }; // Type assertion\n            logger.logInfo(`Received pause request for download: ${pauseMessage.downloadId}`);\n            pausedDownloads[pauseMessage.downloadId] = true;\n            sendDownloadProgress(tabId, pauseMessage.downloadId, undefined, undefined, \"Paused\");\n            return { success: true, action: \"paused\", downloadId: pauseMessage.downloadId }; // Return success\n        } else if (type === RESUME_DOWNLOAD) {\n            const resumeMessage = message as { downloadId: string }; // Type assertion\n            logger.logInfo(`Received resume request for download: ${resumeMessage.downloadId}`);\n            pausedDownloads[resumeMessage.downloadId] = false;\n            sendDownloadProgress(tabId, resumeMessage.downloadId, undefined, undefined, \"Resuming\");\n            return { success: true, action: \"resumed\", downloadId: resumeMessage.downloadId }; // Return success\n        } else {\n            throw new MessageHandlerError(`Unknown download type: ${type}`);\n        }\n    } catch (error) {\n        // Ensure error is an instance of Error for sendDownloadProgress\n        const errorToSend = error instanceof Error ? error : new MessageHandlerError(String(error));\n        sendDownloadProgress(tabId, downloadId, undefined, errorToSend);\n        logger.logError(\"Download failed unexpectedly in message handler\", error);\n        return { error: errorToSend.message }; // Return error to avoid \"Failed to convert to Response\" errors\n    }\n} ","import { SoundCloudApi } from \"../api/soundcloudApi\";\nimport { LogLevel, Logger } from \"../utils/logger\";\nimport {\n  onBeforeSendHeaders,\n  onBeforeRequest,\n  onMessage,\n  onPageActionClicked,\n  openOptionsPage,\n  getExtensionManifest,\n  sendMessageToTab,\n} from \"../compatibility/compatibilityStubs\";\nimport { loadConfiguration, storeConfigValue, getConfigValue, registerConfigChangeHandler } from \"../settings/config\";\nimport { handleIncomingMessage } from \"./messageHandler\";\nimport { DownloadProgress } from \"../types\";\nimport { usesDeclarativeNetRequestForModification, setAuthHeaderRule, setClientIdRule } from \"../utils/browser\";\nimport { preInitializeFFmpegPool } from \"../downloader/ffmpegManager\";\n// --- Main TrackError class for background.ts specific errors ---\nexport class TrackError extends Error {\n  constructor(message: string, trackId?: number) {\n    super(trackId ? `${message} (TrackId: ${trackId})` : message);\n  }\n}\n\nconst soundcloudApi = new SoundCloudApi();\nconst logger = Logger.create(\"Background\", LogLevel.Debug);\nconst manifest = getExtensionManifest();\n\nconst RULE_ID_OAUTH = 1;\nconst RULE_ID_CLIENT_ID = 2;\n\n/**\n * Updates the declarativeNetRequest rule for adding the OAuth token header.\n * If oauthToken is null or undefined, the rule is removed.\n */\nasync function updateAuthHeaderRule(oauthToken?: string | null): Promise<void> {\n  await setAuthHeaderRule(oauthToken);\n}\n\n/**\n * Updates the declarativeNetRequest rule for redirecting with the client_id parameter.\n * If clientId is null or undefined, the rule is removed.\n */\nasync function updateClientIdRule(clientId?: string | null): Promise<void> {\n  await setClientIdRule(clientId);\n}\n\nlogger.logInfo(\"Starting with version: \" + manifest.version);\n\n// Register message listener EARLIER\nonMessage(handleIncomingMessage);\nlogger.logInfo(\"Initial message listener registered.\");\n\n// Load configuration and THEN register message listener AND SET INITIAL DNR RULE\nloadConfiguration(true).then(async () => {\n  logger.logInfo(\"Initial configuration loaded. Setting initial DNR rules.\");\n\n  const initialOauthToken = getConfigValue(\"oauth-token\") as string | null | undefined;\n  await updateAuthHeaderRule(initialOauthToken);\n\n  const initialClientId = getConfigValue(\"client-id\") as string | null | undefined;\n  await updateClientIdRule(initialClientId);\n\n  if (initialOauthToken) {\n    await oauthTokenChanged(initialOauthToken);\n  }\n\n  preInitializeFFmpegPool();\n});\n\n// --- EXPORTED Utility Functions (used by messageHandler.ts) ---\nexport function sendDownloadProgress(tabId: number, downloadId: string, progress?: number, error?: Error | string, status?: \"Paused\" | \"Resuming\", browserDownloadId?: number) {\n  // Enhanced validation of downloadId\n  if (!downloadId || typeof downloadId !== \"string\" || downloadId.trim() === \"\") {\n    logger.logError(`Attempted to send download progress with invalid downloadId: ${JSON.stringify(downloadId)}`);\n\n    // Rather than completely failing, try to log helpful diagnostic info\n    const callStack = new Error().stack;\n    logger.logError(`Call stack for invalid downloadId: ${callStack}`);\n\n    // For messages with progress codes that indicate completion, we should really\n    // try to send them even without a downloadId\n    if (progress === 101 || progress === 102) {\n      logger.logWarn(`Attempting to send COMPLETION message (${progress}) even with missing downloadId`);\n      // Try sending a special message that content.ts can try to match to an active download\n      const fallbackMessage = {\n        downloadId: \"undefined_completion\",\n        progress,\n        error: typeof error === \"string\" ? error : error instanceof Error ? error.message : \"\",\n        status,\n        completionWithoutId: true,\n        timestamp: Date.now(),\n        browserDownloadId // Include browserDownloadId if it exists\n      };\n\n      sendMessageToTab(tabId, fallbackMessage).catch(err => {\n        logger.logError(`Failed to send fallback completion message: ${err}`);\n      });\n    }\n    return;\n  }\n\n  let errorMessage: string = \"\";\n  if (error instanceof Error) {\n    errorMessage = error.message;\n  } else if (typeof error === \"string\") {\n    errorMessage = error;\n  }\n\n  if (progress === 101 || progress === 102) {\n    logger.logInfo(`Sending COMPLETION message for download ${downloadId} to tab ${tabId}, progress=${progress}`);\n  } else if (progress === 100) {\n    logger.logInfo(`Sending FINISHING message for download ${downloadId} to tab ${tabId}`);\n  } else if (progress !== undefined && progress >= 0) {\n    // logger.logDebug(`Sending progress update for download ${downloadId} to tab ${tabId}, progress=${progress.toFixed(1)}%`);\n  }\n\n  const downloadProgressMessage: DownloadProgress = {\n    downloadId,\n    progress,\n    error: errorMessage,\n    status,\n    timestamp: Date.now(), // Add timestamp to help with matching in content.ts\n    browserDownloadId      // Include browserDownloadId in all messages\n  };\n\n  // SIMPLIFIED SENDING LOGIC:\n  // Only send one message, regardless of progress type.\n  // The previous logic for multiple timed messages for 101/102 is removed for testing.\n  if (progress === 101 || progress === 102) {\n    logger.logInfo(`Sending SINGLE COMPLETION message for download ${downloadId} to tab ${tabId}, progress=${progress} (BrowserDownloadId: ${browserDownloadId || \"N/A\"})`);\n    sendMessageToTab(tabId, downloadProgressMessage).catch(err => {\n      logger.logWarn(`Failed to send completion message to tab ${tabId}:`, err);\n    });\n  } else { // For other progress, pause, resume, or general updates\n    sendMessageToTab(tabId, downloadProgressMessage).catch(err => {\n      logger.logWarn(`Failed to send progress/status message to tab ${tabId}:`, err);\n    });\n  }\n}\n\nexport function chunkArray<T>(array: T[], chunkSize: number): T[][] {\n  if (chunkSize < 1) throw new Error(\"Invalid chunk size\");\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    const chunk = array.slice(i, i + chunkSize);\n    chunks.push(chunk);\n  }\n  return chunks;\n}\n// --- End Exported Utility Functions ---\n\n// --- Event Handlers (onBeforeSendHeaders, onBeforeRequest, onPageActionClicked, oauthTokenChanged, registerConfigChangeHandler) ---\nconst authRegex = new RegExp(\"OAuth (.+)\");\nconst followerIdRegex = new RegExp(\"/me/followings/(\\\\d+)\");\n\n// Restore onBeforeSendHeaders for Firefox & non-DNR environments\nonBeforeSendHeaders(\n  (details: chrome.webRequest.WebRequestHeadersDetails) => {\n    if (usesDeclarativeNetRequestForModification()) {\n      const oauthTokenFromStorage = getConfigValue(\"oauth-token\") as string | null;\n      if (details.requestHeaders) {\n        for (let i = 0; i < details.requestHeaders.length; i++) {\n          if (details.requestHeaders[i].name.toLowerCase() === \"authorization\") {\n            const authHeader = details.requestHeaders[i].value as string;\n            const result = authRegex.exec(authHeader);\n            if (result && result.length >= 2 && result[1] !== oauthTokenFromStorage) {\n              logger.logInfo(\"Sniffed and storing OAuth token from request header (all envs).\");\n              storeConfigValue(\"oauth-token\", result[1]);\n            }\n            break;\n          }\n        }\n      }\n      return {};\n    }\n\n    let requestHasAuth = false;\n    const oauthToken = getConfigValue(\"oauth-token\") as string | null;\n\n    if (details.requestHeaders) {\n      for (let i = 0; i < details.requestHeaders.length; i++) {\n        if (details.requestHeaders[i].name.toLowerCase() === \"authorization\") {\n          requestHasAuth = true;\n          const authHeader = details.requestHeaders[i].value as string;\n          const result = authRegex.exec(authHeader);\n          if (result && result.length >= 2 && result[1] !== oauthToken) {\n            logger.logInfo(\"Sniffed and storing OAuth token (Firefox/non-DNR).\");\n            storeConfigValue(\"oauth-token\", result[1]);\n          }\n          break;\n        }\n      }\n      if (!requestHasAuth && oauthToken) {\n        // logger.logDebug(`Adding OAuth token to request for ${details.url} (Firefox/non-DNR)`);\n        details.requestHeaders.push({\n          name: \"Authorization\",\n          value: \"OAuth \" + oauthToken,\n        });\n        return { requestHeaders: details.requestHeaders };\n      }\n    }\n    return {};\n  },\n  [\"*://api-v2.soundcloud.com/*\"],\n  [\"blocking\", \"requestHeaders\"]\n);\n\nonBeforeRequest(\n  (details: chrome.webRequest.WebRequestBodyDetails) => {\n    const url = new URL(details.url);\n    if (url.pathname === \"/connect/session\" && getConfigValue(\"oauth-token\") === null) {\n      logger.logInfo(\"User logged in - clearing potentially stale token.\");\n      storeConfigValue(\"oauth-token\", undefined);\n    } else if (url.pathname === \"/sign-out\") {\n      logger.logInfo(\"User logged out\");\n      storeConfigValue(\"oauth-token\", null);\n      storeConfigValue(\"user-id\", null);\n      storeConfigValue(\"followed-artists\", []);\n    } else if (url.pathname.startsWith(\"/me/followings/\")) {\n      const followerIdMatch = followerIdRegex.exec(url.pathname);\n      if (followerIdMatch && followerIdMatch.length === 2) {\n        const followerId = +followerIdMatch[1];\n        if (followerId) {\n          let followedArtists = (getConfigValue(\"followed-artists\") as number[] | null) || [];\n          if (details.method === \"POST\") {\n            if (!followedArtists.includes(followerId)) followedArtists.push(followerId);\n          } else if (details.method === \"DELETE\") {\n            followedArtists = followedArtists.filter((i) => i !== followerId);\n          }\n          storeConfigValue(\"followed-artists\", followedArtists);\n        }\n      }\n    } else {\n      const clientIdFromUrl = url.searchParams.get(\"client_id\");\n      if (clientIdFromUrl) {\n        const storedClientId = getConfigValue(\"client-id\") as string | null;\n        if (clientIdFromUrl !== storedClientId) {\n          logger.logInfo(`Found new client_id: ${clientIdFromUrl}. Storing it.`);\n          storeConfigValue(\"client-id\", clientIdFromUrl);\n        }\n      } else {\n        if (!usesDeclarativeNetRequestForModification()) {\n          const storedClientId = getConfigValue(\"client-id\") as string | null;\n          if (storedClientId) {\n            logger.logDebug(`Adding ClientId to ${details.url} via redirect (Firefox/non-DNR)`);\n            url.searchParams.append(\"client_id\", storedClientId);\n            return { redirectUrl: url.toString() };\n          }\n        }\n      }\n    }\n    return {};\n  },\n  [\"*://api-v2.soundcloud.com/*\", \"*://api-auth.soundcloud.com/*\"],\n  [\"blocking\"]\n);\n\nonPageActionClicked(() => {\n  openOptionsPage();\n});\n\nconst oauthTokenChanged = async (token: string | null | undefined) => {\n  if (!token) {\n    storeConfigValue(\"user-id\", null);\n    logger.logInfo(\"OAuth token cleared, user ID cleared.\");\n    return;\n  }\n  const user = await soundcloudApi.getCurrentUser();\n  if (!user) {\n    logger.logError(\"Failed to fetch currently logged in user (after token change/init)\");\n    return;\n  }\n  storeConfigValue(\"user-id\", user.id);\n  logger.logInfo(\"Logged in as\", user.username);\n  const followedArtistIds = await soundcloudApi.getFollowedArtistIds(user.id);\n  if (!followedArtistIds) {\n    logger.logError(\"Failed to fetch ids of followed artists\");\n    return;\n  }\n  storeConfigValue(\"followed-artists\", followedArtistIds);\n};\n\nregisterConfigChangeHandler(\"oauth-token\", async (newValue) => {\n  await updateAuthHeaderRule(newValue as string | null | undefined);\n  await oauthTokenChanged(newValue as string | null | undefined);\n});\n\nregisterConfigChangeHandler(\"client-id\", async (newClientId) => {\n  logger.logInfo(`client-id config changed to: ${newClientId}. Updating DNR rule.`);\n  await updateClientIdRule(newClientId as string | null | undefined);\n});\n\n"],"names":["RateLimitError","message","SoundCloudApi","Logger","fn","retries","initialDelayMs","contextString","waitTime","resolve","attempt","delay","error","finalErrorMsg","url","reqUrl","userId","data","trackIds","tracks","acc","cur","index","stream","extension","hls","regexResult","id","downloadObj","_error","artworkUrl","buffer","streamUrl","reportProgress","response","errorText","contentLength","total","loaded","chunks","reader","done","value","completeBuffer","view","offset","chunk","resp","errorMsg","json","FFMessageType","getMessageID","messageID","ERROR_NOT_LOADED","ERROR_TERMINATED","FFmpeg","#worker","#resolves","#rejects","#logEventCallbacks","#progressEventCallbacks","#registerHandlers","type","f","#send","trans","signal","reject","event","callback","classWorkerURL","config","args","timeout","ids","path","fsType","options","mountPoint","encoding","oldPath","newPath","FFFSType","ERROR_RESPONSE_BODY_READER","ERROR_INCOMPLETED_DOWNLOAD","HeaderContentLength","downloadWithProgress","cb","buf","received","delta","position","e","toBlobURL","mimeType","progress","blob","baseLogger","LogLevel","createAndLoadFFmpegInstance","instanceId","instanceLogger","newFfmpeg","coreBaseURL","getPathFromExtensionFile","coreJsPath","coreWasmPath","coreBlobURL","wasmBlobURL","logger","initialMaxFFmpegOperations","getConfigValue","MAX_CONCURRENT_OPERATIONS","ffmpegPool","taskQueue","poolInitialized","poolInitializationPromise","initializePool","loadPromises","i","loadedInstances","instance","_performRemux","instanceWrapper","task","taskId","inputBuffer","fileExtension","progressCallback","inputFilename","outputFilename","ffmpegProgressHandler","uInt8ArrayBuffer","slicedBuffer","bufferError","ffmpegArgs","lastReportedFFmpegProgress","currentFFmpegProgress","outputData","cleanupError","processQueue","availableInstanceWrapper","iw","taskToProcess","terminateError","poolIndex","newInstance","requestRemux","ffmpegProgress","err","preInitializeFFmpegPool","t","a","r","n","s","c","o","Mp3TagWriter","ID3Writer","title","artists","album","comment","trackNumber","year","grouping","artworkBuffer","ATOM_HEAD_LENGTH","ATOM_DATA_HEAD_LENGTH","ATOM_HEADER_LENGTH","Mp4","atom","atomsFound","moovAtom","duration","mvhdAtom","name","dataBuffer","buffers","bufferIndex","slice","levels","levelIndex","parent","childIndex","parentHeadLength","parentHeader","newParent","child","headerBuffer","concatArrayBuffers","parentAtom","existingIndex","lastChild","atoms","curPath","curName","curElem","children","childEnd","childOffset","childAtom","begin","end","dataView","length","headerBufferView","nameChars","dataNameChars","input","bufferView","chars","currentParent","pathSegments","segmentName","segmentAtom","newAtomOffset","newAtomLength","headLength","Mp4TagWriter","parseError","constructorError","processedBuffer","tagsSuccessfullyApplied","errorMessage","finalError","escapeStringRegexp","string","ArtistType","ArtistType2","RemixType","RemixType2","getRemixTypeFromString","stableSort","prop","b","MetadataExtractor","username","userPermalink","titleSplit","producerSplit","remixSplit","unsafeProducerSplit","featureSplit","user","artist","distinctArtists","result","extractArtists","artistNames","separators","_","artistSection","artistString","featureSection","artistsString","producerSection","featureSeparators","remixSection","remixTypeString","remixType","regex","names","promotions","sanitized","XRegExp","loweredInput","separator","Stream","_proto","listener","callbacks","_length","_i","destination","_extends","win","global","window_1","atob","window","decodeB64ToUint8Array","b64Text","decodedString","array","LineStream","nextNewline","TAB","parseByterange","byterangeString","match","attributeSeparator","keyvalue","parseAttributes","attributes","attrs","attr","parseResolution","resolution","split","ParseStream","line","mapper","mappedLine","newLine","key","subkey","clientAttributePattern","isHexaDecimal","isDecimalFloating","expression","customType","dataParser","segment","map","mapFn","camelCase","str","camelCaseKeys","setHoldBack","manifest","serverControl","targetDuration","partTargetDuration","tag","hb","phb","minTargetDuration","minPartDuration","Parser","opts","self","uris","currentUri","currentMap","hasParts","noop","defaultMediaGroups","widevineUuid","currentTimeline","lastByterangeEnd","lastPartByterangeEnd","dateRangeTags","entry","mediaGroup","rendition","def","byterange","mediaGroupType","lastProgramDateTime","programDateTime","segmentIndex","part","partIndex","hint","isPart","otherHint","report","required","dateRange","endOnNextYes","newDateInSeconds","attribute","dateRangeWithSameId","dateRangeToFind","addDef","v","val","currentVersion","targetVersion","identifier","missing","TrackError","trackId","soundcloudApi","isValidTrack","track","isTranscodingDetails","detail","getTranscodingDetails","details","mpegStreams","transcoding","streams","downloadTrack","albumName","playlistNameString","downloadDetails","originalDownloadUrl","transcodingDetailsResult","downloadDetail","hlsUsed","resolvedStreamUrl","resolvedExtension","finalStreamUrl","finalHlsFlag","downloadData","browserDownloadIdFromHandler","handleDownload","titleString","rawFilenameBase","streamBuffer","streamHeaders","saveAs","defaultDownloadLocation","shouldSkipExisting","determinedContentType","finalDownloadFilename","objectUrlToRevoke","potentialDownloadFilename","extractor","remixers","remixerNames","sanitizeFilenameForDownload","checkExtension","sanitizedPlaylistName","pathPrefix","trackIdKey","trackDownloadHistory","loadConfigValue","previousDownload","fakeDownloadId","exactQuery","exactMatches","searchDownloads","escapedPathPrefix","escapedRawFilenameBase","regexQuery","regexMatches","titleArtistQuery","titleArtistMatches","completedDownloads","d","download","storeConfigValue","originalStreamBuffer","playlistBuffer","initialHeaders","p","playlistText","parser","initSegmentBuffer","segmentWithMap","seg","initSegmentFullUrl","initData","segmentUris","segments","totalSegments","segmentProgressStart","segmentProgressRange","segmentData","p_segment","rateLimitMs","buffersToConcat","handleFFmpegInternalProgress","ffmpegInternalProgress","overallProgressUpdate","ffmpegError","taggedBuffer","writer","bufferForTagging","actualArtworkUrl","artworkResponse","fetchedArtworkBuffer","artworkError","tagWriterResult","bufferToSave","blobOptions","downloadBlob","isServiceWorkerContext","createURLFromBlob","base","playlistFolder","justTheFilename","urlToDownload","browserDownloadId","downloadToFile","histKey","history","saveError","Semaphore","count","nextTaskResolve","DOWNLOAD_SET","DOWNLOAD","DOWNLOAD_SET_RANGE","PAUSE_DOWNLOAD","RESUME_DOWNLOAD","MessageHandlerError","pausedDownloads","initialMaxConcurrentDownloads","downloadTrackSemaphore","handleIncomingMessage","sender","receivedMessageForLog","tabId","downloadId","currentFullConfig","loadConfiguration","nonSecretConfig","configKeys","testMessagePayload","sendMessageToTab","ackSetPayload","set","immediateResponse","progresses","browserDownloadIds","reportPlaylistProgress","browserDlId","totalProgress","latestBrowserDlId","sendDownloadProgress","setAlbumName","setPlaylistName","trackIdChunks","chunkArray","currentTrackIdChunk","encounteredError","lastError","trackIdChunk","keyedTracks","downloads","originalIndex","trackDownloadPromise","asyncError","errorToSend","ackDownloadPayload","originalSkipSetting","reportTrackProgress","browserDlIdFromCallback","forceRedownload","normalizedTitle","regexPattern","eraseDownloadHistoryEntry","actualBrowserDownloadId","downloadError","rangeMessage","ackRangePayload","start","totalTracks","validatedStart","validatedEnd","tracksToDownload","isAlbum","averageProgress","trackIdChunkSize","tracksInChunk","trackInfo","trackError","pauseMessage","resumeMessage","getExtensionManifest","updateAuthHeaderRule","oauthToken","setAuthHeaderRule","updateClientIdRule","clientId","setClientIdRule","onMessage","initialOauthToken","initialClientId","oauthTokenChanged","status","callStack","fallbackMessage","downloadProgressMessage","chunkSize","authRegex","followerIdRegex","onBeforeSendHeaders","usesDeclarativeNetRequestForModification","oauthTokenFromStorage","authHeader","requestHasAuth","onBeforeRequest","followerIdMatch","followerId","followedArtists","clientIdFromUrl","storedClientId","onPageActionClicked","openOptionsPage","token","followedArtistIds","registerConfigChangeHandler","newValue","newClientId"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,11,14,16,17,18,19,20]}