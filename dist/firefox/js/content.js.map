{"version":3,"file":"content.js","sources":["../../../src/content/domObserver.ts","../../../src/content/content.ts"],"sourcesContent":["import { Logger } from \"../utils/logger\";\n\nexport interface ObserverEvent {\n  name?: string;\n  selector: string;\n  callback: (node: Element) => void;\n}\n\nexport class DomObserver {\n  private observer: MutationObserver;\n  private events: ObserverEvent[] = [];\n  private unqiueNodeId: number = 0;\n  private logger: Logger;\n\n  constructor() {\n    this.observer = new MutationObserver((mutations) => mutations.forEach((mutation) => this.handleMutation(mutation)));\n    this.logger = Logger.create(\"Observer\");\n  }\n\n  start(node: Node) {\n    this.observer.observe(node, { subtree: true, attributes: true, childList: true });\n\n    this.logger.logDebug(\"Started\");\n  }\n\n  stop() {\n    this.observer.disconnect();\n\n    this.logger.logDebug(\"Stopped\");\n  }\n\n  addEvent(event: ObserverEvent) {\n    if (!event.selector) {\n      this.logger.logWarn(\"Selector was not specified\");\n\n      return;\n    }\n\n    if (!event.callback) {\n      this.logger.logWarn(\"Callback was not specified\");\n\n      return;\n    }\n\n    this.events.push(event);\n\n    this.logger.logDebug(\"Event added\", event);\n  }\n\n  removeEvent(name: string) {\n    this.events = this.events.filter((event) => event.name !== name);\n  }\n\n  private handleMutation(mutation: MutationRecord) {\n    const target = mutation.target;\n    const newNodes = mutation.addedNodes ?? [];\n\n    for (const event of this.events) {\n      if (newNodes.length > 0) {\n        this.handleNodes(newNodes, event);\n      } else if (mutation.type === \"attributes\") {\n        this.handleNodes([target], event, false);\n      }\n    }\n  }\n\n  private handleNodes(nodes: any[] | NodeList, event: ObserverEvent, recursive: boolean = true) {\n    if (!nodes) return;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (this.matchesSelectors(node, event.selector)) {\n        // We only want to emmit an event once\n        if (node._id !== undefined) return;\n\n        node._id = ++this.unqiueNodeId;\n        event.callback(node);\n      }\n\n      if (recursive && node.childNodes?.length > 0) this.handleNodes(node.childNodes, event);\n    }\n  }\n\n  private matchesSelectors(element: any, selectors: string) {\n    return element && element instanceof HTMLElement && element.matches(selectors);\n  }\n}\n","import { DomObserver, ObserverEvent } from \"./domObserver\";\nimport { Logger } from \"../utils/logger\";\nimport { sendMessageToBackend, onMessage, getPathFromExtensionFile } from \"../compatibility/compatibilityStubs\";\nimport { registerConfigChangeHandler, loadConfiguration, setOnConfigValueChanged, configKeys, Config } from \"../settings/config\";\nimport { determineIfUrlIsSet } from \"../utils/browser\";\n\n// --- CSS for Range Modal ---\nconst modalCss = `\n  #scdl-range-modal {\n    display: none;\n    position: fixed;\n    z-index: 10000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    overflow: auto;\n    background-color: rgba(0,0,0,0.6);\n  }\n  #scdl-range-modal-content {\n    background-color: #fefefe;\n    margin: 15% auto;\n    padding: 20px;\n    border: 1px solid #888;\n    width: 80%;\n    max-width: 350px;\n    border-radius: 5px;\n    color: #333; /* Ensure text is visible */\n  }\n  #scdl-range-modal label {\n    display: block;\n    margin-bottom: 5px;\n  }\n  #scdl-range-modal input[type=\"number\"] {\n    width: 60px;\n    padding: 5px;\n    margin-bottom: 15px;\n    margin-right: 10px;\n    border: 1px solid #ccc;\n    border-radius: 3px;\n  }\n  #scdl-range-modal-actions button {\n    padding: 8px 15px;\n    margin-left: 10px;\n    border: none;\n    border-radius: 3px;\n    cursor: pointer;\n  }\n  #scdl-range-modal-download {\n    background-color: #ff5419;\n    color: white;\n  }\n  #scdl-range-modal-cancel {\n    background-color: #ccc;\n  }\n  #scdl-range-modal-error {\n    color: red;\n    font-size: 0.9em;\n    margin-top: 10px;\n    display: none; /* Hidden by default */\n  }\n  .sc-button-download {\n    transition: background-color 0.5s ease-out;\n  }\n`;\n// -------------------------\n\n// --- Modal HTML Structure ---\nlet modalElement: HTMLDivElement | null = null;\nfunction createModal() {\n  if (document.getElementById(\"scdl-range-modal\")) return;\n\n  const style = document.createElement(\"style\");\n  style.textContent = modalCss;\n  document.head.appendChild(style);\n\n  modalElement = document.createElement(\"div\");\n  modalElement.id = \"scdl-range-modal\";\n  modalElement.innerHTML = `\n    <div id=\"scdl-range-modal-content\">\n      <h4>Download Playlist Range</h4>\n      <label for=\"scdl-range-from\">From track:</label>\n      <input type=\"number\" id=\"scdl-range-from\" name=\"from\" min=\"1\" value=\"1\">\n      <label for=\"scdl-range-to\">To track:</label>\n      <input type=\"number\" id=\"scdl-range-to\" name=\"to\" min=\"1\" value=\"\"><br>\n      <small>(Leave \"To\" blank to download until the end)</small>\n      <div id=\"scdl-range-modal-error\"></div>\n      <div id=\"scdl-range-modal-actions\" style=\"text-align: right; margin-top: 15px;\">\n        <button id=\"scdl-range-modal-cancel\">Cancel</button>\n        <button id=\"scdl-range-modal-download\">Download Selection</button>\n      </div>\n    </div>\n  `;\n  document.body.appendChild(modalElement);\n\n  // Add listeners for the modal buttons\n  document.getElementById(\"scdl-range-modal-cancel\").addEventListener(\"click\", hideModal);\n  modalElement.addEventListener(\"click\", (e) => {\n    // Close if clicking outside the content\n    if (e.target === modalElement) {\n      hideModal();\n    }\n  });\n}\n\nfunction showModal(mainDownloadButton: HTMLButtonElement, onDownloadClick: (start: number, end: number | null) => void) {\n  if (!modalElement) createModal();\n\n  const fromInput = document.getElementById(\"scdl-range-from\") as HTMLInputElement;\n  const toInput = document.getElementById(\"scdl-range-to\") as HTMLInputElement;\n  const errorDiv = document.getElementById(\"scdl-range-modal-error\");\n\n  // Reset fields and error message\n  fromInput.value = \"1\";\n  toInput.value = \"\";\n  errorDiv.textContent = \"\";\n  errorDiv.style.display = \"none\";\n\n  // Remove previous listener and add new one to avoid duplicates / stale closures\n  const downloadBtn = document.getElementById(\"scdl-range-modal-download\");\n  const newDownloadBtn = downloadBtn.cloneNode(true) as HTMLButtonElement;\n  downloadBtn.parentNode.replaceChild(newDownloadBtn, downloadBtn);\n\n  newDownloadBtn.addEventListener(\"click\", () => {\n    const start = parseInt(fromInput.value, 10);\n    const endStr = toInput.value;\n    const end = endStr ? parseInt(endStr, 10) : null; // null means download to end\n\n    errorDiv.textContent = \"\"; // Clear previous error\n    errorDiv.style.display = \"none\";\n\n    if (isNaN(start) || start < 1) {\n      errorDiv.textContent = \"Invalid \\\"From\\\" number.\";\n      errorDiv.style.display = \"block\";\n      return;\n    }\n    if (end !== null && (isNaN(end) || end < start)) {\n      errorDiv.textContent = \"Invalid \\\"To\\\" number. Must be greater than or equal to \\\"From\\\".\";\n      errorDiv.style.display = \"block\";\n      return;\n    }\n\n    // Validation passed, call the provided handler\n    onDownloadClick(start, end);\n    hideModal();\n\n    // Trigger the main button's preparing state visually\n    setButtonText(mainDownloadButton, \"Preparing...\");\n    mainDownloadButton.style.cursor = \"default\";\n    mainDownloadButton.onclick = null;\n\n  });\n\n  modalElement.style.display = \"block\";\n}\n\nfunction hideModal() {\n  if (modalElement) {\n    modalElement.style.display = \"none\";\n  }\n}\n// -----------------------------\n\ninterface DownloadButton {\n  elem: HTMLButtonElement;\n  onClick: any;\n  state: \"Idle\" | \"Preparing\" | \"Downloading\" | \"Pausing\" | \"Paused\" | \"Resuming\" | \"Finishing\" | \"Downloaded\" | \"Error\";\n  resetTimer?: number;\n  originalUrl?: string; // Store the URL for resuming/pausing\n  lastProgressTime?: number; // Add timestamp for progress tracking\n  browserDownloadId?: number; // Store browser's numeric downloadId for matching\n}\n\ntype KeyedButtons = { [key: string]: DownloadButton & { resetTimer?: number } };\ntype OnButtonClicked = (downloadId: string) => Promise<any>;\n\nlet observer: DomObserver | null = null;\nconst logger = Logger.create(\"ContentScript\");\n\n// --- Wrapper for sendMessageToBackend to log messages ---\nconst originalSendMessageToBackend = sendMessageToBackend;\nconst loggedSendMessageToBackend = (message: any, callContext?: string): Promise<any> => {\n  let messageToLog = {};\n  try {\n    messageToLog = JSON.parse(JSON.stringify(message));\n  } catch (_e) {\n    messageToLog = { errorParsingMessage: true, originalType: message?.type };\n  }\n  logger.logDebug(`[ContentScript sendMessageToBackend CALLED [Context: ${callContext || \"Unknown\"}] Message:]`, messageToLog);\n\n  if (message && typeof message === \"object\") {\n    const typesRequiringId = [\"DOWNLOAD\", \"DOWNLOAD_SET\", \"DOWNLOAD_SET_RANGE\", \"PAUSE_DOWNLOAD\", \"RESUME_DOWNLOAD\"];\n    if (typesRequiringId.includes(message.type) && (!message.downloadId || message.downloadId === undefined || message.downloadId === \"undefined\")) {\n      const error = new Error(`CRITICAL: Prevented sending message with type ${message.type} and missing downloadId!`);\n      logger.logError(\"[ContentScript loggedSendMessageToBackend]\", error.message, { message: messageToLog, callContext });\n      return Promise.reject(error);\n    }\n    if (!message.timestamp) message.timestamp = Date.now();\n  }\n  return originalSendMessageToBackend(message);\n};\n// --- End Wrapper ---\n\nconst downloadButtons: KeyedButtons = {};\n\nconst setButtonText = (button: HTMLButtonElement, text: string, title?: string) => {\n  button.innerText = text;\n\n  button.title = title ?? text;\n};\n\nconst resetButtonBackground = (button: HTMLButtonElement) => {\n  // Ensure styles are fully reset, important if paused state had specific colors\n  button.style.backgroundColor = \"\";\n  button.style.background = \"\";\n  button.style.color = \"\"; // Reset text color if changed\n};\n\nconst handleMessageFromBackgroundScript = (messagePayload: any, sender: any): Promise<any> => {\n  const uniqueCallId = crypto.randomUUID().substring(0, 8);\n  const currentButtonKeys = Object.keys(downloadButtons);\n  let payloadString = \"<payload_serialization_error>\";\n  try { payloadString = JSON.stringify(messagePayload); } catch { /* ignore */ }\n  let senderString = \"<sender_serialization_error>\";\n  try { senderString = JSON.stringify(sender); } catch { /* ignore */ }\n\n  logger.logDebug(`[HANDLE_MSG_FROM_BG_ENTRY_POINT CALL_ID: ${uniqueCallId}] Invoked. Payload: ${payloadString}. Sender: ${senderString}. Current downloadButton keys: ${currentButtonKeys.join(\",\") || \"none\"}`);\n\n  const relevantKeys = [\"downloadId\", \"progress\", \"error\", \"status\", \"browserDownloadId\", \"originalDownloadId\", \"completionWithoutId\", \"completed\", \"success\", \"timestamp\", \"scdl_test_message\"];\n  const messageKeys = Object.keys(messagePayload || {});\n  const isRelevantMessage = messageKeys.some(key => relevantKeys.includes(key));\n\n  if (!isRelevantMessage && messageKeys.length > 0) {\n    logger.logWarn(\"[HANDLE_MSG_FROM_BG] Discarding irrelevant message by key filter. Payload:\", JSON.parse(JSON.stringify(messagePayload)));\n    return Promise.resolve({ handled: false, reason: \"Irrelevant message\" });\n  }\n  if (isRelevantMessage) {\n    logger.logDebug(\"[HANDLE_MSG_FROM_BG] Relevant message PASSED initial filter. Payload:\", JSON.parse(JSON.stringify(messagePayload)));\n  }\n\n  const { downloadId: receivedDownloadIdFromPayload, progress, error, status, completionWithoutId, completed, timestamp, browserDownloadId, originalDownloadId: originalIdFromPayload } = messagePayload;\n\n  let finalDownloadId: string | undefined;\n\n  if (originalIdFromPayload) {\n    finalDownloadId = originalIdFromPayload;\n    logger.logDebug(`[CS_FID_LOGIC CALL_ID: ${uniqueCallId}] finalDownloadId set from message.originalDownloadId: ${finalDownloadId}`);\n  } else if (receivedDownloadIdFromPayload) {\n    finalDownloadId = receivedDownloadIdFromPayload;\n    logger.logDebug(`[CS_FID_LOGIC CALL_ID: ${uniqueCallId}] finalDownloadId set from message.downloadId: ${finalDownloadId}`);\n  } else {\n    logger.logWarn(`[CS_FID_LOGIC CALL_ID: ${uniqueCallId}] Message has neither originalDownloadId nor downloadId at the top level of payload.`);\n    if (messagePayload && messagePayload.error && messagePayload.originalMessage && typeof messagePayload.originalMessage.downloadId === \"string\") {\n      finalDownloadId = messagePayload.originalMessage.downloadId;\n      logger.logInfo(`[CS_FID_LOGIC CALL_ID: ${uniqueCallId}] finalDownloadId recovered from message.originalMessage.downloadId due to error payload from bridge: ${finalDownloadId}`);\n    }\n  }\n\n  if (!finalDownloadId && browserDownloadId) {\n    const matchedDownloadIds = Object.keys(downloadButtons).filter(id => downloadButtons[id].browserDownloadId === browserDownloadId);\n    if (matchedDownloadIds.length === 1) {\n      finalDownloadId = matchedDownloadIds[0];\n      logger.logDebug(`[CS_FID_LOGIC] finalDownloadId set from browserDownloadId match: ${finalDownloadId}`);\n      if (progress === 101 || completed === true) {\n        const buttonData = downloadButtons[finalDownloadId!];\n        resetButtonBackground(buttonData.elem);\n        buttonData.elem.style.backgroundColor = \"#19a352\";\n        setButtonText(buttonData.elem, \"Downloaded!\");\n        buttonData.elem.title = \"Downloaded successfully (matched by browser downloadId)\";\n        buttonData.elem.onclick = null;\n        buttonData.state = \"Downloaded\";\n        buttonData.resetTimer = window.setTimeout(() => runResetLogic(finalDownloadId!), 10000);\n        logger.logDebug(`[CS_FID_LOGIC] Updated button ${finalDownloadId} to Downloaded state from browserDownloadId match`);\n        return Promise.resolve({ handled: true, id: finalDownloadId });\n      }\n    } else if (matchedDownloadIds.length > 1) {\n      logger.logWarn(`[CS_FID_LOGIC] Found multiple (${matchedDownloadIds.length}) buttons with browserDownloadId=${browserDownloadId}. Cannot reliably map message.`);\n    }\n  }\n\n  if (!finalDownloadId || finalDownloadId === \"undefined_completion\" || completionWithoutId) {\n    logger.logWarn(\"[CS_GENERIC_MATCH_ENTRY] Entering generic/undefined ID matching. \" + `finalDownloadId: ${finalDownloadId}, is_undefined_completion: ${finalDownloadId === \"undefined_completion\"}, ` + `completionWithoutId flag: ${completionWithoutId}. Message payload:`, JSON.parse(JSON.stringify(messagePayload)));\n    const allPotentiallyActiveStates = [\"Downloading\", \"Preparing\", \"Finishing\", \"Pausing\", \"Resuming\"];\n    const currentActiveDownloads = Object.keys(downloadButtons).filter(id => allPotentiallyActiveStates.includes(downloadButtons[id].state));\n    const isMinimalMessage = progress === undefined && status === undefined && completed !== true && completionWithoutId !== true && error === undefined && typeof messagePayload === \"object\" && Object.keys(messagePayload).length <= (originalIdFromPayload ? 5 : (messagePayload.type ? 2 : 1));\n    if (currentActiveDownloads.length === 0 && isMinimalMessage) {\n      logger.logWarn(`[HANDLE_MSG_FROM_BG] Received minimal message (keys: ${Object.keys(messagePayload).join(\", \") || \"none\"}) with no active downloads. Discarding.`, { message: messagePayload });\n      return Promise.resolve({ handled: false, reason: \"Minimal message, no active downloads\" });\n    }\n    logger.logWarn(`[HANDLE_MSG_FROM_BG] Received message (keys: ${Object.keys(messagePayload).join(\", \") || \"none\"}) without a usable finalDownloadId or it is a generic completion. Attempting to match with active downloads (found ${currentActiveDownloads.length} using states: ${allPotentiallyActiveStates.join(\", \")}).`);\n    const isCompletionMessageEvaluation = progress === 101 || progress === 102 || completed === true || completionWithoutId === true || (status === undefined && error === undefined && typeof messagePayload === \"object\" && Object.keys(messagePayload).length <= (originalIdFromPayload ? 5 : 4));\n    if (isCompletionMessageEvaluation) {\n      const activeIdsForCompletionLogic = currentActiveDownloads;\n      logger.logWarn(`[HANDLE_MSG_FROM_BG] Attempting to match as completion message. Found ${activeIdsForCompletionLogic.length} candidates using states: ${allPotentiallyActiveStates.join(\", \")}.`);\n      if (activeIdsForCompletionLogic.length === 1) {\n        const matchedId = activeIdsForCompletionLogic[0];\n        logger.logWarn(`[HANDLE_MSG_FROM_BG] Matched undefined/generic ID message to single active download: ${matchedId}`);\n        finalDownloadId = matchedId;\n        const isActuallyComplete = progress === 101 || progress === 102 || completed === true || completionWithoutId === true;\n        if (isActuallyComplete) {\n          const buttonData = downloadButtons[finalDownloadId!];\n          resetButtonBackground(buttonData.elem);\n          buttonData.elem.style.backgroundColor = \"#19a352\";\n          setButtonText(buttonData.elem, \"Downloaded!\");\n          buttonData.elem.title = \"Downloaded successfully (auto-matched generic completion)\";\n          buttonData.elem.onclick = null;\n          buttonData.state = \"Downloaded\";\n          buttonData.resetTimer = window.setTimeout(() => runResetLogic(finalDownloadId!), 10000);\n          logger.logWarn(`[HANDLE_MSG_FROM_BG] Updated button ${finalDownloadId} to Downloaded state from matched generic completion message.`);\n          return Promise.resolve({ handled: true, id: finalDownloadId });\n        }\n      } else if (activeIdsForCompletionLogic.length > 1 && timestamp) {\n        let mostRecentId = null; let mostRecentTime = 0;\n        activeIdsForCompletionLogic.forEach(id => { const lastTime = downloadButtons[id].lastProgressTime || 0; if (lastTime > mostRecentTime) { mostRecentTime = lastTime; mostRecentId = id; } });\n        if (mostRecentId) {\n          logger.logWarn(`[HANDLE_MSG_FROM_BG] Matched undefined/generic ID to most recent active download by timestamp: ${mostRecentId}`);\n          finalDownloadId = mostRecentId;\n          const isActuallyComplete = progress === 101 || progress === 102 || completed === true || completionWithoutId === true;\n          if (isActuallyComplete) {\n            const buttonData = downloadButtons[finalDownloadId!];\n            resetButtonBackground(buttonData.elem); buttonData.elem.style.backgroundColor = \"#19a352\"; setButtonText(buttonData.elem, \"Downloaded!\");\n            buttonData.elem.title = \"Downloaded successfully (auto-matched generic completion by timestamp)\"; buttonData.elem.onclick = null; buttonData.state = \"Downloaded\";\n            buttonData.resetTimer = window.setTimeout(() => runResetLogic(finalDownloadId!), 10000);\n            logger.logWarn(`[HANDLE_MSG_FROM_BG] Updated button ${finalDownloadId} to Downloaded state from timestamp-matched generic completion message.`);\n            return Promise.resolve({ handled: true, id: finalDownloadId });\n          }\n        } else { logger.logWarn(`[HANDLE_MSG_FROM_BG] Found ${activeIdsForCompletionLogic.length} active downloads, but couldn't match generic completion message by timestamp.`); }\n      } else if (activeIdsForCompletionLogic.length > 0) {\n        logger.logWarn(`[HANDLE_MSG_FROM_BG] Found ${activeIdsForCompletionLogic.length} active downloads, can't match generic completion message reliably by unique or timestamp.`);\n      } else { logger.logWarn(\"[HANDLE_MSG_FROM_BG] No active downloads to match generic completion message to.\"); }\n    }\n    if (!finalDownloadId) {\n      if (currentActiveDownloads.length === 0 && isMinimalMessage) {\n        logger.logWarn(\"[HANDLE_MSG_FROM_BG] Could not determine finalDownloadId for minimal message (no active downloads) after matching attempts. Discarding.\", { message: messagePayload });\n      } else {\n        logger.logWarn(\"[HANDLE_MSG_FROM_BG] Could not determine finalDownloadId from generic message after all attempts. Discarding.\", { message: messagePayload });\n      }\n      return Promise.resolve({ handled: false, reason: \"Could not determine finalDownloadId from generic message\" });\n    }\n  }\n\n  if (!finalDownloadId) {\n    logger.logDebug(\"[HANDLE_MSG_FROM_BG] CRITICAL: finalDownloadId is null/undefined after all matching attempts. Discarding message.\", messagePayload);\n    return Promise.resolve({ handled: false, reason: \"finalDownloadId null after all matching\" });\n  }\n  const buttonData = downloadButtons[finalDownloadId!];\n  if (!buttonData) {\n    // Check if this is a late finalization message for an already cleaned-up button\n    const isErrorObject = typeof messagePayload.error === \"object\" && messagePayload.error !== null;\n    const isErrorString = typeof messagePayload.error === \"string\" && messagePayload.error !== \"\";\n    const isLateFinalization = (messagePayload.progress !== undefined && messagePayload.progress >= 101 && messagePayload.progress <= 102) ||\n      messagePayload.completed === true ||\n      isErrorObject || isErrorString;\n\n    if (isLateFinalization) {\n      logger.logInfo(`[HANDLE_MSG_FROM_BG CALL_ID: ${uniqueCallId}] Button data not found for finalDownloadId: ${finalDownloadId}, but message is a late finalization. Likely already cleaned up. Message:`, JSON.parse(JSON.stringify(messagePayload)));\n      return Promise.resolve({ handled: true, reason: \"Button data not found, late finalization message\" });\n    } else {\n      // It's not a finalization message, so the warning is more relevant\n      const currentKeysForWarning = Object.keys(downloadButtons);\n      let payloadStringForWarning = \"<payload_serialization_error_in_warning>\";\n      try { payloadStringForWarning = JSON.stringify(messagePayload); } catch { /* ignore */ }\n      logger.logWarn(`[HANDLE_MSG_FROM_BG CALL_ID: ${uniqueCallId}] Button data not found for finalDownloadId: ${finalDownloadId}. Message: ${payloadStringForWarning}. All downloadButton keys at this point: ${currentKeysForWarning.join(\",\") || \"none\"}`);\n      return Promise.resolve({ handled: false, reason: \"Button data not found for finalDownloadId\" });\n    }\n  }\n  const { elem: downloadButton, resetTimer, state: currentState } = buttonData;\n  logger.logDebug(`[HANDLE_MSG_FROM_BG] Processing for finalDownloadId: ${finalDownloadId}. Current button state: ${currentState}. Message progress: ${progress}, success: ${messagePayload.success}`);\n\n  // If button is already marked as Downloaded or Error, ignore further progress/status updates for this ID\n  // unless it's a specific re-activation or a new command.\n  if (currentState === \"Downloaded\" || currentState === \"Error\") {\n    // Allow specific messages like a new download attempt (which would have a new ID or different context)\n    // For now, if it's just progress or a simple status for an already finalized download, log and ignore.\n    if (progress !== undefined || status !== undefined) { // status might be part of a pause/resume attempt on a finalized button\n      logger.logWarn(`[HANDLE_MSG_FROM_BG] Received message for already finalized downloadId ${finalDownloadId} (state: ${currentState}). Ignoring for UI update. Message:`, messagePayload);\n      return Promise.resolve({ handled: true, id: finalDownloadId, reason: `Already in ${currentState} state` });\n    }\n  }\n\n  // Check for late/redundant simple acknowledgments\n  const isSimpleAck = messagePayload.error === \"\" &&\n    messagePayload.success === undefined &&\n    progress === undefined &&\n    status === undefined &&\n    completed === undefined;\n\n  if (isSimpleAck && currentState !== \"Preparing\" && originalIdFromPayload === finalDownloadId) {\n    // It's a simple ack, but we're not in 'Preparing' state anymore.\n    // This might be a late/redundant ack from the background after an initial command.\n    // No specific UI action needed if we're past the 'Preparing' stage for this type of message.\n    logger.logDebug(`[HANDLE_MSG_FROM_BG] Received redundant simple acknowledgment for ${finalDownloadId} while button state is ${currentState}. Ignoring for UI update. Payload:`, JSON.parse(JSON.stringify(messagePayload)));\n    // We still need to return a promise, similar to how other branches do.\n    // Indicate it was handled, but no state change from this specific redundant message.\n    return Promise.resolve({ handled: true, id: finalDownloadId, reason: \"Redundant simple ack, state not Preparing\" });\n  }\n\n  if (messagePayload.success === true && originalIdFromPayload === finalDownloadId) {\n    logger.logDebug(`[CS_DEBUG_ACK_INITIAL_MATCH] Early ack initial match for ${finalDownloadId}. Current button state: ${currentState}. Full Message:`, JSON.parse(JSON.stringify(messagePayload)));\n    if (currentState === \"Preparing\") {\n      logger.logDebug(\"[CS_DEBUG_ACK_CONDITIONS] currentState is Preparing.\");\n      if (progress === undefined) {\n        logger.logDebug(\"[CS_DEBUG_ACK_CONDITIONS] message.progress is undefined.\");\n        if (status === undefined) {\n          logger.logDebug(\"[CS_DEBUG_ACK_CONDITIONS] message.status is undefined.\");\n          if (completed === undefined) {\n            logger.logDebug(\"[CS_DEBUG_ACK_CONDITIONS] message.completed is undefined.\");\n            if (!error) {\n              logger.logDebug(\"[CS_DEBUG_ACK_CONDITIONS] !message.error is true. ALL PRE-CONDITIONS FOR STATE TRANSITION MET.\");\n            } else { logger.logWarn(`[CS_DEBUG_ACK_FAIL_FINAL_BLOCK] !message.error FAILED. Error: ${error}`); }\n          } else { logger.logWarn(`[CS_DEBUG_ACK_FAIL_FINAL_BLOCK] message.completed FAILED. Was: ${completed}`); }\n        } else { logger.logWarn(`[CS_DEBUG_ACK_FAIL_FINAL_BLOCK] message.status FAILED. Was: ${status}`); }\n      } else { logger.logWarn(`[CS_DEBUG_ACK_FAIL_FINAL_BLOCK] message.progress FAILED. Was: ${progress}`); }\n    } else { logger.logWarn(`[CS_DEBUG_ACK_FAIL_FINAL_BLOCK] currentState was NOT Preparing. Was: ${currentState}`); }\n  }\n\n  // Adjusted condition: Accept if (success===true AND no error) OR (error===\"\" AND success is undefined/not explicitly false)\n  if (((messagePayload.success === true && !error) || (messagePayload.error === \"\" && messagePayload.success === undefined)) && originalIdFromPayload === finalDownloadId && currentState === \"Preparing\" && progress === undefined && status === undefined && completed === undefined) {\n    logger.logDebug(`[HANDLE_MSG_FROM_BG] Initial command success for ${finalDownloadId}. Transitioning to Downloading state.`);\n    setButtonText(downloadButton, \"Downloading... (Click to Pause)\");\n    downloadButton.style.background = \"linear-gradient(90deg, #ff5419 0%, transparent 0%)\";\n    downloadButton.style.cursor = \"pointer\";\n    downloadButton.onclick = createPauseResumeHandler(finalDownloadId!);\n    downloadButtons[finalDownloadId!].state = \"Downloading\";\n    downloadButtons[finalDownloadId!].lastProgressTime = Date.now();\n  } else if (progress === 101) {\n    logger.logDebug(`[HANDLE_MSG_FROM_BG] Download complete (101) for finalDownloadId=${finalDownloadId}`);\n    resetButtonBackground(downloadButton);\n    downloadButton.style.backgroundColor = \"#19a352\";\n    setButtonText(downloadButton, \"Downloaded!\");\n    downloadButton.title = \"Downloaded successfully\";\n    downloadButton.onclick = null;\n    downloadButtons[finalDownloadId!].state = \"Downloaded\";\n    downloadButtons[finalDownloadId!].resetTimer = window.setTimeout(() => runResetLogic(finalDownloadId!), 10000);\n  } else if (progress === 102) {\n    logger.logDebug(`[HANDLE_MSG_FROM_BG] Download complete with errors (102) for finalDownloadId=${finalDownloadId}`);\n    resetButtonBackground(downloadButton); downloadButton.style.backgroundColor = \"gold\"; downloadButton.style.color = \"#333\";\n    setButtonText(downloadButton, \"Downloaded!\"); downloadButton.title = error || \"Some tracks failed to download\"; downloadButton.onclick = null;\n    downloadButtons[finalDownloadId!].state = \"Downloaded\"; downloadButtons[finalDownloadId!].resetTimer = window.setTimeout(() => runResetLogic(finalDownloadId!), 30000);\n  } else if (status === \"Paused\") {\n    logger.logDebug(`[HANDLE_MSG_FROM_BG] Button state updated to Paused, finalDownloadId=${finalDownloadId}`);\n    resetButtonBackground(downloadButton); setButtonText(downloadButton, \"Paused (Click to Resume)\");\n    downloadButton.style.cursor = \"pointer\"; downloadButton.onclick = createPauseResumeHandler(finalDownloadId!);\n    downloadButtons[finalDownloadId!].state = \"Paused\";\n  } else if (status === \"Resuming\") {\n    logger.logDebug(`[HANDLE_MSG_FROM_BG] Button state updated to Resuming, finalDownloadId=${finalDownloadId}`);\n    setButtonText(downloadButton, \"Resuming...\"); downloadButton.style.cursor = \"default\"; downloadButton.onclick = null;\n    downloadButtons[finalDownloadId!].state = \"Resuming\";\n  } else if (progress === 100 || (progress > 100 && progress < 101)) {\n    if (currentState !== \"Paused\" && currentState !== \"Pausing\" && currentState !== \"Resuming\") {\n      logger.logDebug(`[HANDLE_MSG_FROM_BG] Button state updated to Finishing, finalDownloadId=${finalDownloadId}`);\n      setButtonText(downloadButton, \"Finishing...\"); downloadButton.style.background = \"linear-gradient(90deg, #ff5419 100%, transparent 0%)\";\n      downloadButton.onclick = null; downloadButtons[finalDownloadId!].state = \"Finishing\";\n    }\n  } else if (progress !== undefined && progress >= 0 && progress < 100) {\n    // If the button is currently in a \"Pausing\" or \"Paused\" state (due to user click),\n    // ignore incoming progress updates that reflect the \"Downloading\" state to prevent flicker.\n    if (currentState === \"Pausing\" || currentState === \"Paused\") {\n      logger.logDebug(`[HANDLE_MSG_FROM_BG] Progress update (${progress}%) for ${finalDownloadId} received while state is '${currentState}'. Ignoring UI update to prevent flicker.`);\n      // Optionally, still update lastProgressTime if desired, even if UI doesn't change:\n      // if (downloadButtons[finalDownloadId!]) {\n      //   downloadButtons[finalDownloadId!].lastProgressTime = Date.now();\n      // }\n      return Promise.resolve({ handled: true, id: finalDownloadId, reason: \"Ignoring download progress while pausing/paused\" });\n    }\n\n    logger.logDebug(`[HANDLE_MSG_FROM_BG] Button state updated to Downloading (${progress}%), finalDownloadId=${finalDownloadId}`);\n    setButtonText(downloadButton, \"Downloading... (Click to Pause)\");\n    downloadButton.style.background = `linear-gradient(90deg, #ff5419 ${progress}%, transparent 0%)`;\n\n    // Only assign/re-assign the click handler if the button wasn't already in the \"Downloading\" state\n    // or if the handler is somehow missing.\n    // currentState reflects the state *before* this message.\n    if (currentState !== \"Downloading\" || !downloadButton.onclick) {\n      downloadButton.style.cursor = \"pointer\";\n      downloadButton.onclick = createPauseResumeHandler(finalDownloadId!);\n    }\n    // Ensure the state is marked as Downloading.\n    downloadButtons[finalDownloadId!].state = \"Downloading\";\n    // Update lastProgressTime, assuming it's a property in your DownloadButton interface for downloadButtons entries\n    if (downloadButtons[finalDownloadId!]) {\n      downloadButtons[finalDownloadId!].lastProgressTime = Date.now();\n    }\n  } else if (error) {\n    logger.logWarn(`[HANDLE_MSG_FROM_BG] Button state updated to Error: ${error}, finalDownloadId=${finalDownloadId}`);\n    resetButtonBackground(downloadButton); downloadButton.style.backgroundColor = \"#d30029\";\n    setButtonText(downloadButton, \"ERROR\", error); downloadButton.onclick = null;\n    downloadButtons[finalDownloadId!].state = \"Error\";\n  } else if (currentState === \"Preparing\" && progress !== undefined) {\n    logger.logDebug(`[HANDLE_MSG_FROM_BG] Button state forcibly updated from Preparing to Downloading, finalDownloadId=${finalDownloadId}`);\n    setButtonText(downloadButton, \"Downloading... (Click to Pause)\");\n    downloadButton.style.background = \"linear-gradient(90deg, #ff5419 \" + (progress || 0) + \"%, transparent 0%)\";\n    downloadButton.style.cursor = \"pointer\"; downloadButton.onclick = createPauseResumeHandler(finalDownloadId!);\n    downloadButtons[finalDownloadId!].state = \"Downloading\";\n  }\n  return Promise.resolve({ handled: true, id: finalDownloadId, finalState: downloadButtons[finalDownloadId!]?.state });\n};\n\nlogger.logDebug(\"[CONTENT_SCRIPT_LISTENER_SETUP] Attempting to set up onMessage listener NOW.\");\n\nif (typeof onMessage !== \"undefined\") {\n  onMessage(handleMessageFromBackgroundScript);\n  logger.logDebug(`[CONTENT_SCRIPT_LISTENER_SETUP] onMessage listener setup complete. Document readyState: ${document.readyState}`);\n} else {\n  logger.logDebug(\"[CONTENT_SCRIPT_SETUP_ERROR] onMessage utility is not defined!\");\n}\n\nconst createDownloadButton = (small?: boolean) => {\n  const button = document.createElement(\"button\");\n  const buttonSizeClass = small ? \"sc-button-small\" : \"sc-button-medium\";\n\n  button.className = `sc-button-download sc-button ${buttonSizeClass} sc-button-responsive`;\n  setButtonText(button, \"Download\");\n\n  return button;\n};\n\nconst createDownloadCommand = (url: string) => {\n  // Determine if the URL is for a playlist/set based on URL pattern\n  const isSetUrl = url.includes(\"/sets/\") || url.includes(\"/albums/\");\n\n  // DEBUG: Add extensive logging for playlist detection\n  logger.logDebug(`createDownloadCommand: URL=${url}, isSetUrl=${isSetUrl}`, { url, isSetUrl });\n\n  const command = (downloadId: string) => {\n    if (!downloadId) {\n      logger.logError(\"Attempted to send DOWNLOAD command with undefined/empty downloadId\", { url });\n      return Promise.reject(\"Undefined/empty downloadId for DOWNLOAD command\");\n    }\n    return loggedSendMessageToBackend({ // USE WRAPPER\n      type: isSetUrl ? \"DOWNLOAD_SET\" : \"DOWNLOAD\",\n      url,\n      downloadId,\n    }, \"createDownloadCommand\");\n  };\n\n  // Store the URL directly on the command function for use by the context menu\n  (command as any).url = url;\n  // Set the isSet flag to indicate if this is a set/playlist\n  (command as any).isSet = isSetUrl;\n\n  // DEBUG: Add verification log\n  logger.logDebug(`createDownloadCommand: Created command with isSet=${(command as any).isSet}`, { commandUrl: (command as any).url, isSet: (command as any).isSet });\n\n  return command;\n};\n\nconst addDownloadButtonToParent = (parent: Node & ParentNode, onClicked: OnButtonClicked & { url?: string; isSet?: boolean }, small?: boolean) => {\n  const downloadButtonExists = parent.querySelector(\"button.sc-button-download\") !== null;\n\n  if (downloadButtonExists) {\n    logger.logDebug(\"Download button already exists\");\n    return;\n  }\n\n  // Log the parent and the clicked URL details\n  logger.logDebug(\"Adding download button\", {\n    parentNode: parent.nodeName,\n    url: (onClicked as any).url,\n    isSet: (onClicked as any).isSet\n  });\n\n  const button = createDownloadButton(small);\n  const downloadUrl = (onClicked as any).url; // Store URL early to ensure it's available\n\n  // Debug URL to ensure it's correctly captured\n  logger.logInfo(`Button created with URL: ${downloadUrl}`);\n\n  const originalOnClick = async () => {\n    const downloadId: string = crypto.randomUUID();\n\n    // Store the button and URL information *immediately* when button is clicked\n    downloadButtons[downloadId] = {\n      elem: button,\n      onClick: originalOnClick, // Store self for potential reset\n      state: \"Preparing\",\n      originalUrl: downloadUrl, // Store URL needed for pause/resume context\n      lastProgressTime: Date.now() // Add timestamp for progress tracking\n    };\n\n    logger.logInfo(`Button clicked with downloadId: ${downloadId}, URL: ${downloadUrl}`);\n\n    button.style.cursor = \"default\";\n    button.onclick = null; // Disable direct click while preparing\n    setButtonText(button, \"Preparing...\");\n    resetButtonBackground(button); // Ensure clean background\n\n    // Add a safety timeout to reset button if we don't get progress updates\n    const safetyTimeout = setTimeout(() => {\n      const currentButtonData = downloadButtons[downloadId];\n      if (currentButtonData && currentButtonData.state === \"Preparing\") {\n        logger.logWarn(`Safety timeout triggered for downloadId=${downloadId}, button still in Preparing state`);\n        setButtonText(button, \"Timeout (Retry?)\");\n        button.title = \"Download request timed out. Click to try again.\";\n        button.style.backgroundColor = \"#d30029\"; // Error color\n        button.style.cursor = \"pointer\";\n        button.onclick = originalOnClick; // Re-enable click to let user retry\n        downloadButtons[downloadId].state = \"Error\"; // Mark as Error due to timeout\n      }\n    }, 10000); // 10 seconds safety timeout\n\n    // Add a completion safety timeout to prevent downloads from being stuck in Downloading state\n    // This needs to be much longer to account for large downloads\n    const completionTimeout = setTimeout(() => {\n      const currentButtonData = downloadButtons[downloadId];\n      if (currentButtonData && currentButtonData.state === \"Downloading\") {\n        const lastProgressTime = currentButtonData.lastProgressTime || 0;\n        const timeSinceLastProgress = Date.now() - lastProgressTime;\n\n        // If no progress updates for more than 2 minutes, consider it stuck\n        if (timeSinceLastProgress > 120000) { // 2 minutes\n          logger.logWarn(`Completion safety timeout triggered for downloadId=${downloadId}. Download seems stuck in Downloading state for ${timeSinceLastProgress / 1000}s`);\n\n          // Check if the download might have completed silently\n          if (timeSinceLastProgress > 180000) { // 3 minutes - assume potential completion\n            logger.logInfo(`Assuming potential silent completion for downloadId=${downloadId}`);\n            resetButtonBackground(button);\n            button.style.backgroundColor = \"#19a352\";\n            setButtonText(button, \"Downloaded!\");\n            button.title = \"Download likely completed (auto-detected)\";\n            button.onclick = null;\n            downloadButtons[downloadId].state = \"Downloaded\";\n            downloadButtons[downloadId].resetTimer = window.setTimeout(() => runResetLogic(downloadId), 10000);\n          } else {\n            // Just mark as potentially stuck but still downloading\n            logger.logInfo(`Marking download ${downloadId} as potentially stuck`);\n            setButtonText(button, \"Downloading... (may be stuck)\");\n          }\n        }\n      }\n    }, 300000); // 5 minutes timeout\n\n    // Execute the original download command (passed in as onClicked)\n    try {\n      const response = await onClicked(downloadId);\n      logger.logInfo(`Download command response for ${downloadId}:`, response);\n\n      // Clear safety timeout since we got a response\n      clearTimeout(safetyTimeout);\n\n      // Check if button is still in preparing state and update if needed\n      const currentButtonData = downloadButtons[downloadId];\n      if (currentButtonData && currentButtonData.state === \"Preparing\") {\n        logger.logInfo(`Manually transitioning button from Preparing to Downloading state for ${downloadId}`);\n        setButtonText(button, \"Downloading... (Click to Pause)\");\n        button.style.background = \"linear-gradient(90deg, #ff5419 0%, transparent 0%)\";\n        button.style.cursor = \"pointer\";\n        button.onclick = createPauseResumeHandler(downloadId);\n        downloadButtons[downloadId].state = \"Downloading\";\n        downloadButtons[downloadId].lastProgressTime = Date.now();\n      }\n    } catch (err) {\n      // Clear safety timeout since we got an error response\n      clearTimeout(safetyTimeout);\n      clearTimeout(completionTimeout);\n\n      logger.logError(`Initial download command failed for ${downloadUrl}`, err);\n      // Handle immediate failure case\n      if (downloadButtons[downloadId]) {\n        downloadButtons[downloadId].state = \"Error\";\n        setButtonText(button, \"ERROR\", err.message || \"Failed to start\");\n        button.style.backgroundColor = \"#d30029\";\n      }\n    }\n  };\n\n  // Add context menu for force redownload\n  button.oncontextmenu = (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n\n    // Remove any existing context menu\n    const existingMenu = document.getElementById(\"scdl-context-menu\");\n    if (existingMenu) document.body.removeChild(existingMenu);\n\n    // Create context menu\n    const menu = document.createElement(\"div\");\n    menu.id = \"scdl-context-menu\";\n    menu.style.position = \"absolute\";\n    menu.style.left = `${e.pageX}px`;\n    menu.style.top = `${e.pageY}px`;\n    menu.style.background = \"#fff\";\n    menu.style.boxShadow = \"0 2px 5px rgba(0,0,0,0.2)\";\n    menu.style.padding = \"5px 0\";\n    menu.style.borderRadius = \"3px\";\n    menu.style.zIndex = \"10000\";\n\n    document.body.appendChild(menu);\n\n    // Click elsewhere to dismiss\n    const dismissHandler = () => {\n      if (document.getElementById(\"scdl-context-menu\")) {\n        document.body.removeChild(menu);\n      }\n      document.removeEventListener(\"click\", dismissHandler);\n    };\n\n    document.addEventListener(\"click\", dismissHandler);\n\n    return false; // Prevent browser context menu\n  };\n\n  button.onclick = originalOnClick; // Assign the initial click handler\n\n  parent.appendChild(button);\n\n  // --- Add Range Button for Sets ---\n  const isSet = (onClicked as any).isSet;\n\n  // DEBUG: Add logging to verify isSet flag\n  logger.logInfo(\"Checking if should add range button:\", {\n    isSet,\n    url: (onClicked as any).url,\n    urlIncludes: {\n      sets: (onClicked as any).url?.includes(\"/sets/\"),\n      albums: (onClicked as any).url?.includes(\"/albums/\")\n    },\n    browserType: typeof browser !== \"undefined\" ? \"Firefox\" : \"Chrome\"\n  });\n\n  // Determine the final isSet value using the abstracted utility function\n  const finalIsSet = determineIfUrlIsSet(downloadUrl, isSet);\n\n  if (finalIsSet) {\n    // ... (range button logic remains the same, but ensure it uses the main button's state for updates)\n    const rangeButton = document.createElement(\"button\");\n\n    // DEBUG: Log that we're creating a range button\n    logger.logInfo(\"Creating range button for URL=\" + ((onClicked as any).url || \"unknown\"));\n\n    const rangeButtonSizeClass = small ? \"sc-button-small\" : \"sc-button-medium\"; // Match size\n    rangeButton.className = `sc-button-range sc-button ${rangeButtonSizeClass} sc-button-responsive`;\n    rangeButton.textContent = \"Range...\";\n    rangeButton.title = \"Download a range of tracks\";\n    rangeButton.style.marginLeft = \"5px\"; // Add some space\n\n    rangeButton.onclick = (e) => {\n      e.preventDefault(); // Prevent form submission if inside one\n      e.stopPropagation(); // Prevent triggering other clicks\n\n      // IMPORTANT: Create a downloadId and store button info BEFORE opening the modal\n      const preDownloadId: string = crypto.randomUUID();\n\n      // Store the button with the URL information before the modal is even shown\n      downloadButtons[preDownloadId] = {\n        elem: button,\n        onClick: originalOnClick,\n        state: \"Idle\", // Not preparing yet until user confirms\n        originalUrl: downloadUrl, // Use the URL captured when the button was created\n        lastProgressTime: Date.now() // Add timestamp for progress tracking\n      };\n\n      logger.logInfo(`Range button clicked. Created preDownloadId: ${preDownloadId}, with URL: ${downloadUrl}`);\n\n      // Prepare the handler for the modal's Download button\n      const handleRangeDownload = (start: number, end: number | null) => {\n        // Use our pre-created downloadId instead of searching\n        const mainButtonId = preDownloadId;\n\n        logger.logInfo(`Range download handler called with start=${start}, end=${end}, mainButtonId=${mainButtonId}`);\n\n        const buttonData = downloadButtons[mainButtonId];\n\n        // Debug the buttonData to see what's available\n        logger.logInfo(\"Button data for range download:\", {\n          hasButtonData: !!buttonData,\n          originalUrl: buttonData?.originalUrl,\n          state: buttonData?.state\n        });\n\n        if (!buttonData || !buttonData.originalUrl) {\n          logger.logError(`Range download failed: No button data or URL for ID ${mainButtonId}`);\n          const errorDiv = document.getElementById(\"scdl-range-modal-error\");\n          if (errorDiv) {\n            errorDiv.textContent = \"Error: Could not get original URL for the playlist.\";\n            errorDiv.style.display = \"block\";\n          }\n          return;\n        }\n\n        // Update button text to \"Preparing...\"\n        setButtonText(buttonData.elem, \"Preparing...\");\n        buttonData.elem.style.cursor = \"default\";\n        buttonData.elem.onclick = null;\n        buttonData.state = \"Preparing\";\n        buttonData.lastProgressTime = Date.now();\n\n        // Add safety timeout for range downloads too\n        const safetyTimeout = setTimeout(() => {\n          if (downloadButtons[mainButtonId] && downloadButtons[mainButtonId].state === \"Preparing\") {\n            logger.logWarn(`Safety timeout triggered for range download with ID ${mainButtonId}`);\n            setButtonText(buttonData.elem, \"Timeout (Retry?)\"); // MODIFIED\n            buttonData.elem.title = \"Range download request timed out. Click to try again.\"; // MODIFIED\n            buttonData.elem.style.backgroundColor = \"#d30029\"; // MODIFIED // Error color\n            buttonData.elem.style.cursor = \"pointer\";\n            buttonData.elem.onclick = originalOnClick; // Allow retrying with regular download\n            downloadButtons[mainButtonId].state = \"Error\"; // MODIFIED // Mark as Error due to timeout\n          }\n        }, 15000); // Slightly longer timeout for range downloads\n\n        // Add a completion safety timeout specifically for range downloads\n        // Since range downloads can take longer, we use a longer timeout\n        const completionTimeout = setTimeout(() => {\n          const currentButtonData = downloadButtons[mainButtonId];\n          if (currentButtonData && (currentButtonData.state === \"Downloading\" || currentButtonData.state === \"Preparing\")) {\n            const lastProgressTime = currentButtonData.lastProgressTime || 0;\n            const timeSinceLastProgress = Date.now() - lastProgressTime;\n\n            // If no progress updates for more than 5 minutes, consider it potentially stuck\n            if (timeSinceLastProgress > 300000) { // 5 minutes\n              logger.logWarn(`Range download completion safety timeout triggered for ID ${mainButtonId}. Download seems stuck for ${timeSinceLastProgress / 1000}s`);\n\n              // For range downloads, after 10 minutes, assume it might have completed silently\n              if (timeSinceLastProgress > 1800000) { // 30 minutes\n                logger.logInfo(`Assuming potential silent completion for range download ${mainButtonId}`);\n                resetButtonBackground(buttonData.elem);\n                buttonData.elem.style.backgroundColor = \"#19a352\";\n                setButtonText(buttonData.elem, \"Downloaded!\");\n                buttonData.elem.title = \"Range download likely completed (auto-detected)\";\n                buttonData.elem.onclick = null;\n                downloadButtons[mainButtonId].state = \"Downloaded\";\n                downloadButtons[mainButtonId].resetTimer = window.setTimeout(() => runResetLogic(mainButtonId), 10000);\n              } else {\n                // Just mark as potentially stuck but still downloading\n                logger.logInfo(`Marking range download ${mainButtonId} as potentially stuck`);\n                setButtonText(buttonData.elem, \"Downloading range... (may be stuck)\");\n              }\n            }\n          }\n        }, 1800000); // 30 minutes timeout for range downloads\n\n        // Log the message we're about to send\n        logger.logInfo(\"Sending range download message:\", {\n          type: \"DOWNLOAD_SET_RANGE\",\n          url: buttonData.originalUrl,\n          start,\n          end,\n          downloadId: mainButtonId\n        });\n\n        // Send the message with full logging\n        loggedSendMessageToBackend({\n          type: \"DOWNLOAD_SET_RANGE\",\n          url: buttonData.originalUrl,\n          start,\n          end,\n          downloadId: mainButtonId,\n        }, \"handleRangeDownload\").then(response => {\n          // Clear safety timeout on response\n          clearTimeout(safetyTimeout);\n\n          logger.logInfo(\"Range download response:\", response);\n\n          // Manually update button if still in Preparing state\n          if (downloadButtons[mainButtonId] && downloadButtons[mainButtonId].state === \"Preparing\") {\n            logger.logInfo(`Manually transitioning range button from Preparing to Downloading state for ${mainButtonId}`);\n            setButtonText(buttonData.elem, \"Downloading... (Click to Pause)\");\n            buttonData.elem.style.background = \"linear-gradient(90deg, #ff5419 0%, transparent 0%)\";\n            buttonData.elem.style.cursor = \"pointer\";\n            buttonData.elem.onclick = createPauseResumeHandler(mainButtonId);\n            downloadButtons[mainButtonId].state = \"Downloading\";\n            downloadButtons[mainButtonId].lastProgressTime = Date.now();\n          }\n        }).catch(error => {\n          // Clear safety timeout on error\n          clearTimeout(safetyTimeout);\n          clearTimeout(completionTimeout);\n\n          logger.logError(\"Range download request failed:\", error);\n\n          // Update button to error state\n          if (downloadButtons[mainButtonId]) {\n            resetButtonBackground(buttonData.elem);\n            buttonData.elem.style.backgroundColor = \"#d30029\";\n            setButtonText(buttonData.elem, \"ERROR\", error?.message || \"Range download failed\");\n            buttonData.elem.onclick = null;\n            downloadButtons[mainButtonId].state = \"Error\";\n          }\n        });\n      };\n\n      showModal(button, handleRangeDownload);\n    };\n    parent.appendChild(rangeButton);\n  }\n  // --------------------------------\n};\n\nconst removeElementFromParent = (element: Element) => {\n  element.parentNode.removeChild(element);\n};\n\nconst removeElementsMatchingSelectors = (selectors: string) => {\n  const elements = document.querySelectorAll(selectors);\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    removeElementFromParent(element);\n  }\n};\n\nconst removeBuyLinks = () => {\n  const selector = \"a.sc-buylink\";\n\n  removeElementsMatchingSelectors(selector);\n\n  const event: ObserverEvent = {\n    selector,\n    callback: (node) => removeElementFromParent(node),\n  };\n\n  observer?.addEvent(event);\n};\n\nconst removeDownloadButtons = () => {\n  removeElementsMatchingSelectors(\"button.sc-button-download\");\n};\n\nconst addDownloadButtonToTrackPage = () => {\n  const selector = \".sc-button-group-medium > .sc-button-like\";\n  logger.logDebug(`[TrackPage] Querying for selector: ${selector}`);\n\n  const addDownloadButtonToPossiblePlaylist = (node: Element) => {\n    logger.logDebug(\"[TrackPage] Found node matching selector:\", node);\n    const downloadUrl = window.location.origin + window.location.pathname;\n    const downloadCommand = createDownloadCommand(downloadUrl);\n    // Pass the downloadCommand which includes the isSet flag\n    addDownloadButtonToParent(node.parentNode, downloadCommand, false);\n  };\n\n  document.querySelectorAll(selector).forEach(addDownloadButtonToPossiblePlaylist);\n\n  const event: ObserverEvent = {\n    selector,\n    callback: addDownloadButtonToPossiblePlaylist,\n  };\n\n  observer?.addEvent(event);\n  logger.logDebug(`[TrackPage] Initial elements found: ${document.querySelectorAll(selector).length}`);\n};\n\nconst addDownloadButtonToFeed = () => {\n  const selector = \".sound.streamContext .sc-button-group > .sc-button-like\";\n  logger.logDebug(`[Feed] Querying for selector: ${selector}`);\n\n  const addDownloadButtonToPossiblePlaylist = (node: Element) => {\n    logger.logDebug(\"[Feed] Found node matching selector:\", node);\n    const soundBody = node.parentElement.closest(\".sound__body\");\n    const titleLink = soundBody.querySelector(\"a.soundTitle__title\");\n\n    if (titleLink === null) {\n      return;\n    }\n\n    const downloadUrl = window.location.origin + titleLink.getAttribute(\"href\");\n    const downloadCommand = createDownloadCommand(downloadUrl);\n    // Pass the downloadCommand which includes the isSet flag\n    addDownloadButtonToParent(node.parentNode, downloadCommand, true);\n  };\n\n  document.querySelectorAll(selector).forEach(addDownloadButtonToPossiblePlaylist);\n\n  const event: ObserverEvent = {\n    selector,\n    callback: addDownloadButtonToPossiblePlaylist,\n  };\n\n  observer?.addEvent(event);\n  logger.logDebug(`[Feed] Initial elements found: ${document.querySelectorAll(selector).length}`);\n};\n\nconst handleBlockRepostsConfigChange = (blockReposts: boolean) => {\n  let script = document.querySelector<HTMLScriptElement>(\"#repost-blocker\");\n\n  if (blockReposts) {\n    if (script) {\n      logger.logWarn(\"Repost-Blocker script has already been injected!\");\n\n      return;\n    }\n\n    const payloadFile = getPathFromExtensionFile(\"/js/repostBlocker.js\");\n\n    if (!payloadFile) return;\n\n    logger.logInfo(\"Start blocking reposts\");\n\n    script = document.createElement(\"script\");\n    script.type = \"text/javascript\";\n    script.id = \"repost-blocker\";\n    script.src = payloadFile;\n\n    document.documentElement.appendChild(script);\n  } else {\n    if (!script) return;\n\n    logger.logInfo(\"Stop blocking reposts\");\n\n    const cleanupScript = document.createElement(\"script\");\n    cleanupScript.type = \"text/javascript\";\n    cleanupScript.id = \"cleanup-repost-blocker\";\n    cleanupScript.innerText = \"XMLHttpRequest.prototype.resetSend();\";\n\n    document.documentElement.appendChild(cleanupScript);\n\n    document.documentElement.removeChild(script);\n    document.documentElement.removeChild(cleanupScript);\n  }\n};\n\nconst handlePageLoaded = async () => {\n  logger.logInfo(\"handlePageLoaded executing...\");\n  observer = new DomObserver();\n\n  removeBuyLinks();\n\n  removeDownloadButtons();\n\n  addDownloadButtonToTrackPage();\n\n  addDownloadButtonToFeed();\n\n  // Add specific function for playlists/sets\n  addDownloadButtonToPlaylistPage();\n\n  observer.start(document.body);\n\n  logger.logInfo(\"Attached!\");\n};\n\n// Add this new function to explicitly handle playlists\nconst addDownloadButtonToPlaylistPage = () => {\n  logger.logInfo(\"[PlaylistPage] Running playlist button initialization\");\n\n  // Check if we're on a playlist/set page\n  const isPlaylistPage = window.location.pathname.includes(\"/sets/\") ||\n    window.location.pathname.includes(\"/albums/\") ||\n    document.querySelector(\".setTrackList\") !== null;\n\n  if (!isPlaylistPage) {\n    logger.logDebug(\"[PlaylistPage] Not on a playlist page, skipping\");\n    return;\n  }\n\n  logger.logInfo(\"[PlaylistPage] Detected playlist page, adding download button\");\n\n  // Try multiple potential targets for button placement\n  const possibleSelectors = [\n    // Track list header\n    \".soundActions .sc-button-group\",\n    // Header actions\n    \".soundHeader__actions .sc-button-group\",\n    // Like button container\n    \".sc-button-like\",\n    // Play button\n    \".playControls__play\",\n    // Set Actions\n    \".setActions .sc-button-group\"\n  ];\n\n  // Log all present elements we might try to use\n  for (const selector of possibleSelectors) {\n    const elements = document.querySelectorAll(selector);\n    logger.logDebug(`[PlaylistPage] Found ${elements.length} elements matching \"${selector}\"`);\n  }\n\n  // Try to find a suitable button parent from our selector options\n  let buttonParent = null;\n  for (const selector of possibleSelectors) {\n    const element = document.querySelector(selector);\n    if (element) {\n      buttonParent = element;\n      logger.logInfo(`[PlaylistPage] Found button parent: ${selector}`);\n      break;\n    }\n  }\n\n  // If we didn't find a button parent through direct selectors, try an alternative approach\n  if (!buttonParent) {\n    logger.logWarn(\"[PlaylistPage] No direct button parent found, trying alternative approach\");\n\n    // Find the main playlist container\n    const playlistContainer = document.querySelector(\".trackList\") ||\n      document.querySelector(\".setTrackList\");\n\n    if (playlistContainer) {\n      // Look for existing elements that we can insert before/after\n      const existingButton = document.querySelector(\".sc-button-like\") ||\n        document.querySelector(\".sc-button-share\") ||\n        document.querySelector(\".sc-button-play\");\n\n      if (existingButton && existingButton.parentNode) {\n        buttonParent = existingButton.parentNode;\n        logger.logInfo(\"[PlaylistPage] Found button parent via existing button\", buttonParent);\n      } else {\n        // Create our own button container if absolutely needed\n        const tracklistHeader = playlistContainer.querySelector(\".tracklistHeader\") ||\n          playlistContainer.querySelector(\".setTrackList__header\");\n\n        if (tracklistHeader) {\n          buttonParent = document.createElement(\"div\");\n          buttonParent.className = \"sc-button-group sc-button-group-medium\";\n          tracklistHeader.appendChild(buttonParent);\n          logger.logInfo(\"[PlaylistPage] Created custom button parent in tracklist header\");\n        }\n      }\n    }\n  }\n\n  if (buttonParent) {\n    // Get the URL of the current page (the playlist)\n    const downloadUrl = window.location.origin + window.location.pathname;\n    logger.logInfo(`[PlaylistPage] Creating download command for: ${downloadUrl}`);\n\n    // Create a command with explicit isSet flag\n    const command = createDownloadCommand(downloadUrl);\n    (command as any).isSet = true; // Force the isSet flag to true\n\n    logger.logInfo(\"[PlaylistPage] Adding download button to parent:\", buttonParent);\n    addDownloadButtonToParent(buttonParent, command, false);\n  } else {\n    logger.logError(\"[PlaylistPage] Could not find or create button parent for playlist page\");\n  }\n};\n\nconst documentState = document.readyState;\n\nif (documentState === \"complete\" || documentState === \"interactive\") {\n  setTimeout(handlePageLoaded, 0);\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", handlePageLoaded);\n\n// Add a periodic check for stuck downloads that runs every 60 seconds\nlet stuckDownloadCheckInterval: number | null = null;\n\nfunction startStuckDownloadChecker() {\n  if (stuckDownloadCheckInterval !== null) {\n    clearInterval(stuckDownloadCheckInterval);\n  }\n\n  stuckDownloadCheckInterval = window.setInterval(() => {\n    const now = Date.now();\n    const activeDownloadIds = Object.keys(downloadButtons);\n\n    if (activeDownloadIds.length === 0) return;\n\n    logger.logDebug(`Running stuck download check for ${activeDownloadIds.length} active downloads`);\n\n    activeDownloadIds.forEach(downloadId => {\n      const buttonData = downloadButtons[downloadId];\n      if (!buttonData) return;\n\n      // We're only concerned with buttons that might be stuck in \"Downloading\" state\n      if (buttonData.state === \"Downloading\") {\n        const lastProgressTime = buttonData.lastProgressTime || 0;\n        const idleTime = now - lastProgressTime;\n\n        // If no progress updates for more than 5 minutes\n        if (idleTime > 300000) {\n          logger.logWarn(`Download ${downloadId} has been idle for ${Math.floor(idleTime / 1000)}s`);\n\n          // If download has been idle for more than 10 minutes, assume it completed\n          if (idleTime > 600000) {\n            logger.logInfo(`Auto-completing download ${downloadId} due to long inactivity (${Math.floor(idleTime / 1000)}s)`);\n\n            resetButtonBackground(buttonData.elem);\n            buttonData.elem.style.backgroundColor = \"#19a352\";\n            buttonData.elem.title = \"Download likely completed (auto-detected)\";\n            buttonData.elem.onclick = null;\n            buttonData.state = \"Downloaded\";\n\n            // Set timer to reset button to idle state\n            if (buttonData.resetTimer) {\n              clearTimeout(buttonData.resetTimer);\n            }\n            buttonData.resetTimer = window.setTimeout(() => runResetLogic(downloadId), 10000);\n          }\n          // If download has been idle for 5+ minutes but less than 10 minutes, update the text\n          else {\n            setButtonText(buttonData.elem, \"Downloading... (may be stuck)\");\n            buttonData.elem.title = `No progress for ${Math.floor(idleTime / 60000)} minutes. Click to pause/resume.`;\n          }\n        }\n      }\n    });\n  }, 60000); // Check every minute\n\n  logger.logInfo(\"Started automatic stuck download checker\");\n}\n\nfunction stopStuckDownloadChecker() {\n  if (stuckDownloadCheckInterval !== null) {\n    clearInterval(stuckDownloadCheckInterval);\n    stuckDownloadCheckInterval = null;\n    logger.logInfo(\"Stopped automatic stuck download checker\");\n  }\n}\n\nwindow.onbeforeunload = () => {\n  observer?.stop();\n  stopStuckDownloadChecker();\n  logger.logInfo(\"Unattached!\");\n};\n\n// Initialize stuck download checker along with other page initialization\nfunction initializeDownloadCheckers() {\n  startStuckDownloadChecker();\n}\n\n// Call to start the checker when page is loaded\nif (documentState === \"complete\" || documentState === \"interactive\") {\n  setTimeout(initializeDownloadCheckers, 1000); // Start slightly after main initialization\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  setTimeout(initializeDownloadCheckers, 1000);\n});\n\nfunction writeConfigValueToLocalStorage(key: string, value: any) {\n  const item = JSON.stringify(value);\n\n  window.localStorage.setItem(\"SOUNDCLOUD-DL-\" + key, item);\n}\n\n// Removed direct loadConfiguration call. Configuration will be fetched from background.\nlogger.logInfo(\"[ContentScript] Requesting configuration from background script...\");\nloggedSendMessageToBackend({ type: \"GET_EXTENSION_CONFIG\" }, \"ContentScript_GetConfig\")\n  .then((loadedConfigFromBg: Partial<Record<keyof Config, { value: any }>>) => {\n    if (!loadedConfigFromBg) {\n      logger.logError(\"[ContentScript] Failed to load configuration from background script. Received undefined or null.\");\n      // Potentially use default values or show an error to the user\n      return;\n    }\n\n    logger.logInfo(\"[ContentScript] Configuration received from background:\", loadedConfigFromBg);\n\n    // Populate page's localStorage with non-secret values from the received config\n    for (const key of Object.keys(loadedConfigFromBg)) {\n      if (configKeys.includes(key as keyof Config)) {\n        const configKey = key as keyof Config;\n        // The received config from background should already be filtered for secrets,\n        // but we double-check or assume it's pre-filtered.\n        // The original `config` object from `utils/config` isn't fully populated here,\n        // so checking `config[configKey].secret` might be unreliable.\n        // We rely on the background script to only send non-secret values.\n        writeConfigValueToLocalStorage(configKey, loadedConfigFromBg[configKey]?.value);\n\n        // Directly update the value in the local 'config' object if needed for other functions.\n        // This is a tricky part, as `content.ts` doesn't \"own\" the config state.\n        // For now, we'll assume functions like `handleBlockRepostsConfigChange`\n        // will eventually be adapted or get values directly.\n      }\n    }\n\n    // Handle specific config actions, e.g., 'block-reposts'\n    const blockRepostsConfig = loadedConfigFromBg[\"block-reposts\"];\n    if (blockRepostsConfig && typeof blockRepostsConfig.value === \"boolean\") {\n      logger.logInfo(`[ContentScript] Setting up block-reposts based on received config: ${blockRepostsConfig.value}`);\n      handleBlockRepostsConfigChange(blockRepostsConfig.value);\n    } else {\n      logger.logWarn(\"[ContentScript] 'block-reposts' configuration not found or invalid in object from background.\");\n      // Optionally, apply a default behavior for block-reposts if not received\n      // handleBlockRepostsConfigChange(false); // Example: default to false\n    }\n\n    // TODO: Implement a mechanism for content.ts to react to ongoing config changes.\n    // This will likely involve the background script sending messages to content.ts\n    // when a config value it cares about is updated in the extension's storage.\n    // setOnConfigValueChanged(writeConfigValueToLocalStorage); // This was tied to the old direct load.\n    // registerConfigChangeHandler(\"block-reposts\", handleBlockRepostsConfigChange); // This also needs rethinking.\n\n    logger.logInfo(\"[ContentScript] Initial configuration applied.\");\n\n  }).catch(err => {\n    logger.logError(\"[ContentScript] Error requesting or processing configuration from background script:\", err);\n    // Fallback or error display logic if config loading fails\n    // For example, could try to load defaults for critical features or show a notification.\n    // As a minimal fallback for block-reposts:\n    // handleBlockRepostsConfigChange(false); // Default to not blocking if config fails\n  });\n\n// --- Function to create the pause/resume click handler ---\nconst createPauseResumeHandler = (downloadId: string): (() => Promise<void>) => {\n  return async () => {\n    const buttonData = downloadButtons[downloadId];\n    if (!buttonData) {\n      logger.logWarn(`Pause/Resume: Button data not found for downloadId: ${downloadId}`);\n      return;\n    }\n\n    if (!downloadId) { // Should not happen if buttonData was found, but as a safeguard\n      logger.logError(\"Attempted to send PAUSE/RESUME command with undefined/empty downloadId.\");\n      return;\n    }\n\n    // Current state of the button before this click action\n    const currentButtonState = buttonData.state;\n\n    if (currentButtonState === \"Downloading\" || currentButtonState === \"Resuming\") {\n      // Immediately update UI to \"Pausing...\" and set state\n      logger.logInfo(`[PAUSE_CLICK] User clicked Pause for ${downloadId}. Current state: ${currentButtonState}. Transitioning to Pausing.`);\n      setButtonText(buttonData.elem, \"Pausing...\");\n      buttonData.elem.style.cursor = \"default\"; // Indicate non-interactive while command is processed\n      buttonData.elem.onclick = null; // Prevent rapid re-clicks\n      buttonData.state = \"Pausing\";\n      buttonData.lastProgressTime = Date.now(); // Update time to reflect this action\n\n      await loggedSendMessageToBackend({ type: \"PAUSE_DOWNLOAD\", downloadId }, \"createPauseResumeHandler-Pause\");\n    } else if (currentButtonState === \"Paused\") {\n      // Immediately update UI to \"Resuming...\" and set state\n      logger.logInfo(`[RESUME_CLICK] User clicked Resume for ${downloadId}. Current state: ${currentButtonState}. Transitioning to Resuming.`);\n      setButtonText(buttonData.elem, \"Resuming...\");\n      buttonData.elem.style.cursor = \"default\"; // Indicate non-interactive\n      buttonData.elem.onclick = null; // Prevent rapid re-clicks\n      buttonData.state = \"Resuming\";\n      buttonData.lastProgressTime = Date.now(); // Update time\n\n      await loggedSendMessageToBackend({ type: \"RESUME_DOWNLOAD\", downloadId }, \"createPauseResumeHandler-Resume\");\n    } else {\n      logger.logWarn(`[PAUSE_RESUME_CLICK] Clicked on button for ${downloadId} but state is '${currentButtonState}', not Downloading/Resuming or Paused. No action taken.`);\n    }\n  };\n};\n\n// Define a function to run the reset logic for any download ID\nfunction runResetLogic(downloadId: string, newState: \"Idle\" | \"Error\" = \"Idle\") {\n  const buttonData = downloadButtons[downloadId];\n  if (!buttonData) return;\n\n  const { elem: downloadButton, onClick: originalOnClick } = buttonData;\n\n  // Start fade-out by resetting background\n  resetButtonBackground(downloadButton);\n  // After fade, reset text and handlers\n  setTimeout(() => {\n    if (downloadButtons[downloadId]) { // Check *again*\n      setButtonText(downloadButton, newState === \"Error\" ? \"ERROR\" : \"Download\");\n      downloadButton.title = newState === \"Error\" ? (\"Error occurred\") : \"Download\";\n      downloadButton.style.cursor = \"pointer\";\n      // Re-attach the *original* click handler, NOT the pause/resume one\n      downloadButton.onclick = originalOnClick;\n      downloadButtons[downloadId].state = newState === \"Error\" ? \"Error\" : \"Idle\";\n      // Only delete if fully reset to Idle, not if ending in Error state\n      if (newState === \"Idle\") {\n        delete downloadButtons[downloadId];\n      }\n    }\n  }, 500); // Delay matches CSS transition duration\n}\n\n// Add a debug function to periodically check the active downloads\nlet debugIntervalId: number | null = null;\n\nfunction startDebugLogging() {\n  if (debugIntervalId !== null) {\n    clearInterval(debugIntervalId);\n  }\n\n  debugIntervalId = window.setInterval(() => {\n    const activeDownloadIds = Object.keys(downloadButtons);\n    if (activeDownloadIds.length === 0) return;\n\n    logger.logDebug(`DEBUG: Currently tracking ${activeDownloadIds.length} active downloads`);\n\n    activeDownloadIds.forEach(downloadId => {\n      const buttonData = downloadButtons[downloadId];\n      if (!buttonData) return;\n\n      logger.logDebug(`DEBUG: Download ${downloadId} - State=${buttonData.state}, browserDownloadId=${buttonData.browserDownloadId || \"none\"}, lastProgress=${buttonData.lastProgressTime ? new Date(buttonData.lastProgressTime).toISOString() : \"none\"}`);\n    });\n  }, 10000); // Log every 10 seconds\n\n  logger.logInfo(\"Started debug logging for downloads\");\n}\n\n// Call to start the debug logger when page is loaded\nif (documentState === \"complete\" || documentState === \"interactive\") {\n  setTimeout(startDebugLogging, 2000); // Start after other initialization\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  setTimeout(startDebugLogging, 2000);\n});\n"],"names":["DomObserver","mutations","mutation","Logger","node","event","name","target","newNodes","nodes","recursive","i","element","selectors","modalCss","modalElement","createModal","style","hideModal","e","showModal","mainDownloadButton","onDownloadClick","fromInput","toInput","errorDiv","downloadBtn","newDownloadBtn","start","endStr","end","setButtonText","observer","logger","originalSendMessageToBackend","sendMessageToBackend","loggedSendMessageToBackend","message","callContext","messageToLog","error","downloadButtons","button","text","title","resetButtonBackground","handleMessageFromBackgroundScript","messagePayload","sender","uniqueCallId","currentButtonKeys","payloadString","senderString","relevantKeys","messageKeys","isRelevantMessage","key","receivedDownloadIdFromPayload","progress","status","completionWithoutId","completed","timestamp","browserDownloadId","originalIdFromPayload","finalDownloadId","matchedDownloadIds","id","buttonData","runResetLogic","allPotentiallyActiveStates","currentActiveDownloads","isMinimalMessage","activeIdsForCompletionLogic","matchedId","mostRecentId","mostRecentTime","lastTime","isErrorObject","isErrorString","currentKeysForWarning","payloadStringForWarning","downloadButton","resetTimer","currentState","createPauseResumeHandler","onMessage","createDownloadButton","small","buttonSizeClass","createDownloadCommand","url","isSetUrl","command","downloadId","addDownloadButtonToParent","parent","onClicked","downloadUrl","originalOnClick","safetyTimeout","currentButtonData","completionTimeout","lastProgressTime","timeSinceLastProgress","response","err","existingMenu","menu","dismissHandler","isSet","determineIfUrlIsSet","rangeButton","rangeButtonSizeClass","preDownloadId","mainButtonId","removeElementFromParent","removeElementsMatchingSelectors","elements","removeBuyLinks","selector","removeDownloadButtons","addDownloadButtonToTrackPage","addDownloadButtonToPossiblePlaylist","downloadCommand","addDownloadButtonToFeed","titleLink","handleBlockRepostsConfigChange","blockReposts","script","payloadFile","getPathFromExtensionFile","cleanupScript","handlePageLoaded","addDownloadButtonToPlaylistPage","possibleSelectors","buttonParent","playlistContainer","existingButton","tracklistHeader","documentState","stuckDownloadCheckInterval","startStuckDownloadChecker","now","activeDownloadIds","idleTime","stopStuckDownloadChecker","initializeDownloadCheckers","writeConfigValueToLocalStorage","value","item","loadedConfigFromBg","configKeys","configKey","blockRepostsConfig","currentButtonState","newState","debugIntervalId","startDebugLogging"],"mappings":"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"}